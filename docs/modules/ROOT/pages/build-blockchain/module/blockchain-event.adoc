= How to create a blockchain event
Mona Bärenfänger <mona@lightcurve.io>
:toc: preamble
:idprefix:
:idseparator: -
:docs_sdk: lisk-sdk::
// URLs
// Project URLS
:url_build_plugin: build-blockchain/create-plugin.adoc

====
On this page, you'll learn how to:

* [x] Create a new blockchain event
* [x] Register the event in the module
* [x] Emit the event in the module inside a module life cycle hook
* [ ] Listen to the event.
For an example of how to listen to the event, check out the guide xref:{url_build_plugin}[]
====

Blockchain events, or module events, are logs of events that occur in the blockchain network during block execution.
Events occur per block, and are stored in the respective block header, from where they can be queried.

[CAUTION]
====
By default, a blockchain event is only stored for 300 blocks on-chain, then it is removed, to reduce the overall database size and increase scalability.

If desired, the time that events are kept in the database can be increased in the node config under `system.keepEventsForHeights`.
====

For the Hello module, we implement a simple blockchain event as an example: The "New Hello" event.

This event should be emitted every time a new "Create Hello" command is executed on a node.


== Create a new event type

First, define the corresponding interface for the event in `types.ts`.
The event data shall contain the address of the sender of the Hello message, and the Hello message that was sent.

.hello/types.ts
[source,typescript]
----
export interface NewHelloEventData {
	senderAddress: Buffer;
	message: string;
}
----

Define the corresponding schema in `schema.ts`, too.

.hello/schema.ts
[source,typescript]
----
export const newHelloEventSchema = {
	$id: '/hello/events/new_hello',
	type: 'object',
	required: ['senderAddress', 'message'],
	properties: {
		senderAddress: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		message: {
			dataType: 'string',
			fieldNumber: 2,
		},
	},
};
----

Create a new file called `new_hello.ts` inside the `events/` folder of the module, and import the above-defined interface and schema.
To create the event class, also import the `BaseEvent` and `EventQueuer` from the `lisk-sdk`.

.hello/events/new_hello.ts
[source,typescript]
----
import { BaseEvent, EventQueuer } from 'lisk-sdk';
import { newHelloEventSchema } from '../schema';
import { NewHelloEventData } from '../types';

export class NewHelloEvent extends BaseEvent<NewHelloEventData> {
	public schema = newHelloEventSchema;

	public log(ctx: EventQueuer, data: NewHelloEventData): void {
		this.add(ctx, data, [data.senderAddress]);
	}
}
----

The new event class is created by extending from the `BaseEvent`.

Inside of the event class, we need to define the following properties:

* `schema`: Defines the schema of the event data
* `log()`: A method to emit the event and add it to the event queue of the node.

== Register the event

Now that we created a new event type, import it into the `module.ts` file, and register the event in the module constructor.

[source,typescript]
----
import { NewHelloEvent } from './events/new_hello';
// [...]

export class HelloModule extends BaseModule {
    // [...]

    public constructor() {
        super();
        // registration of stores and events
        // [...]
        this.events.register(NewHelloEvent, new NewHelloEvent(this.name));
    }
    // [...]
}
----

== Emit the event

Now that the event is registered with the module, you can call the `log()` method of the event at any time inside the module.

In this example, we want to emit the "New Hello" event every time a "Create Hello" command was executed, so we add the corresponding logic to the `afterCommandExecute()` module lifecycle hook.

[source,typescript]
----
import { NewHelloEvent } from './events/new_hello';
import { createHelloSchema, CreateHelloParams, configSchema } from './schema';
// [...]

export class HelloModule extends BaseModule {
    // [...]

    public async afterCommandExecute(context: TransactionExecuteContext): Promise<void> {
        // Get the "New Hello" event
        const newHelloEvent = this.events.get(NewHelloEvent);
        // Decode the command parameters
        const createHelloParams: CreateHelloParams = codec.decode<CreateHelloParams>(createHelloSchema, context.transaction.params);
        context.logger.info(createHelloParams,"createHelloParams")
        // Use the log() method of the event to emit the event
        newHelloEvent.log(context.getMethodContext(), {
            senderAddress: context.transaction.senderAddress,
            message: createHelloParams.message
        });

    }
    // [...]
}
----

Now, the module will create a new event every time a "Create Hello" command is executed, and the event will include the sender address and the sent Hello message.

NOTE: An example of how to listen to a specific event can be found in the guide xref:{url_build_plugin}[].
