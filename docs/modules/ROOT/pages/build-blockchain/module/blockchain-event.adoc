= How to create a blockchain event
Mona Bärenfänger <mona@lightcurve.io>
:toc: preamble
:idprefix:
:idseparator: -
:docs_sdk: lisk-sdk::
// URLs
// Project URLS
:url_build_plugin: build-blockchain/create-plugin.adoc

====
On this page, you'll learn how to...:

* [x] Create a new blockchain event.
* [x] Register the event in the module.
* [x] Emit the event in the module inside a module life cycle hook.
* [ ] Listen to the event.
For an example how to listen to the event, check out the guide xref:{url_build_plugin}[].
====

Blockchain events, or module events, are logs of events that occur in the blockchain network during block execution.
Events occur per block, and are stored in the respective block header, from where they can be queried.

[CAUTION]
====
By default, a blockchain event is only stored for 300 blocks on-chain, then it is removed, to reduce the overall database size and increase scalability.

If desired, the time that events are kept in the database can be increased in the node config under `system.keepEventsForHeights`.
====


== Create a new event type

.hello/types.ts
[source,typescript]
----
export interface NewHelloEventData {
	senderAddress: Buffer;
	message: string;
}
----

.hello/schema.ts
[source,typescript]
----
export const newHelloEventSchema = {
	$id: '/hello/events/new_hello',
	type: 'object',
	required: ['senderAddress', 'message'],
	properties: {
		senderAddress: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		message: {
			dataType: 'string',
			fieldNumber: 2,
		},
	},
};
----

[source,typescript]
----
import { BaseEvent, EventQueuer } from 'lisk-sdk';
import { newHelloEventSchema } from '../schema';
import { NewHelloEventData } from '../types';

export class NewHelloEvent extends BaseEvent<NewHelloEventData> {
	public schema = newHelloEventSchema;

	public log(ctx: EventQueuer, data: NewHelloEventData): void {
		this.add(ctx, data, [data.senderAddress]);
	}
}
----

== Register the event

[source,typescript]
----
import { NewHelloEvent } from './events/new_hello';
// [...]

export class HelloModule extends BaseModule {
    // [...]

    public constructor() {
        super();
        // registration of stores and events
        // [...]
        this.events.register(NewHelloEvent, new NewHelloEvent(this.name));
    }
    // [...]
}
----

== Emit the event

[source,typescript]
----
import { NewHelloEvent } from './events/new_hello';
import { createHelloSchema, CreateHelloParams, configSchema } from './schema';
// [...]

export class HelloModule extends BaseModule {
    // [...]

    public async afterCommandExecute(context: TransactionExecuteContext): Promise<void> {
        // Get the "New Hello" event
        const newHelloEvent = this.events.get(NewHelloEvent);
        // Decode the command parameters
        const createHelloParams: CreateHelloParams = codec.decode<CreateHelloParams>(createHelloSchema, context.transaction.params);
        context.logger.info(createHelloParams,"createHelloParams")
        // Use the log() method of the event to emit the event
        newHelloEvent.log(context.getMethodContext(), {
            senderAddress: context.transaction.senderAddress,
            message: createHelloParams.message
        });

    }
    // [...]
}
----

////
== Blockchain Events

A list of events that this module is able to emit is covered here.

Modules, plugins, and external services can subscribe to these events.

TIP: See the xref:{url_intro_modules_events}[Events] section of the "Modules" introduction page and the xref:{url_advanced_communication_aliases}[Aliases] section of the "Communication" page for more information.

Add a new event `newHello`.
This event shall be published every time a user is updating their hello message.
The `events` defined can be published to the application in the <<lifecycle-hooks>> of the module.

.src/app/modules/hello/hello_module.ts
[source,typescript]
----
export class HelloModule extends BaseModule {

    // ...
    public events = ['newHello'];

    // ...
}
----

== Lifecycle Hooks

Lifecycle hooks allow a module to execute certain logic, before or after blocks or transactions are applied to the blockchain.

Inside of the lifecycle hooks, it's possible to *publish* the above defined events to the application and to filter for certain transactions and blocks, before applying the logic.

TIP: See the "Lifecycle Hooks" section of the xref:{url_intro_modules_lifecyclehooks}[Modules] introduction page for more information.

In the hello module, two different lifecycle hooks are defined.

afterTransactionApply::
Publishes a new event `hello:newHello` for every applied `hello` transaction asset, and adds information about the sender of the transaction, and the corresponding hello message.

afterGenesisBlockApply::
If the genesis block is applied, it will set the counter for posted hello transactions to zero.

.src/app/modules/hello/hello_module.ts
[source,typescript]
----
export class HelloModule extends BaseModule {

    // ...

     // Lifecycle hooks
    public async afterTransactionApply(_input: TransactionApplyContext) {
        // Publish a `newHello` event for every received hello transaction
        // 1. Check for correct module and asset IDs
        if (_input.transaction.moduleID === this.id && _input.transaction.assetID === 0) {

            // 2. Decode the transaction asset
            const helloAsset = codec.decode(
                helloAssetSchema,
                _input.transaction.asset
            );

            // 3. Publish the event 'hello:newHello' and
            // attach information about the sender address and the posted hello message.
            this._channel.publish('hello:newHello', {
                sender: _input.transaction._senderAddress.toString('hex'),
                hello: helloAsset.helloString
            });
        }
    }

    public async afterGenesisBlockApply(_input: AfterGenesisBlockApplyContext) {
        // Set the hello counter to zero after the genesis block is applied
        await _input.stateStore.chain.set(
            CHAIN_STATE_HELLO_COUNTER,
            codec.encode(helloCounterSchema, { helloCounter: 0 })
        );
    }

    // ...
}
----

It is recommended to store the different schemas in a separate file, e.g. `schemas.js`, and import them in to the module and asset where required.

TIP: For more information about schemas, check out the xref:{url_references_schemas}[] page.

The following schemas are used in the lifecycle hooks:

.src/app/modules/hello/schemas.js
[source,js]
----
// This key is used to save the data for the hello counter in the database
const CHAIN_STATE_HELLO_COUNTER = "hello:helloCounter";

// This schema is used to decode/encode the data of the hello counter from/for the database
const helloCounterSchema = {
  $id: "lisk/hello/counter",
  type: "object",
  required: ["helloCounter"],
  properties: {
    helloCounter: {
      dataType: "uint32",
      fieldNumber: 1,
    },
  },
};

// This schema is used to decode/encode the data of the asset of the hello transaction from/for the database
const helloAssetSchema = {
  $id: "lisk/hello/asset",
  type: "object",
  required: ["helloString"],
  properties: {
    helloString: {
      dataType: "string",
      fieldNumber: 1,
    },
  },
};

module.exports = {
  CHAIN_STATE_HELLO_COUNTER,
  helloCounterSchema,
  helloAssetSchema
};
----
////