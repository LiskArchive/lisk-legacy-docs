= Connecting to endpoints
Muhammad Talha <muhammad.talha@lightcurve.io>
:toc: preamble
:toclevels: 5
:page-toclevels: 4
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
//External URLs
:url_npm_lisk_sdk: https://www.npmjs.com/package/lisk-sdk
// Project URLs
:docs_sdk: v6@lisk-sdk::
:url_advanced_rpc: api/lisk-node-rpc.adoc
:url_endpoints_modules: build-blockchain/module/endpoints-methods.adoc#endpoints
:url_endpoints_plugins: build-blockchain/plugin/plugin-endpoints.adoc#creating-an-endpoint
:url_sync_store: build-blockchain/plugin/plugin-class.adoc#sync-and-store-new-event
:url_cli: {docs_sdk}client-cli.adoc#endpoint
:url_intro_modules: understand-blockchain/sdk/modules-commands.adoc
:url_intro_plugins: understand-blockchain/sdk/plugins.adoc
// :url_references_elements_apiclient: {sdk_docs}references/lisk-elements/api-client.adoc
// :url_references_elements_client: {sdk_docs}references/lisk-elements/client.adoc
:url_advanced_rpc_endpoints: {url_advanced_rpc}#endpoints
:JSON_RPC_Specs: https://www.jsonrpc.org/specification
:url_sidechain_client: glossary.adoc#sidechain-client
// footnotes
:fn_sidechain_client_glossary: footnote:client[See xref:{url_sidechain_client}[Sidechain client] for more details.]

// TODO: Update the page by uncommenting the hyperlinks once the updated pages are available.

By default, Lisk exposes xref:{url_advanced_rpc_endpoints}[a range of endpoints] to communicate with a node.

Apart from that, sidechain clients{fn_sidechain_client_glossary}, specifically xref:{url_intro_modules}[Modules] and xref:{url_intro_plugins}[Plugins] of a sidechain client can also expose endpoints as described in the guides about xref:{url_endpoints_modules}[implementing endpoints for a module] and xref:{url_endpoints_plugins}[creating an endpoint for a plugin], respectively.

On this page, you'll learn about how the aforementioned endpoints can be invoked within the Lisk ecosystem.

[[the-api-client]]
== Invoking via API client

// The xref:{url_references_elements_apiclient}[] simplifies sending API requests to a blockchain application. 
The API client simplifies sending API requests to a blockchain application.

Blockchain applications developed with the Lisk SDK communicate to a node via RPCs. RPC-based interfaces i.e., IPC, WS, or HTTP allow applications to *invoke* RPC endpoints. 

An API client can be imported into any JS client application as shown in the following snippets.

// TIP: To conveniently communicate with a blockchain application, use the `apiClient` included in the xref:{url_references_elements_client}[@liskhq/lisk-client] and the {url_npm_lisk_sdk}[lisk-sdk^] packages.
TIP: To conveniently communicate with a blockchain application, use the `apiClient` included in the @liskhq/lisk-client and the lisk-sdk packages.

[tabs]
=====
WS API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;
const nodeAPIURL = 'ws://localhost:7887/rpc-ws';

const getClient = async () => {
    if (!clientCache) {
        clientCache = await apiClient.createWSClient(nodeAPIURL);
    }
    return clientCache;
};


const blockId = "0f4ea1c3cfb61b99d387b26aaadf57936a528e5c713c6e55aa06f4d621b7e6f0";

getClient().then((client) => {
    client.invoke("chain_getBlockByID", {
        id: blockId
    }).then(res => {
        console.log("Result: ", res);
    });
});
----
--
IPC API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;

const getClient = async () => {
    if (!clientCache) {
        // The datapath to the sidechain client should be passed here
        // In our case, we are passing datapath for the "hello_client"
        clientCache = await apiClient.createIPCClient('~/.lisk/hello_client');
    }
    return clientCache;
};

const blockId = "0f4ea1c3cfb61b99d387b26aaadf57936a528e5c713c6e55aa06f4d621b7e6f0";

getClient().then((client) => {
    client.invoke("chain_getBlockByID", {
        id: blockId
    }).then(res => {
        console.log("Result: ", res);
    });
});
----
--
HTTP cURL::
+
--
Apart from the WS and IPC method, Lisk endpoints also support HTTP requests and response mechanisms. With a {JSON_RPC_Specs}[JSON RPC 2.0] based format, any endpoint can be invoked using a cURL request. For example, as shown below:

[source,json]
----
curl --location --request POST 'http://localhost:7887/rpc' \
--header 'Content-Type: application/json' \
--data-raw '{
    "jsonrpc": "2.0",
    "id": "1",
    "method": "chain_getBlockByHeight",
    "params": {
        "height": 2291
    }
}'
----
--
=====

[TIP]
====
Lisk also supports invoking endpoints from within the sidechain client. For more information, check out the xref:{url_sync_store}[syncing and storing] example for the `HelloInfoPlugin`. Specifically, the line of code shown in the following example:

[source,typescript]
----
private async _syncChainEvents(): Promise<void> {
    // 1. Get the latest block height from the sidechain
    const res = await this.apiClient.invoke<{ header: { height: number } }>("chain_getLastBlock", {});
    //[...]
}
----
====

== Invoking via Lisk CLI
Any endpoint within the Lisk ecosystem can be invoked via Lisk's CLI as well.
For more information, check out the xref:{url_cli}[CLI reference page].

NOTE: If you are running *Lisk Core*, you can use nearly the same CLI commands as in the general Lisk CLI.
Just replace `./bin/run` with `lisk-core` in that case.

To invoke an endpoint via Lisk CLI, simply use the `endpoint:invoke` command as shown below:

[source,bash]
----
$./bin/run endpoint:invoke chain_getLastBlock --pretty
{
  "header": {
    "version": 2,
    "timestamp": 1662742534,
    "height": 110,
    "previousBlockID": "4ef1095d3560064dd4a66fb4543680efe65a64020c363571b107be9513628674",
    "stateRoot": "b2507620beb3be5cd7d0cbb7926e4365b5674b682673dc2423400a497636e13e",
    "assetRoot": "2aa695e23b36439b56130a490ef38feaaec57d82859ff64f5ca61cc49993afa3",
    "eventRoot": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
    "transactionRoot": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
    "validatorsHash": "84f3ed67cec1eb7bd6dc3ec01b0d0323021c1e86a3dc760b9b92041c28da31ac",
    "aggregateCommit": {
      "height": 0,
      "aggregationBits": "",
      "certificateSignature": ""
    },
    "generatorAddress": "lsk5y2q2tn35xrnpdc4oag8sa3ktdacmdcahvwqot",
    "maxHeightPrevoted": 0,
    "maxHeightGenerated": 110,
    "signature": "6ecd5c6f14d18f84a2125cca4186a6cc493dcd66338f9b13c580cc06be7a33267fe259a074d6f6dc9276aff700a985472fca15cbcf25b2fde1b621fe0810b507",
    "id": "334416bdc1f8a7ff842728ac4e591337a0e7b80f190934694cad7e2a9afdb416"
  },
  "transactions": [],
  "assets": [
    {
      "module": "random",
      "data": "0a10dde856a212ac5af46e26abb5f941cc8b"
    }
  ]
}
----
