= RPC endpoints of a Lisk node
Mona Bärenfänger <mona@lightcurve.io>
:description: Introduces the Lisk communication architecture, which is based on IPC Unix Sockets and WebSocket.
//Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:sdk_docs: lisk-sdk::
//External URLs
:url_npm_lisk_sdk: https://www.npmjs.com/package/lisk-sdk
:url_wiki_ipc: https://en.wikipedia.org/wiki/Inter-process_communication
:url_websocket: https://en.wikipedia.org/wiki/WebSocket
:url_eda: https://en.wikipedia.org/wiki/Event-driven_architecture
// Project URLs
:url_advanced_architecture: understand-blockchain/architecture.adoc#application
:url_advanced_rpc: api/lisk-node-rpc.adoc
:url_guides_config_rpc: build-blockchain/configure-app.adoc#rpc
:url_intro_modules: understand-blockchain/modules-assets.adoc
:url_intro_modules_assets: understand-blockchain/modules-assets.adoc#assets
:url_intro_modules_lifecycle: understand-blockchain/modules-assets.adoc#lifecycle-hooks
:url_intro_modules_statestore: understand-blockchain/modules-assets.adoc#the-state-store
:url_intro_plugins: understand-blockchain/plugins.adoc
:url_intro_plugins_load: understand-blockchain/plugins.adoc#defining-the-plugin-logic
:url_references_elements_apiclient: {sdk_docs}references/lisk-elements/api-client.adoc
:url_references_elements_client: {sdk_docs}references/lisk-elements/client.adoc
:url_references_plugins_monitor: {sdk_docs}plugins/monitor-plugin.adoc
:url_advanced_rpc_actions: {url_advanced_rpc}#actions
:url_advanced_rpc_events: {url_advanced_rpc}#events
:url_guides_asset: build-blockchain/create-asset.adoc
:url_lisk_sdk: glossary.adoc#lisk-sdk

The open Lisk communication architecture is based on two different RPC (Remote-Procedure-Call), API modes: {url_wiki_ipc}[Inter-Process Communication (IPC)^] and {url_websocket}[WebSocket (WS)^].
The xref:{url_advanced_architecture}[Application] can be configured to either expose an IPC or a WS API that can be used by internal components such as modules and plugins, as well as by any external service such as other scripts in JS, a tool in Rust, or a Python daemon.

TIP: For more information about the configuration of the RPC endpoints, check out the xref:{url_guides_config_rpc}[configuration guide].

image::intro/communication-architecture.png[]

[[the-api-client]]
== The API client

The xref:{url_references_elements_apiclient}[] simplifies sending API requests to a blockchain application via IPC or WS.

It can be imported in any JS client application.

It  provides an interface to *subscribe* to all events and to *invoke* actions of the blockchain application and its' modules & plugins.

TIP: To conveniently communicate with a blockchain application, use the `apiClient` which is included in the xref:{url_references_elements_client}[@liskhq/lisk-client] and the {url_npm_lisk_sdk}[lisk-sdk^] packages.

[tabs]

=====
WS API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;
const nodeAPIURL = 'ws://localhost:8080/ws';

const getClient = async () => {
	if (!clientCache) {
		clientCache = await apiClient.createWSClient(nodeAPIURL);
	}
	return clientCache;
};

const blockId = 123;

getClient().then((client) => {
	client.invoke("app:getBlockByID", {
		id: blockId
	}).then(res => {
		const decodedBlock = client.block.decode(res);
		console.log("Decoded block: ", decodedBlock);
		process.exit(0);
	});
});
----
--
IPC API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;
const nodeAPIURL = 'ws://localhost:8080/ws';

const getClient = async () => {
    if (!clientCache) {
        clientCache = await apiClient.createIPCClient('~/.lisk/my-app');
    }
    return clientCache;
};

const blockId = 123;

getClient().then((client) => {
	client.invoke("app:getBlockByID", {
		id: blockId
	}).then(res => {
		const decodedBlock = client.block.decode(res);
		console.log("Decoded block: ", decodedBlock);
		process.exit(0);
	});
});
----
--
=====

=== IPC vs WS

There are two ways through which a node can communicate via the API:

* IPC (Inter-Process-Communication)
* WS (WebSocket)

In general, IPC is preferred for local connections because it...

* is slightly faster
* supports synchronous data exchange
* does not use the ports of the system, avoiding any risk of collision when the port is already used by another application

WS, on the contrary, should be used if the node API communicates with services on remote servers.

== Channels

All modules and plugins have access to a `channel` to communicate with the application via actions and events.

=== Channel for modules

The channel in modules has only one purpose: it allows a module to publish events to the application which were defined in the <<events>> property of the module.

The channel is accessible inside of a module under `this._channel`.
It is used especially in the xref:{url_intro_modules_lifecycle}[lifecycle-hooks], to publish the events of the module.

The following function is available for a `channel` inside a module:

* `publish(eventName: string, data?: object)`: Publishes an event.

An example how to use the channel to publish an event is shown below:

[source,js]
----
this._channel.publish('hello:newHello', {
  sender: transaction._senderAddress.toString('hex'),
  hello: helloAsset.helloString
});
----

The above code example will publish the event `hello:newHello` to the application, and attach an object which is containing the sender address and the hello message of the last sent xref:{url_guides_asset}[hello transaction].

=== Channel for plugins

The channel is used inside of the xref:{url_intro_plugins_load}[load()] function of a plugin.

The following functions are available for a `channel` inside a plugin:

* `publish(eventName: string, data?: object)`: Publishes an event.
* `subscribe(eventName: string, cb: EventCallback)`: Subscribes to an event.
* `once(actionName: string, cb: EventCallback)`: Executes the callback only once, when receiving the event for the first time.
* `invoke(actionName: string, params?: object)`: Invokes an action.

[source,js]
----
channel.subscribe('app:block:new', ({ data }) => {
    const decodedBlock = this.codec.decodeBlock(data.block);
    this._knownTimestamps.push(decodedBlock.header.timestamp);
    channel.publish('myPlugin:timestamp', { timestamp: decodedBlock.header.timestamp });
});
----

== Aliases

<<events>> and <<actions>> are identified by their alias.

Example alias:

 "monitor:getTransactionStats"

The alias always consists of the following parts:

. *Prefix:* Consists of the module or plugin name that provides the respective action or event.
Equals `app` if it's an xref:{url_advanced_rpc}[application event or action].
The prefix `monitor` in this example is referring the the xref:{url_references_plugins_monitor}[].
. *Separator:*
Prefix and suffix are always separated by a colon `:`.
. *Suffix:* The respective name of the event or action.

== Interfaces

A blockchain application communicates via <<actions>> and <<events>> which can be invoked (actions), or subscribed to (events), via WebSocket.

The different components of the application each have access to different parts of these interfaces.
This is summarized in the following table.

For each action and event displayed below, the following statements apply:

* ... `reply` means, the component can reply to this kind of RPC request.
* ... `invoke` means, the component can invoke this kind of RPC request.
* ... `publish` means, the component can publish events.
* ... `subscribe` means, the component can subscribe to events.


image::intro/sdk-interfaces.png[]

== Actions

Actions are invoked to receive specific data from the blockchain application.
Actions are part of the request / response API, and are invoked via RPCs.

The following components can *expose* actions:

* xref:{url_intro_modules}[]
* xref:{url_intro_plugins}[]
* and also the application itself, see xref:{url_advanced_rpc_actions}[application actions]

The following components can *invoke* actions:

* Plugins
* External services/applications

=== How to invoke actions

The first argument is always the <<aliases,alias>>.
If input data is required, it is provided as a second argument.

[tabs]

=====
API client::
+
--
Actions can be invoked by <<the-api-client>>.

.How to invoke different kind of actions with the API client
[source,js]
----
const data = await client.invoke('app:getSchema'); // <1>
const data = await client.invoke('app:actionName', input); // <2>
client.invoke('monitor:getTransactionStats').then((val) => { // <3>
    console.log(val);
});
----

<1> How to invoke an action.
<2> How to invoke an action that needs some input data.
<3> Example of how to invoke an action of the monitor plugin.
--
Channel::
+
--
Actions can be invoked by plugins with the <<channel-for-plugins>>.

.How to invoke an action inside a plugin
[source,js]
----
this._nodeInfo = await this.channel.invoke("app:getNodeInfo");
----
--
=====

== Events

Events are part of the public publish / subscribe API of a blockchain application.
If an event is published it is immediately received by all of the subscribers of the event.

The following components can *publish* events:

* xref:{url_intro_modules}[]
* xref:{url_intro_plugins}[]
* and also the application itself, see xref:{url_advanced_rpc_events}[application events]

The following components can *subscribe* to events:

* Plugins
* External services / applications

=== How to publish and subscribe to events

Events are published inside lifecycle hooks of the module.
The `channel` is available inside the lifecycle hooks, which offers the possibility to subscribe and publish to events, as well as invoking actions in the network.

.Publishing an event
[source,typescript]
----
channel.publish('pluginAlias:timestamp', { info: 'sample' });
----

Example for subscribing to an event by utilizing <<the-api-client>>:

.Subscribing to an event
[source,typescript]
----
client.subscribe('pluginAlias:timestamp', ( data ) => {
  console.log(data);
});
client.subscribe('app:block:new', ( data ) => {
  console.log('new block:',data);
});
----

