= Communicating to a Lisk node via RPC
Mona Bärenfänger <mona@lightcurve.io> Muhammad Talha <muhammad.talha@lightcurve.io>
:description: Introduces the Lisk communication architecture, which is based on IPC Unix Sockets and WebSocket.
//Settings
:toc: preamble
:toclevels: 5
:page-toclevels: 4
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:sdk_docs: lisk-sdk::
//External URLs
:url_npm_lisk_sdk: https://www.npmjs.com/package/lisk-sdk
:url_wiki_ipc: https://en.wikipedia.org/wiki/Inter-process_communication
:url_websocket: https://en.wikipedia.org/wiki/WebSocket
:url_wiki_http_protocol: https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
:url_eda: https://en.wikipedia.org/wiki/Event-driven_architecture
// Project URLs
:url_rpc_config: {sdk_docs}config.adoc#rpc
:url_advanced_rpc: api/lisk-node-rpc.adoc
:url_guides_config_rpc: build-blockchain/configuration.adoc#rpc
:url_intro_modules: understand-blockchain/sdk/modules-commands.adoc
:url_intro_plugins: understand-blockchain/sdk/plugins.adoc
:url_intro_plugins_load: understand-blockchain/sdk/plugins.adoc#defining-the-plugin-logic
:url_references_elements_apiclient: {sdk_docs}references/lisk-elements/api-client.adoc
:url_references_elements_client: {sdk_docs}references/lisk-elements/client.adoc
:url_references_plugins_monitor: {sdk_docs}plugins/monitor-plugin.adoc
:url_advanced_rpc_endpoints: {url_advanced_rpc}#endpoints
:url_advanced_rpc_events: {url_advanced_rpc}#events
:url_guides_asset: build-blockchain/modules/command.adoc
:url_lisk_sdk: glossary.adoc#lisk-sdk
:url_RPC_System_API: {url_advanced_rpc}#system
:url_RPC_Events: {url_advanced_rpc}#events
:JSON_RPC_Specs: https://www.jsonrpc.org/specification
:url_module_endpoints: {sdk_docs}/modules/index.adoc
:url_module_commands: understand-blockchain/sdk/modules-commands.adoc#blockchain-events 
:url_sidechain_glossary: glossary.adoc#sidechain-application
:url_sapp: glossary.adoc#sapp

The open Lisk communication architecture is based on three different RPC (Remote-Procedure-Call) API modes: {url_wiki_ipc}[Inter-Process Communication (IPC)^], {url_websocket}[WebSocket (WS)^], and {url_wiki_http_protocol}[Hypertext Transfer Protocol (HTTP)^].
The application can be configured to expose either IPC, WS, or HTTP APIs, as discussed in the xref:{url_rpc_config}[RPC Configurations].
These APIs can be used by internal components such as modules and plugins. External services such as other scripts in JS, a tool in Rust, or a Python daemon can also use these APIs.

TIP: For more information about the configuration of the RPC endpoints, check out the xref:{url_guides_config_rpc}[configuration guide].

image::intro/communication-architecture.png[,1000 ,align="center"]

[[the-api-client]]
== The API client

The xref:{url_references_elements_apiclient}[] simplifies sending API requests to a xref:{url_sidechain_glossary}[Sidechain application (sApp)].
A xref:{url_sapp}[sApp] developed with Lisk SDK communicates to a node via RPCs. RPC-based interfaces i.e. IPC, WS, or HTTP allow applications to *invoke* and *subscribe* (WS and IPC only) to RPC endpoints and events. 

An API client can be imported into any JS client application as shown in the following snippets.

TIP: To conveniently communicate with a sidechain application, use the `apiClient` included in the xref:{url_references_elements_client}[@liskhq/lisk-client] and the {url_npm_lisk_sdk}[lisk-sdk^] packages.

[tabs]

=====
WS API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;
const nodeAPIURL = 'ws://localhost:7887/rpc-ws';

const getClient = async () => {
    if (!clientCache) {
        clientCache = await apiClient.createWSClient(nodeAPIURL);
    }
    return clientCache;
};


const blockId = "0f4ea1c3cfb61b99d387b26aaadf57936a528e5c713c6e55aa06f4d621b7e6f0";

getClient().then((client) => {
    client.invoke("chain_getBlockByID", {
        id: blockId
    }).then(res => {
        console.log("Result: ", res);
    });
});
----
--
IPC API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;

const getClient = async () => {
    if (!clientCache) {
        clientCache = await apiClient.createIPCClient('~/.lisk/my-app');
    }
    return clientCache;
};

const blockId = "0f4ea1c3cfb61b99d387b26aaadf57936a528e5c713c6e55aa06f4d621b7e6f0";

getClient().then((client) => {
    client.invoke("chain_getBlockByID", {
        id: blockId
    }).then(res => {
        console.log("Result: ", res);
    });
});
----
--
HTTP cURL::
+
--
Apart from the WS and IPC method, Lisk endpoints also support HTTP requests and response mechanisms. With a {JSON_RPC_Specs}[JSON RPC 2.0] based format, any endpoint can be invoked using a cURL request. For example:

[source,json]
----
curl --location --request POST 'http://localhost:7887/rpc' \
--header 'Content-Type: application/json' \
--data-raw '{
    "jsonrpc": "2.0",
    "id": "1",
    "method": "chain_getBlockByHeight",
    "params": {
        "height": 2291
    }
}'
----
--
=====


=== IPC vs WS vs HTTP

The three modes of communication i.e. IPC, WS, and HTTP allow 
sApps to communicate with Lisk nodes.

*IPC* in general is the preferred method for local connections:

    * It is slightly faster.
    * It supports synchronous data exchange.
    * It does not use the system ports, so it mitigates any risk of collision when the ports are already in use by another application.
    * It can invoke and subscribe to endpoints and events, respectively.

*WS* on the contrary should be used if the node API has to communicate with services on remote servers.

    * It is a bidirectional communication protocol that allows sending and receiving of data between a client and a server.
    * A WS connection is kept alive until terminated by either the client or the server.
    * A WS connection is usually necessary if real-time data acquisition is required.
    * A WS connection can also invoke and subscribe to endpoints and events, respectively.

*HTTP* is stateless, so it can only be used for fetching data from an endpoint.

    * HTTP requests establish a uni-directional connection to the server and close it once a response is received.
    * Since an event emits data in real time, a subscription can only work if the receiver's connection is persistent. This is not possible with an HTTP connection, hence it cannot be used to subscribe to events.

== Aliases

<<events>> and <<endpoints>> are identified by their aliases.

Example alias:

 "system_getNodeInfo"

An alias always consists of the following parts:

. *Prefix:* A *namespace* from which an event or an endpoint belongs to. The prefix `system` in this example is referring to the xref:{url_RPC_System_API}[System namespace].
. *Separator:*
The prefix and suffix are always separated by an underscore `_`.
. *Suffix:* A suffix is a name of the event or an endpoint e.g. `getNodeInfo` is the name of an endpoint that exists inside the `system` namespace.

== Interfaces

A sApp communicates via interfaces i.e. <<endpoints>> and <<events>>. Endpoints are invoked and events are subscribed to. Within an application, different interfaces are exposed to different components. This is summarized in the following diagram.

image::intro/sdk-interfaces.png[,600 ,align="center"]

For each endpoint and event displayed above, the following statements apply:

* ... `reply` means, the component can reply to this kind of RPC request.
* ... `invoke` means, the component can invoke this kind of RPC request.
* ... `subscribe` means, the component can subscribe to RPC events.

=== Endpoints

Endpoints are invoked to receive specific data from a sApp.
Endpoints are part of the request/response mechanism and are invoked via RPCs.

The following components can *expose* endpoints:

* xref:{url_intro_modules}[], for details about module specific endpoints, see xref:{url_module_endpoints}[Modules Overview].
* xref:{url_intro_plugins}[]
* and also the application itself, see xref:{url_advanced_rpc_endpoints}[application endpoints]

The following components can *invoke* endpoints:

* Plugins
* External services/applications

==== How to invoke endpoints

Whilst invoking an endpoint, the first argument is always the <<aliases,alias>>.
If input data is required, it is provided as a second argument. All endpoints can be invoked via either <<the-api-client>> or an HTTP request. The following example shows the invocation of an endpoint with and without additional arguments.

.How to invoke different kinds of endpoints with the API client
[source,js]
----
// How to invoke an endpoint.
const data = await client.invoke('system_getSchema');
console.log(data);

// How to invoke an endpoint that needs some data input.
const data = await client.invoke('namespace_endpointName', input); 
console.log(data);
----

== Events
Lisk framework emits RPC and Blockchain events, details of which are discussed below:

=== RPC Events
RPC events allow other applications to subscribe to Lisk Blockchain events. By default, Lisk exposes various events that can be subscribed to get the latest information regarding network, chain, and transactions. These events can be subscribed to, by the following:

* xref:{url_intro_plugins}[]
* External services/applications

TIP: For more information about the default events exposed by the Lisk Framework, check out the xref:{url_RPC_Events}[Events reference] page.

==== How to subscribe to events
Each event as described in the  xref:{url_RPC_Events}[Events reference] page can be subscribed to, by using the convention mentioned in the <<aliases>> section. The following snippet describes how an event can be subscribed by using <<the-api-client>>:

.Subscribing to an event
[source,typescript]
----
client.subscribe('network_newBlock', ( data ) => {
  console.log('new block: ',data);
});
----

=== Blockchain events
Blockchain events emit data about events occuring on chain. For details, see the xref:{url_module_commands}[Blockchain Events] section.