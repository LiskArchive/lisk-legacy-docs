= Lisk Core
Mona Bärenfänger <mona@lightcurve.io> Christopher Braithwaite <christopher.braithwaite@lightcurve.io>
// Settings
:description: References and guides how to setup, update and manage a Lisk Core node.
:toc: preamble
:page-no-previous: true
:docs_general: ROOT::
:page-aliases: monitoring.adoc
:imagesdir: ../assets/images
// External URLs
:url_faucet_testnet: https://testnet-faucet.lisk.com/
:url_lisk_blog_betanet5: https://lisk.com/blog/development/launch-betanet-v5
:url_lisk_desktop: https://lisk.com/wallet
:url_nodejs: https://nodejs.org
:url_postgresql: https://www.postgresql.org
:url_redis: https://redis.io
:url_semver: https://semver.org/
:url_swagger: https://swagger.io
:url_observer: https://lisk.observer/
:url_observer_testnet: https://testnet.lisk.observer/
:url_liskscan: https://liskscan.com/
:url_liskscan_testnet: https://testnet.liskscan.com/
// Project URLs
:url_config: management/configuration.adoc
:url_config_block_generation: management/forging.adoc
:url_management_accounts: management/account-management.adoc
:url_getting_started: setup/npm.adoc
:url_setup: setup/index.adoc#distributions
:url_setup_binary: setup/application.adoc
:url_setup_npm: setup/npm.adoc
:url_setup_snap: setup/snap.adoc
:url_setup_docker: setup/docker.adoc
:url_setup_source: setup/source.adoc
:url_upgrade_binary: update/application.adoc
:url_upgrade_commander: update/commander.adoc
:url_upgrade_docker: update/docker.adoc
:url_upgrade_source: update/source.adoc
:url_ref_rpc: {docs_general}api/lisk-node-rpc.adoc
:url_configure_rpc: lisk-docs::build-blockchain/configure-app.adoc#rpc
:url_sdk_plugin_httpapi: lisk-sdk::plugins/http-api-plugin.adoc
:url_migration: lisk-docs::pages/management/migration.adoc
:url_pos: lisk-docs::pages/modules/dpos-module.adoc
:url_bft: lisk-docs::pages/understand-blockchain/consensus/bft.adoc
:url_cross_chain: lisk-docs::pages/understand-blockchain/interoperability/communication.adoc
:url_lisk_migrator: management/migration.adoc#setting-up-the-lisk-migrator
:url_lisk_api: reference/api.adoc

image:banner_core.png[Core]

ifeval::[{page-component-version} !== master]

IMPORTANT: To access the latest Lisk Core version, please xref:master@{page-component-name}::{page-relative}[click here].
endif::[]

== Overview

The Lisk Core can be defined as a blockchain application running on the Lisk Mainnet that implements/enforces the Lisk protocol, enabling a user to easily set up a node and participate in the network.
To provide a high level overview, the main functionalities are listed below:

* The possibility to connect to a subset of peers in the Lisk mainchain's P2P network.
* To synchronize with the Lisk blockchain including requesting, forwarding and processing of the blocks, which also contain the transactions.
// => Lisk Core node stores all current account balances and transactions
* To maintain the transaction pool, which might contain a subset of unconfirmed transactions.
* To request and forward the unconfirmed transactions.
* To possibly generate new blocks when running a delegate node.

Furthermore, Lisk Core nodes are able to store all current addresses, balances, and transactions.


With the latest version of Lisk Core, there will be new configurable settings and the modules described in the <<Modules>> sub-section will also be used.

NOTE: To migrate from Lisk Core v3 to v4 please follow the migration process as covered in the xref:{migration}[migration guide].

==== Migration overview

The Lisk SDK v6 has introduced some new configurable settings, including certain constants that need to be specified for each chain, which must also be specified in Lisk Core v4.
A brief overview of the migration process from Lisk Core v3 to Lisk Core v4 is depicted graphically in the illustration below in Figure 1.

.Migration process overview
image::migration-v3-v4.png[align=center]

In Figure 1 above, the blocks in pink are generated by the Lisk Core v3 nodes, including the state snapshot.
The snapshot block is shown in green, and is generated by the xref:{url_lisk_migrator}[migrator tool].
Finally, the blocks in yellow are generated by the Lisk Core v4 nodes post the migration.

This illustrated process for performing the migration from Lisk Core v3 to Lisk Core v4 is described in this section.

Firstly, nodes running Lisk Core v3, follow the steps in the bullet points listed below:

- Once a block at height `HEIGHT_SNAPSHOT` is processed, a snapshot of the state is then derived, which is denoted by the `STATE_SNAPSHOT`.
If this block is reverted and a new block for this height is processed, then this will require the `STATE_SNAPSHOT` to be computed again.
- Nodes will continue to process blocks until the block at height `HEIGHT_SNAPSHOT` is final.
- Once the block at height `HEIGHT_SNAPSHOT` is final, nodes can stop generating and processing new blocks.
All blocks with a height larger than or equal to `HEIGHT_SNAPSHOT + 1` are the discarded, even if they are finalized.
- Nodes then compute a snapshot block (as defined below) using a migrator tool and store it locally.
- The following sub-section provides the overview of how nodes start to run Lisk Core v4.
- Once the timeslot of the snapshot block at height `HEIGHT_SNAPSHOT + 1` is passed, the first round following the new protocol starts.

==== Starting Lisk Core v4

When Lisk Core v4 is started for the first time, the following steps below are performed:

1. Firstly, get the snapshot block (the one for height `HEIGHT_SNAPSHOT + 1`):
- (a) Check if the snapshot block for height `HEIGHT_SNAPSHOT + 1` exists locally.
If yes, then fetch this block.
If not, stop the initialization here.
2. It will then be necessary to process the snapshot block to initialize the state store per each module followed by verifying the initial state.
3. Check if all blocks between the heights `HEIGHT_PREVIOUS_SNAPSHOT_BLOCK` and `HEIGHT_SNAPSHOT` (inclusive) from Lisk Core v3 can be found locally.
If yes then the following in (a) and (b) below must be applied:
- (a) Fetch these blocks from the highest to the lowest height.
Each block is then validated, and assuming the validation step passes, the block and its transactions are continued in the database.
- (b) The following steps 4 and 5 below can be skipped.
4. Fetch all blocks between heights `HEIGHT_PREVIOUS_SNAPSHOT_BLOCK + 1` and `HEIGHT_SNAPSHOT` (inclusive) via peer-to-peer network from highest to lowest height.
Each block is validated using minimal validation steps.
If the validation passes, the block along with its transactions is continued in the database.
5. The snapshot block for the height `HEIGHT_PREVIOUS_SNAPSHOT_BLOCK` is downloaded from a server.
The URL for the source can be configured.
When downloaded, it is validated using minimal validation steps.
If this validation step passes, the block is continued in the database.
The steps 3 to 5 from above could run in the background with low priority.

NOTE: Note that due to step 1.(a) above, it is a requirement to run Lisk Core v3 and the migrator tool before running Lisk Core v4.
However, it may occur that nodes starting some time after the migration, may fetch the snapshot block and its preceding blocks without running Lisk Core v3 and the xref:{url_lisk_migrator}[Lisk migrator tool].

=== Modules

Within Lisk Core v4, the following modules will be used:

* PoS
- xref:{url_pos}[PoS] (Proof-of-stake), module is responsible for handling delegate registration, votes, and computing the delegate weight.
* Auth
- The Auth module is responsible for handling and verifying nonces and for transaction signature validation, including transactions from multisignature accounts.
* BFT
- The xref:{url_bft}[BFT] module is responsible for maintaining the consensus participants, their BFT weights, and all information related to the consensus votes that have been cast as part of the block headers.
* Validators
- The Validators module is responsible for validating the eligibility of a validator for generating a block and the block signature.
Furthermore, it maintains information about the registered validators in its module store and provides the generator list.
* Random
- The Random module handles the validation of the inputs and computation of outputs for the commit and reveal process for a Lisk blockchain.
Hence, it manages the validation of the inputs for the commit and reveal process, as well as the computation of the random seeds from this process.
// Info on Random process in LIP 0022
* Fee
- The Fee module is responsible for the handling of the transaction fees.
It allows chains to choose the token used to pay the fee, and to define a minimum fee for the transactions to be valid.
* Interoperability
- The Interoperability module provides basic functionalities to transmit information between interoperable chains in the Lisk ecosystem using xref:{cross_chain}[cross-chain messages].
* Token
- This module allows any chain in the ecosystem to handle and transfer tokens in a coherent, secure, and controlled manner.
It is composed of a state store definition used to store tokens in the state.
* Legacy
- The Legacy module maintains all accounts on the Lisk mainchain that received balance transfers to their address in the old 8-byte format, and for which no public key is associated.
The Legacy module also implements a command allowing delegates without a BLS key to register one.

==== Module State Store

Within the chain each module that is registered defines its own state and the possible state transitions.
For example, this could be the transactions defined within the module or the reducers that can be called by other modules.

This new state architecture is now substantially different, as previously, the state of a chain was organized per account rather than per module.
For example, a user's balance would be stored together with all the other properties related to that specific user.
Alternatively, with the new state model, the balance of a user is stored in the token module state and is separated from all other properties.

In addition, the chain also maintains a *global state store*, which can be determined as a collection of key-value pairs defining the state of the blockchain.
Following the modular architecture, the state store is further split into several *module stores*, namely, collections of key-value pairs that are defined within the state specific to the module.
This is achieved by imposing a specific format for keys in the global state store.
Hence, each key is given by the concatenation of the module store prefix, a substore prefix, and a store key.
A module store can be defined as the collection of key-value pairs whose keys share the same module store prefix (which identifies the specific module store).

Separating the state store into several key-value maps allows us to logically compartmentalize each module, following the same mantra behind our chain architecture, each module defines its part of the state and its own state transitions.

- *Module State* The key-value pairs stored in the map of the module.
For example, the user balance, and the escrow accounts are stored in the token module.
- *Module state transactions*: The transactions defined in a module (for example, the token transfer transaction in the token module), as well as the logic executed with every block or transactions, such as the reward assigned to the generator after a block has been processed.

The state tree is the sparse Merkle tree built on top of the state store.
Organizing the state of a blockchain in a Merkle tree allows to cryptographically authenticate the whole state with a single hash, the state root.
The state root property is calculated at the end of the block processing as the Merkle root of the state tree and included in the block header.
Information from the block header is then used to create a certificate and signed by the chain validators.

The following constants for the module store have been defined and are shown below:

[cols="2,1,2,4"]
|===
|*Name*|*Type*|*Value*|*Description*
|`STORE_PREFIX_LENGTH`|uint32|4|Length in bytes of a store prefix.
|`SUBSTORE_PREFIX_LENGTH`|uint32|2|Length in bytes of a substore prefix.

|===

The illustration below in Figure 2 depicts the general structure of the state sparse Merkle tree for a Lisk blockchain using two application-specific modules.
The state root is the Merkle root, and as described above each module defines its own module store.
he keys of the leaf nodes start with the store prefixes, so that each module subtree is separated from the others. Please note, not all modules are shown in this illustration.

.State sparse Merkle tree
image::state_tree.png[align=center]


== Getting started

[[node]]
=== What is a node?

The Lisk blockchain is a decentralized network that consists of many different servers, (or nodes).
Node operators are required to set up Lisk Core on a server, and then connect it to the desired network.

There are over 600 nodes around the world that are maintained by individuals, and these nodes communicate with the network.
For example, by broadcasting and receiving blocks or transactions from their peers.
In addition, Lisk Core nodes are also required to generate/add new blocks to the blockchain.

=== Who should operate a node?

If you fall under one of the following categories listed below, then it is recommended to set up your own node:

* *Exchanges* and other services that rely on a stable API interface to the network.
* *Delegates* who have registered as a delegate and would like to actively generate new blocks.
* *Users* who do not trust external sources and want to be in full control over their node.

=== Why operate a node?

- To have a private entry point to communicate with the network.
This is especially important when running an exchange and implementing LSK tokens.
- To create your own snapshots of the blockchain.
- To create transactions and send them to the network.
- To have the option to xref:{url_config_block_generation}[generate] new blocks, (assuming you are an active delegate).
- To acquire full control in order to xref:{url_config}[configure] the node to your specific requirements.

NOTE: To learn how to set up a node, please see the xref:{url_getting_started}[NPM setup] page.

[[networks]]
== Networks

The Lisk Core can be connected to different networks.
Please be aware that there are two key accessible public networks existing which are entirely independent of each other.
These networks are described below.
//Note: ChainIDs & ports could be further updated according to Manu.

.Public networks of Lisk
[cols="1h,1m,1m",options="header"]
|===
| Network | Port (default) | Chain ID

| Mainnet
| 8001
| 00000000

| Testnet
| 7001
| 01000000

|===

=== Mainnet

The Mainnet is where the true Lisk economy exists.
Within this network the Lisk users can transfer LSK tokens from one account to another, register accounts as delegates; and vote for other delegates.

==== Mainnet blockchain explorer

* {url_observer}[^]
* {url_liskscan}[^]

=== Testnet

The Testnet is an independent replica of the Lisk Mainnet, whose main function is to test the upgrades first before they are run on the Lisk Mainnet.
Subsequently, this is where new/updated versions and fixes of the Lisk Core are tested.

To start using the Testnet, please download your free LSK Testnet from the {url_faucet_testnet}[Testnet faucet^].

To connect to the Testnet via {url_lisk_desktop}[Lisk Desktop^], simply enable the "Network Switcher" in the settings and then use it to switch the network to `Testnet`.

==== Testnet blockchain explorer

* {url_observer_testnet}[^]
* {url_liskscan_testnet}[^]

== APIs

.Available APIs for Lisk nodes
[cols="1,1,1,1,1,",options="header"]
|===

| API | Transport| Architecture | Port (default) |Comment |Reference

| RPC Endpoints
| WS
| RPC
| Depends on the network, see: <<networks>>
| To enable, xref:{url_configure_rpc}[enable RPC websockets] in the node config.
| xref:{url_ref_rpc}[]

|===

The Lisk API documentation can be found xref:{url_lisk_api}[here].


== Token

The native token for the Lisk Mainnet is the *LSK*.
Each LSK is further subdivided into 10^8^ *Beddows*.

== Custom modules

Lisk Core includes the `legacyAccount` module which contains the following transaction.

=== LSK Reclaim

This transaction allows to access the balance that was sent to a legacy address without any associated public key.
Legacy addresses, generated from the first eight bytes of the public key, were used in older versions of the protocol.
This legacy address is deduced from the `senderPublicKey` of the transaction, and the amount specified in the transaction asset must correspond to the amount in the legacy account.

image::ReclaimAsset.png[ReclaimAsset,330,147]
