= How to execute a CCM
Mona Bärenfänger <mona@lightcurve.io>
:toc:
:idprefix:
:idseparator: -
:sectnums:
// URLs
:url_github_sdk_interop: https://github.com/LiskHQ/lisk-sdk/tree/release/6.0.0/examples/interop

== How to convert the Hello module into an interoperable module

To convert an existing module to an interoperable module, perform the following adjustment:

Import the `BaseInteroperableModule` class and remove the `BaseModule` class, as it will be replaced by the `BaseInteroperableModule`.

Additionally, create a new file called `cc_method.ts`, and add a skeleton for potential cross-chain methods the module is offering.

[source,typescript]
----
import { BaseCCMethod } from 'lisk-sdk';

export class HelloInteroperableMethod extends BaseCCMethod {}
----

Now import the `HelloInteroperableMethod` and use it to create a new member `crossChainMethod` inside the module.

In the end, the updated module should look similar to the example below:

.hello/module.ts
[source,typescript]
----
/* eslint-disable class-methods-use-this */
// Replace BaseModule with BaseInteroperableModule
import {
    validator,
    BaseInteroperableModule,
    // ...
} from 'lisk-sdk';
// Import the newly created cc_method
import { HelloInteroperableMethod } from './cc_method';

// ...


export class HelloModule extends BaseInteroperableModule {
       public endpoint = new HelloEndpoint(this.stores, this.offchainStores);
    public method = new HelloMethod(this.stores, this.events);
    public commands = [new CreateHelloCommand(this.stores, this.events)];
       // Assign HelloInteroperableMethod to crossChainMethod
    public crossChainMethod = new HelloInteroperableMethod(this.stores, this.events);

    // ...
}
----

Now that the interoperable module is initialized, let's create the cross-chain command which will be used to accept and execute the CCM on the sidechain.

== Add required schemas and constants

Add the schema and the corresponding interface to the `schemas.ts` file inside the `hello` module.

.hello/schemas.ts
[source,typescript]
----
/**
 * Parameters of the reactCrossChain CCM
 */
export interface CCReactMessageParams {
    /**
     * A number indicating the type of the reaction.
     */
    reactionType: number;
    /**
     * ID of the message.
     */
    helloMessageID: string;
    /** Optional field for data / messages. */
    data: string;
}

/**
 * Schema for the parameters of the reactCrossChain CCM
 */
export const CCReactMessageParamsSchema = {
    /** The unique identifier of the schema. */
    $id: '/lisk/hello/ccReactParams',
    type: 'object',
    /** The required parameters for the command. */
    required: ['reactionType', 'helloMessageID', 'data'],
    /** A list describing the available parameters for the command. */
    properties: {
        reactionType: {
            dataType: 'uint32',
            fieldNumber: 1,
        },
        helloMessageID: {
            dataType: 'string',
            fieldNumber: 2,
        },
        data: {
            dataType: 'string',
            fieldNumber: 3,
            minLength: 0,
            maxLength: 64,
        },
    },
};
----

Create a new file `constants.ts` inside the `hello` module, to store the required constants.

.hello/constants.ts
[source,typescript]
----
export const CROSS_CHAIN_COMMAND_NAME_REACT = 'reactCrossChain';
export const MAX_RESERVED_ERROR_STATUS = 63;
----

== Create a store for reactions

Create a new store to store the reactions.

.hello/stores/reaction.ts
[source,typescript]
----
import { BaseStore } from 'lisk-sdk';

export interface ReactionStoreData {
    reactions: {
        like: Buffer[];
    };
}

export const reactionStoreSchema = {
    $id: '/hello/reaction',
    type: 'object',
    required: ['reactions'],
    properties: {
        reactions: {
            type: 'object',
            fieldNumber: 1,
            properties: {
                like: {
                    type: 'array',
                    fieldNumber: 1,
                    items: {
                        dataType: 'bytes',
                    },
                },
            },
        },
    },
};

export class ReactionStore extends BaseStore<ReactionStoreData> {
    public schema = reactionStoreSchema;
}
----

== Initialize the cc_command

Initialize a new command `react` with Lisk Commander

[source,bash]
----
lisk generate:command hello react
----

And move it to a new folder `cc_commands` inside the `hello` module.

Now, open the file `hello/cc_commands/react_command.ts` and import the constants, schemas and types defined above.

Next, update the following properties of the command:

* Replace `BaseCommand` with `BaseCCCommand`
* Replace `ReactCommand` with `ReactCCCommand`
* Replace `CommandVerifyContext` and `CommandExecuteContext,` with `CrossChainMessageContext`
//TODO: Is it required that the command names for commands creating and executing a specific CCM must match?
* Set the name of the command to `reactCrossChain`.
* Set the command schema to match `CCReactMessageParamsSchema`.

.hello/cc_commands/react_command.ts
[source,typescript]
----
import { BaseCCCommand, CrossChainMessageContext, codec, cryptography, db } from 'lisk-sdk';
import { CCReactMessageParamsSchema, CCReactMessageParams } from '../schemas';
import { MAX_RESERVED_ERROR_STATUS, CROSS_CHAIN_COMMAND_NAME_REACT } from '../constants';
import { ReactionStore, ReactionStoreData } from '../stores/reaction';
import { MessageStore } from '../stores/message';

export class ReactCCCommand extends BaseCCCommand {
    public schema = CCReactMessageParamsSchema;

    public get name(): string {
        return CROSS_CHAIN_COMMAND_NAME_REACT;
    }
}
----

== CCM verification

Now, implement the command verification.

To keep the example simple, we only check if the CCM `status` code is valid, and if a Hello message exists for the `helloMessageID` defined in the CCM params.

The CCM to be verified is included in the CCM context `ctx` of the `execute()` hook.

Extend the `verify()` hook to include more checks for the other parameters as well, as desired.

.hello/cc_commands/react_command.ts
[source,typescript]
----
public async verify(ctx: CrossChainMessageContext): Promise<void> {
    const { ccm } = ctx;

    if (ccm.status > MAX_RESERVED_ERROR_STATUS) {
        throw new Error(`Invalid CCM status code. As it exceeds ${MAX_RESERVED_ERROR_STATUS}.`);
    }

    const params = codec.decode<CCReactMessageParams>(crossChainReactParamsSchema, ccm.params);
    const messageCreatorAddress = cryptography.address.getAddressFromLisk32Address(
        params.helloMessageID,
    );
    if (!(await this.stores.get(MessageStore).has(ctx, messageCreatorAddress))) {
        throw new Error('Message ID does not exists.');
    }
}
----

Once it is verified that the parameters are valid, we can execute the CCM.

== CCM execution

For this, adjust the `execute()` hook as shown in the snippet below.

The CCM is included in the CCM context `ctx` of the `execute()` hook and can be used to access the CCM parameters.

The <<create-a-store-for-reactions, Reaction Store>> is used to save the reactions for Hello messages.

.hello/cc_commands/react_command.ts
[source,typescript]
----
public async execute(ctx: CrossChainMessageContext): Promise<void> {
    const { ccm, logger } = ctx;
    logger.info('Executing React CCM');
    // const { sendingChainID, status, receivingChainID } = ccm;
    // Decode the provided CCM parameters
    const params = codec.decode<CCReactMessageParams>(CCReactMessageParamsSchema, ccm.params);
    logger.info(params, 'parameters');
    // Get helloMessageID and reactionType from the parameters
    const { helloMessageID, reactionType } = params;
    const reactionSubstore = this.stores.get(ReactionStore);
    const messageCreatorAddress = cryptography.address.getAddressFromLisk32Address(helloMessageID);
    let msgReactions: ReactionStoreData;

    // Get existing reactions for a Hello message, or initialize an empty reaction object, if none exists,yet.
    try {
        msgReactions = await reactionSubstore.get(ctx, messageCreatorAddress);
    } catch (error) {
        if (!(error instanceof db.NotFoundError)) {
            logger.info({ helloMessageID, crossChainCommand: this.name }, (error as Error).message);
            logger.error({ error }, 'Error when getting the reaction substore');
            throw error;
        }
        logger.info(
            { helloMessageID, crossChainCommand: this.name },
            `No entry exists for given helloMessageID ${helloMessageID}. Creating a default entry.`,
        );
        msgReactions = { reactions: { like: [] } };
    }

    // Check if the reactions is a like
    if (reactionType === 0) {
        const hasLiked = msgReactions.reactions.like.indexOf(ctx.transaction.senderAddress);
        // If the sender has already liked the message
        if (hasLiked > -1) {
            // Remove the sender address from the likes for the message
            msgReactions.reactions.like = msgReactions.reactions.like.splice(hasLiked, 1);
        // If the sender has not liked the message yet
        } else {
            // Add the sender address to the likes of the message
            msgReactions.reactions.like.push(ctx.transaction.senderAddress);
        }
    } else {
        logger.error({ reactionType }, 'invalid reaction type');
    }
    // Update the reaction store with the reactions for the specified Hello message
    await reactionSubstore.set(ctx, messageCreatorAddress, msgReactions);
}
----

== Final updates of the module and app.ts

Go back to the file `hello/module.ts` and update it as described in the code comments.

.hello/module.ts
[source,typescript]
----
import { BaseInteroperableModule, ModuleMetadata, ModuleInitArgs } from 'lisk-sdk';
import { ReactCrossChainCommand } from './commands/react_command';
import { ReactEndpoint } from './endpoint';
import { ReactMethod } from './method';
import { ReactInteroperableMethod } from './cc_method';
// Import the type for the InteroperabilityMethod
import { InteroperabilityMethod } from './types';

export class ReactModule extends BaseInteroperableModule {
    public endpoint = new ReactEndpoint(this.stores, this.offchainStores);
    public method = new ReactMethod(this.stores, this.events);
    public commands = [new ReactCrossChainCommand(this.stores, this.events)];
    public crossChainMethod = new ReactInteroperableMethod(this.stores, this.events);
    // Create a private member to store the methods of the interoperability module
    private _interoperabilityMethod!: InteroperabilityMethod;

    // ...

    // Assign the methods of the interoperability module to _interoperabilityMethod
    public addDependencies(interoperabilityMethod: InteroperabilityMethod) {
        this._interoperabilityMethod = interoperabilityMethod;
    }

    // Lifecycle hooks
    // eslint-disable-next-line @typescript-eslint/require-await
    public async init(_args: ModuleInitArgs) {
        // Pass the methods of the interoperability module to the reactCrossChain command
        this.commands[0].init({
            interoperabilityMethod: this._interoperabilityMethod,
        });
    }
}
----

Open the `app.ts` file, and register the module to the application.

Because the `ReactModule` is an *interoperable module*, it is required to call `app.registerInteroperableModule()` additionally.

Last but not least, call the `addDependencies()` method of the `ReactModule` with the methods of the interoperability module as a parameter.

IMPORTANT: Please remove the redundant registration of the `ReactModule` in the `modules.ts` file. It was added automatically during the command initialization.

.app.ts
[source,typescript]
----
import { Application, PartialApplicationConfig } from 'lisk-sdk';
import { registerModules } from './modules';
import { registerPlugins } from './plugins';
import { ReactModule } from './modules/react/module';

export const getApplication = (config: PartialApplicationConfig): Application => {
    const { app, method } = Application.defaultApplication(config);
    const reactModule = new ReactModule();
    app.registerModule(reactModule);
    app.registerInteroperableModule(reactModule);
    reactModule.addDependencies(method.interoperability);

    registerModules(app);
    registerPlugins(app);

    return app;
};
----

The implementation of a cross-chain command in the Hello module is now completed.

An example implementation of the interoperable modules React and Hello on two different sidechains is available in the Lisk SDK repository under {url_github_sdk_interop}[examples/interop^].
Feel free to check it out.