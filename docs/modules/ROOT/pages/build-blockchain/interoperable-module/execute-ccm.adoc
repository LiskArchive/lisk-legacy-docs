= How to execute a CCM
Mona Bärenfänger <mona@lightcurve.io>
:toc:
:idprefix:
:idseparator: -
:sectnums:

== How to convert the Hello module into an interoperable module

To convert an existing module to an interoperable module, perform the following adjustment:

Import the `BaseInteroperableModule` class and remove the `BaseModule` class, as it will be replaced by the `BaseInteroperableModule`.

Additionally, create a new file called `cc_method.ts`, and add a skeleton for potential cross-chain methods the module is offering.

[source,typescript]
----
import { BaseCCMethod } from 'lisk-sdk';

export class HelloInteroperableMethod extends BaseCCMethod {}
----

Now import the `HelloInteroperableMethod` and use it to create a new member `crossChainMethod` inside the module.

In the end, the updated module should look similar to the example below:

[%collapsible]
=====
.hello/module.ts
[source,typescript]
----
/* eslint-disable class-methods-use-this */
// Replace BaseModule with BaseInteroperableModule
import {
	validator,
	BaseInteroperableModule,
    // ...
} from 'lisk-sdk';
// Import the newly created cc_method
import { HelloInteroperableMethod } from './cc_method';

// ...


export class HelloModule extends BaseInteroperableModule {
    public endpoint = new HelloEndpoint(this.stores, this.offchainStores);
	public method = new HelloMethod(this.stores, this.events);
	public commands = [new CreateHelloCommand(this.stores, this.events)];
    // Assign HelloInteroperableMethod to crossChainMethod
	public crossChainMethod = new HelloInteroperableMethod(this.stores, this.events);

	// ...
}
----
=====

Now that the interoperable module is initialized, let's create the cross-chain command which will be used to accept and execute the CCM on the sidechain.

== The `reactCrossChain` command

Add the schema and the corresponding interface to the `schemas.ts` file inside the `hello` module.

.hello/schemas.ts
[source,typescript]
----
/**
 * Parameters of the cross-chain token transfer command
 */
export const CCReactMessageParamsSchema = {
	/** The unique identifier of the schema. */
	$id: '/lisk/hello/ccReactParams',
	type: 'object',
	/** The required parameters for the command. */
	required: ['reactionType', 'helloMessageID', 'data'],
	/** A list describing the available parameters for the command. */
	properties: {
		reactionType: {
			dataType: 'uint32',
			fieldNumber: 1,
		},
		/**
		 * ID of the message.
		 */
		helloMessageID: {
			dataType: 'string',
			fieldNumber: 2,
		},
		/** Optional field for data / messages. */
		data: {
			dataType: 'string',
			fieldNumber: 3,
			minLength: 0,
			maxLength: 64,
		},
	},
};

export interface CCReactMessageParams {
	reactionType: number;
	helloMessageID: string;
	data: string;
}
----

Create a new file `constants.ts` inside the `hello` module, to store required constants.

.hello/constants.ts
[source,typescript]
----
export const CROSS_CHAIN_COMMAND_NAME_REACT = 'reactCrossChain';
export const MAX_RESERVED_ERROR_STATUS = 63;
----

Create a new store to store the reactions.

.hello/stores/reaction.ts
[source,typescript]
----
import { BaseStore } from 'lisk-sdk';

export interface ReactionStoreData {
	reactions: {
		like: Buffer[];
	};
}

export const reactionStoreSchema = {
	$id: '/hello/reaction',
	type: 'object',
	required: ['reactions'],
	properties: {
		reactions: {
			type: 'object',
			fieldNumber: 1,
			properties: {
				like: {
					type: 'array',
					fieldNumber: 1,
					items: {
						dataType: 'bytes',
					},
				},
			},
		},
	},
};

export class ReactionStore extends BaseStore<ReactionStoreData> {
	public schema = reactionStoreSchema;
}
----

Initialize a new command `react` with Lisk Commander

[source,bash]
----
lisk generate:command hello react
----

And move it to a new folder `cc_commands` inside the `hello` module.

Now, open the file `hello/cc_commands/react_command.ts` and import the constants, schemas and types defined above.

Next, define the following properties of the command:

* change `BaseCommand` to `BaseCCCommand` and
* `ReactCommand` to `ReactCCCommand` to define the command as a cross-chain command.
Cross-chain commands are able to accept and execute CCMs.
//TODO: Is it required that the command names for commands creating and executing a specific CCM must match?
* Set the name of the command to `reactCrossChain`.
* Set the command schema to equal `CCReactMessageParamsSchema`.

.hello/cc_commands/react_command.ts
[source,typescript]
----
import { BaseCCCommand, CrossChainMessageContext, codec, cryptography, db } from 'lisk-sdk';
import { CCReactMessageParamsSchema, CCReactMessageParams } from '../schemas';
import { MAX_RESERVED_ERROR_STATUS, CROSS_CHAIN_COMMAND_NAME_REACT } from '../constants';
import { ReactionStore, ReactionStoreData } from '../stores/reaction';
import { MessageStore } from '../stores/message';

export class ReactCCCommand extends BaseCCCommand {
	public schema = CCReactMessageParamsSchema;

	public get name(): string {
		return CROSS_CHAIN_COMMAND_NAME_REACT;
	}
}
----

Now, go back to the `react_command.ts` file, and implement the command verification.

To keep the example simple, we only check if the `receivingChainID` parameter doesn't equal the value of the sending chain.

Extend the `verify()` hook to include more checks for the other parameters as well, as desired.

.hello/cc_commands/react_command.ts
[source,typescript]
----
public async verify(ctx: CrossChainMessageContext): Promise<void> {
    const { ccm } = ctx;

    if (ccm.status > MAX_RESERVED_ERROR_STATUS) {
        throw new Error('Invalid CCM status code.');
    }

    const params = codec.decode<CCReactMessageParams>(crossChainReactParamsSchema, ccm.params);
    const messageCreatorAddress = cryptography.address.getAddressFromLisk32Address(
        params.helloMessageID,
    );
    if (!(await this.stores.get(MessageStore).has(ctx, messageCreatorAddress))) {
        throw new Error('Message ID does not exists.');
    }
}
----

.hello/cc_commands/react_command.ts
[source,typescript]
----
public async execute(ctx: CrossChainMessageContext): Promise<void> {
    const { ccm, logger } = ctx;
    logger.info('Executing React CCM');
    // const methodContext = ctx.getMethodContext();
    // const { sendingChainID, status, receivingChainID } = ccm;
    const params = codec.decode<CCReactMessageParams>(crossChainReactParamsSchema, ccm.params);
    logger.info(params, 'parameters');
    const { helloMessageID, reactionType } = params;
    const reactionSubstore = this.stores.get(ReactionStore);
    const messageCreatorAddress = cryptography.address.getAddressFromLisk32Address(helloMessageID);
    let msgReactions: ReactionStoreData;

    try {
        msgReactions = await reactionSubstore.get(ctx, messageCreatorAddress);
    } catch (error) {
        if (!(error instanceof db.NotFoundError)) {
            logger.info({ helloMessageID, crossChainCommand: this.name }, (error as Error).message);
            logger.error({ error }, 'Error when getting the reaction substore');
            throw error;
        }
        logger.info(
            { helloMessageID, crossChainCommand: this.name },
            `No entry exists for given helloMessageID ${helloMessageID}. Creating a default entry.`,
        );
        msgReactions = { reactions: { like: [] } };
    }
    if (reactionType === 0) {
        const hasLiked = msgReactions.reactions.like.indexOf(ctx.transaction.senderAddress);
        if (hasLiked  > -1) {
            msgReactions.reactions.like = msgReactions.reactions.like.splice(hasLiked, 1);
        } else {
            msgReactions.reactions.like.push(ctx.transaction.senderAddress);
        }
    } else {
        logger.error({ reactionType }, 'invalid reaction type');
    }
    await reactionSubstore.set(ctx, messageCreatorAddress, msgReactions);
}
----

Go back to the file `hello/module.ts` and update it as described in the code comments.

.hello/module.ts
[source,typescript]
----
import { BaseInteroperableModule, ModuleMetadata, ModuleInitArgs } from 'lisk-sdk';
import { ReactCrossChainCommand } from './commands/react_command';
import { ReactEndpoint } from './endpoint';
import { ReactMethod } from './method';
import { ReactInteroperableMethod } from './cc_method';
// Import the type for the InteroperabilityMethod
import { InteroperabilityMethod } from './types';

export class ReactModule extends BaseInteroperableModule {
	public endpoint = new ReactEndpoint(this.stores, this.offchainStores);
	public method = new ReactMethod(this.stores, this.events);
	public commands = [new ReactCrossChainCommand(this.stores, this.events)];
	public crossChainMethod = new ReactInteroperableMethod(this.stores, this.events);
    // Create a private member to store the methods of the interoperability module
	private _interoperabilityMethod!: InteroperabilityMethod;

	// ...

    // Assign the methods of the interoperability module to _interoperabilityMethod
	public addDependencies(interoperabilityMethod: InteroperabilityMethod) {
		this._interoperabilityMethod = interoperabilityMethod;
	}

	// Lifecycle hooks
	// eslint-disable-next-line @typescript-eslint/require-await
	public async init(_args: ModuleInitArgs) {
        // Pass the methods of the interoperability module to the reactCrossChain command
		this.commands[0].init({
			interoperabilityMethod: this._interoperabilityMethod,
		});
	}
}
----

Open the `app.ts` file, and register the module to the application.

Because the `ReactModule` is an *interoperable module*, it is required to call `app.registerInteroperableModule()` additionally.

Last but not least, call the `addDependencies()` method of the `ReactModule` with the methods of the interoperability module as parameter.

IMPORTANT: Please remove the redundant registration of the `ReactModule` in the `modules.ts` file. It was added automatically during the command initialization.

.app.ts
[source,typescript]
----
import { Application, PartialApplicationConfig } from 'lisk-sdk';
import { registerModules } from './modules';
import { registerPlugins } from './plugins';
import { ReactModule } from './modules/react/module';

export const getApplication = (config: PartialApplicationConfig): Application => {
	const { app, method } = Application.defaultApplication(config);
	const reactModule = new ReactModule();
	app.registerModule(reactModule);
	app.registerInteroperableModule(reactModule);
	reactModule.addDependencies(method.interoperability);

	registerModules(app);
	registerPlugins(app);

	return app;
};
----