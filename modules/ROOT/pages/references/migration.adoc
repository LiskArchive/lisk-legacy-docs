= SDK Migration Guide
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc:
:idprefix:
:idseparator: -
:docs-general: ROOT::
:docs-lisk-v5: lisk-sdk::
:docs-understand-modules: {docs-general}understand-blockchain/sdk/modules-commands.adoc
:sectnums:
// URLs
:url_ethereum_events: https://medium.com/mycrypto/understanding-event-logs-on-the-ethereum-blockchain-f4ae7ba50378
:url_wiki_pubsub: https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern
// Project URLs
:url_sdkv5_rpc_events: {docs-lisk-v5}events.adoc
:url_api_rpc_getEvents: {docs-general}api/lisk-node-rpc.adoc
:url_standardevent: {docs-understand-modules}#standard-event
:url_methods: {docs-understand-modules}#methods
:url_endpoints: {docs-understand-modules}#endpoints
:url_understand_rpc_events: {docs-general}understand-blockchain/sdk/rpc.adoc#rpc-events
:url_build_module_event: {docs-general}build-blockchain/module/blockchain-event.adoc

== Terminology changes

[cols="1,1,3",options="header"]
|===
|SDKv6 (new)
|SDKv5 (old)
|Description

|Block generation
|Forging
|Act of proposing a block to a blockchain network.

|Validator node
|Forging node
|A type of node which has capability of generating a block.

|RPC node
|Non-forging node
|A type of node which allows users to query information from a blockchain network.

|Chain ID
|Network ID
|Unique identifier of a chain account.
It is used when sending tokens to a specific chain and also prepended for signing to protect against replay attacks.

|Sidechain client
|Blockchain application
|Refers to software that runs a sidechain node that follows the Lisk protocol.

|Sidechain application
|Blockchain application
|Refers to sidechain client + middleware + UI.

|Module/Plugin endpoint
|Module/Plugin action
|An interface between a module/plugin and an external system via an RPC endpoint.

|Module method
|Module reducer
|An interface for module-to-module communication.

|RPC event
|Application event
|Events which are natively included in the Lisk Framework, and follow the publish/subscribe pattern.
|===

== Introduction of the chain ID

== Removing module & command IDs

The module and command IDs are removed completely in Lisk SDKv6.

Module and command name are used as unique identifiers for modules and commands instead.

.Main benefits of this change
[%collapsible]
====
Improved developer experience::
Reduces the number of required properties and uses strings which are more associative than numbers.
====

== Failed transactions are included in blocks

Transaction fee is paid for every transaction included in a block.
By including failed transactions in blocks, the transaction fee for a transaction is always paid even if it failed and didn't introduce any state changes on the blockchain.

To verify, if a transaction which is included in a block was executed successfully, Lisk SDK v6 introduces the <<addition-of-blockchain-events>>.

.Main benefits of this change
[%collapsible]
====
Increased rewards for validators::
By doing this, validators will still be rewarded for executing the logic of the transaction until the point where it failed.
Increased security::
Additionally, it mitigates the danger of DDoSing sidechains by spamming transactions that will fail, because the transaction fee has to be paid in any case.
====

== Addition of blockchain events

**Blockchain events** are newly introduced, and **Module events** are completely removed in Lisk SDK v6.

Although similar in name, **Blockchain events** follow a completely different approach.
To avoid confusion between the two events, please read the summary below, which is comparing the new and old events inside modules.

.Main benefits of this change
[%collapsible]
=====
Required, if failed transactions are included in blocks::
As explained above, <<failed-transactions-are-included-in-blocks>> in v6.
+
[CAUTION]
====
This means, if you wish to verify that a transaction was successfully executed, it is not sufficient anymore to check, if it is included in a finalized block.
====
+
It could happen that the transaction inside a block has failed, and wasn't executed on the blockchain.
+
But how to check if the transaction failed, or was executed successfully?
To transmit this information, the xref:{url_standardevent}[standard event] is emitted for every transaction included in the particular block.
It informs if that particular transaction was successfully executed, or failed.
+
By adding events, it is therefore possible again to check if a transaction was executed successfully.
At the same time, events can store various additional information on-chain, which can be valuable for other services.
Additional events can be defined per module by the sidechain developer.
=====

[tabs]
=====
Blockchain events - SDKv6::
+
--
[cols="1h,6"]
|===
|Description
|Blockchain events are introduced newly in Lisk SDK v6.
Blockchain events are still defined and emitted inside the module, but it is not possible to subscribe to them via the RPC API of a node.

Instead, blockchain events are **logged per block**, i.e. directly included in the block header and can be queried through the RPC API of a node by requesting the RPC endpoint `chain_getEvents`.

*Blockchain events in Lisk SDK v6 are following a concept comparable to the {url_ethereum_events}[Ethereum event log^].*

Beside the newly introduced blockchain events, there are still a couple of xref:{url_understand_rpc_events}[RPC events] included in the Lisk Framework, which can be retrieved via public-subscribe, as in v5.

The sidechain developer can define new blockchain events per module as desired, but the RPC events are not customizable anymore.
Only new blockchain events can be included in the sidechain client by the developer.

|Purpose
|Blockchain events are a way for modules to store important information which is not included in the transactions or block assets, directly inside the block header.

They are part of the overall state of the blockchain, as an event root of all events included in a particular block is stored in the block header.

They can include a lot of additional data, if required, as the events themselves can be removed from the stores of the node after a certain time, and therefore don't "pollute" the blockchain itself.

|Definition
a|
[source,js]
----
public constructor() {
    super();
    // registration of stores and events
    this.events.register(NewHelloEvent, new NewHelloEvent(this.name));
}
----

For more information how to create the corresponding event class, please check out the guide xref:{url_build_module_event}[]

|Publishing
a|
[source,js]
----
const newHelloEvent = this.events.get(NewHelloEvent);
newHelloEvent.add(context, {
    senderAddress: context.transaction.senderAddress,
    message: context.params.message
},[ context.transaction.senderAddress ]);
----
|Retrieving
a|
In Lisk SDK v6, events are requested per block height after an event is emitted.

Retrieving events from a node:

[source,bash]
----
curl --location --request POST 'http://localhost:7887/rpc' \
--header 'Content-Type: application/json' \
--data-raw '{
    "jsonrpc": "2.0",
    "id": "1",
    "method": "chain_getEvents",
    "params": {
        "height": 123
    }
}'
----
////
Lisk Service now offers additional endpoints to query for events more conveniently.
////
|===
--
Module events - SDKv5::
+
--
[cols="1h,6"]
|===
|Description
|Analog to the xref:{url_sdkv5_rpc_events}[application events] from v5, module events could be subscribed to via the RPC API of a node.

An event informs services that subscribed to it, if a certain event happened (e.g. a transaction was executed), and often contain additional data, providing more information or context about the event.

*Module events in Lisk SDK v5 follow the {url_wiki_pubsub}[publish-subscribe-pattern^].*

|Purpose
|Events are used to communicate about certain events in real time, and to prevent reoccuring RPC request, just to check if there are any changes.

|Definition
a|
[source,js]
----
public events = ['newHello'];
----

For more information how to create the corresponding event class, please check out the guide xref:{url_build_module_event}[]

|Publishing
a|
[source,js]
----
this._channel.publish('hello:newHello', {
    sender: tx.senderAddress.toString('hex'),
    hello: helloAsset.helloString
});
----

|Retrieving
a|
In Lisk SDK v5, events could be subscribed directly via the API client.

If an event was missed, there was no way of retrieving the event, after it was emitted by a node.

[source,js]
----
client.subscribe('app:block:new', ( data ) => {
  console.log('new block:',data);
});
----
|===
--
=====

== Methods replace reducers

The module reducers are renamed to xref:{url_methods}[methods].

Methods in Lisk SDK v6 still have the same purpose as reducers in v5, but beside the name change, they are also defined slightly different, as summarized below:

.Main benefits of this change
[%collapsible]
====
Improved developer experience::
* By providing a base class for the creation of module methods, developers can follow a dedicated pattern to include methods into a module in a straightforward manner.
* The renaming from reducers to methods was introduced to improve intuitive understanding of the meaning behind this data structure.
====

[tabs]
=====
Methods - SDKv6::
+
--
[cols="1h,6"]
|===

|Name
|Method

|Description
|An interface for module-to-module communication.

|Definition
a|
. Define methods in a class which extends from the `BaseMethod`:
+
[source,typescript]
----
export class TokenMethod extends BaseMethod {

    // ...

	public async getAvailableBalance(
		methodContext: ImmutableMethodContext,
		address: Buffer,
		tokenID: TokenID,
	): Promise<bigint> {
		const canonicalTokenID = await this.getCanonicalTokenID(methodContext, tokenID);
		const userStore = this.stores.get(UserStore);
		try {
			const user = await userStore.get(methodContext, userStore.getKey(address, canonicalTokenID));
			return user.availableBalance;
		} catch (error) {
			if (!(error instanceof NotFoundError)) {
				throw error;
			}
			return BigInt(0);
		}
	}

    // ...
}
----
. Assign the `method` attribute of the module to an instance of the Method class, which was created above:
+
[source,typescript]
----
import { TokenMethod } from './method';

export class TokenModule extends BaseInteroperableModule {
	public method = new TokenMethod(this.stores, this.events, this.name);
    // ...
}
----

|Usage
a|
[source,typescript]
----
import { TokenMethod } from '../../../token';
// ...

export class SidechainRegistrationCommand extends BaseInteroperabilityCommand {
	public schema = sidechainRegParams;
	private _tokenMethod!: TokenMethod;

	public addDependencies(tokenMethod: TokenMethod) {
		this._tokenMethod = tokenMethod;
	}
    public async verify(
		context: CommandVerifyContext<SidechainRegistrationParams>,
	): Promise<VerificationResult> {
        // ...
        // Sender must have enough balance to pay for extra command fee.
		const availableBalance = await this._tokenMethod.getAvailableBalance(
			context.getMethodContext(),
			senderAddress,
			TOKEN_ID_LSK,
		);
		if (availableBalance < REGISTRATION_FEE) {
            // ...
		}
        // ...
	}
}
----
|===
--
Reducers - SDKv5::
+
--
[cols="1h,6"]
|===

|Description
|An interface for module-to-module communication.

|Definition
a|
[source,typescript]
----
export class TokenModule extends BaseModule {
	// [...]
	public reducers = {
		credit: async (params: Record<string, unknown>, stateStore: StateStore): Promise<void> => {
			// [...]
		},
		debit: async (params: Record<string, unknown>, stateStore: StateStore): Promise<void> => {
			// [...]
		},
		getBalance: async (
			params: Record<string, unknown>,
			stateStore: StateStore,
		): Promise<bigint> => {
			const { address } = params;
			if (!Buffer.isBuffer(address)) {
				throw new Error('Address must be a buffer');
			}
			const account = await stateStore.account.getOrDefault<TokenAccount>(address);
			return account.token.balance;
		}
	};
    // [...]
}

----

|Usage
a|
Reducers can be invoked through the `reducerHandler`, which is available inside the lifecycle hooks and assets of a module.

[source,typescript]
----
// debit tokens from sender account
await reducerHandler.invoke("token:debit", {
  address: senderAddress,
  amount: asset.initValue,
});
----
|===
--
=====

== Endpoints replace actions

The module actions are renamed to xref:{url_endpoints}[endpoints].

Endpoints in Lisk SDK v6 still have the same purpose as actions in v5, but beside the name change, they are also defined slightly different, as summarized below:

.Main benefits of this change
[%collapsible]
====
Improved developer experience::
* By providing a base class for the creation of module endpoints, developers can follow a dedicated pattern to include endpoints into a module in a straightforward manner.
* The renaming from actions to endpoints was introduced to improve intuitive understanding of the meaning behind this data structure.
====

[tabs]
=====
Endpoints - SDKv6::
+
--
[cols="1h,6"]
|===

|Name
|Endpoints

|Description
|An interface between a module and an external system via an RPC endpoint.

|Definition
a|
[source,typescript]
----
import { BaseEndpoint, ModuleEndpointContext, cryptography } from 'lisk-sdk';
import { MessageStore, MessageStoreData } from './stores/message';

export class HelloEndpoint extends BaseEndpoint {
    public async getHello(ctx: ModuleEndpointContext): Promise<MessageStoreData> {
        // 1. Get message store
        const messageSubStore = this.stores.get(MessageStore);
        // 2. Get the address from the endpoint params
        const { address } = ctx.params;
        // 3. Validate address
        if (typeof address !== 'string') {
            throw new Error('Parameter address must be a string.');
        }
        cryptography.address.validateLisk32Address(address);
        // 4. Get the Hello message for the address from the message store
        const helloMessage = await messageSubStore.get(
            ctx,
            cryptography.address.getAddressFromLisk32Address(address),
        );
        // 5. Return the Hello message
        return helloMessage;
    }
}
----
|Usage
a|
[source,bash]
----
curl --location --request GET 'http://localhost:7887/rpc' \
--header 'Content-Type: application/json' \
--data-raw '{
    "jsonrpc": "2.0",
    "id": "1",
    "method": "hello_getHello",
    "params": {
        "address": "lskuz5p98kz3mqzxnu68qdrjxtvdvr2o7pprtj4yv"
    }
}'
----

[source,typescript]
----
// How to invoke an endpoint that needs some data input.
const data = await client.invoke('namespace_endpointName', input);
console.log(data);
----
|===
--
Actions - SDKv5::
+
--
[cols="1h,6"]
|===

|Description
|

|Definition
a|
[source,typescript]
----
export class HelloModule extends BaseModule {

    // ...

    public actions = {
        amountOfHellos: async () => {
            const res = await this._dataAccess.getChainState(CHAIN_STATE_HELLO_COUNTER);
            const count = codec.decode(
                helloCounterSchema,
                res
            );
            return count;
        },
    };

    // ...
}
----

|Usage
a|
[source,typescript]
----
const data = await client.invoke('app:actionName', input);
----
|===
--
=====

== Migration of store from v5 to v6

[cols="1h,4,4",options="header"]
|===
|
|SDKv5
|SDKv6

|Description
|
|

|Definition
|
|

|Usage
|
|
|===

== Addition of metadata

.Main benefits of this change
[%collapsible]
====
Improved developer experience::
* By providing a base class for the creation of module methods, developers can follow a dedicated pattern to include methods into a module in a straightforward manner.
* The renaming from reducers to methods was introduced to improve intuitive understanding of the meaning behind this data structure.
====

== Removing account schema

.Main benefits of this change
[%collapsible]
====
Improved developer experience::
* By providing a base class for the creation of module methods, developers can follow a dedicated pattern to include methods into a module in a straightforward manner.
* The renaming from reducers to methods was introduced to improve intuitive understanding of the meaning behind this data structure.
====

== Update of how to register module and dependencies

.Main benefits of this change
[%collapsible]
====
Improved developer experience::
* By providing a base class for the creation of module methods, developers can follow a dedicated pattern to include methods into a module in a straightforward manner.
* The renaming from reducers to methods was introduced to improve intuitive understanding of the meaning behind this data structure.
====

[cols="1h,4,4",options="header"]
|===
|
|SDKv5
|SDKv6

|Description
|
|

|Definition
|
|

|Usage
|
|
|===