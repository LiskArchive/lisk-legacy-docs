= Creating transactions and signing them offline
:toc: preamble
:idprefix:
:idseparator: -
:docs_sdk: lisk-sdk::
:url_guides_decoding: integrate-blockchain/encode-decode.adoc
:url_transfer_asset: {docs_sdk}modules/token-module.adoc#transferasset
:url_register_delegate_asset: {docs_sdk}modules/dpos-module.adoc#registertransactionasset
:url_vote_delegate_asset: {docs_sdk}modules/dpos-module.adoc#votetransactionasset
:url_unlock_asset: {docs_sdk}modules/dpos-module.adoc#unlocktransactionasset
:url_pom_asset: {docs_sdk}modules/dpos-module.adoc#pomtransactionasset
:url_framework_httpapi: {docs_sdk}plugins/http-api-plugin.adoc
:url_service: lisk-service::index.adoc

How to create and sign a transaction in an entirely offline environment.

== Using the node CLI to create a transaction offline

The CLI  of a node can be used to create a transaction, even if the node is currently offline.

[NOTE]
====
The flag `--offline` is used here, so that the transaction can be signed, even if the node is not connected to any network at the moment.

The `--offline` flag also requires the flags `--chain-id` and `--nonce` to be specified.
====

[source,bash]
----
./bin/run transaction:create token transfer 10000000 --chain-id=00000000 --nonce=0 --offline
----

[source,bash]
----
? Please enter: amount:  1000000000
? Please enter: recipientAddress: lsk44ejwrjb4g44hj9mbtc43h8bcu54g2gbbyyvrk
? Please enter: data:  Happy Birthday!
? Please enter passphrase:  [hidden]
? Please re-enter passphrase:  [hidden]
----

After all relevant information about the transaction is given, the transaction is created and returned in hex format:

----
{"transaction":"0802100018022080c2d72f2a20e03c09bdc8c023d94cf66a5d352e6258380210d97d545abbf75668ea3736e3123229088094ebdc031214ab0041a7d3f7b2c290b5b834d46bdc7b7eb858151a0b73656e6420746f6b656e733a40faa2626d7306506b1999f48aa2f4b1ffdee01e641fa76d37a9d1d6fd8c225a81065c856ea625c52d138a7e3ba86b62913dc8e5aef8b5e307641ab66e0277a60b"}
----

.How to additionally return the transaction in JSON format
[%collapsible]
====
To also see the decoded transaction object on creation, add the `--json` parameter:

[source,bash]
----
$ ./bin/run transaction:create token transfer 10000000 --chain-id=00000000 --nonce=0 --offline
----

This creates reply as seen below:

[source,json]
----
{
  "transaction": "0802100018022080c2d72f2a20e03c09bdc8c023d94cf66a5d352e6258380210d97d545abbf75668ea3736e3123229088094ebdc031214ab0041a7d3f7b2c290b5b834d46bdc7b7eb858151a0b73656e6420746f6b656e733a40faa2626d7306506b1999f48aa2f4b1ffdee01e641fa76d37a9d1d6fd8c225a81065c856ea625c52d138a7e3ba86b62913dc8e5aef8b5e307641ab66e0277a60b"
}
----

[source,json]
----
{
  "transaction": {
    "moduleID": 2,
    "assetID": 0,
    "nonce": "2",
    "fee": "100000000",
    "senderPublicKey": "e03c09bdc8c023d94cf66a5d352e6258380210d97d545abbf75668ea3736e312",
    "signatures": [
      "faa2626d7306506b1999f48aa2f4b1ffdee01e641fa76d37a9d1d6fd8c225a81065c856ea625c52d138a7e3ba86b62913dc8e5aef8b5e307641ab66e0277a60b"
    ],
    "asset": {
      "amount": "1000000000",
      "recipientAddress": "ab0041a7d3f7b2c290b5b834d46bdc7b7eb85815",
      "data": "send tokens"
    }
  }
}
----
====

== Creating transactions offline with Lisk Elements

The following Lisk Elements packages are required to create and sign a transaction offline:

Required::
* @liskhq/lisk-client, including the following libraries:
** @liskhq/lisk-transactions

Recommended::
* @liskhq/lisk-client, including the following libraries:
** @liskhq/lisk-transactions
** @liskhq/lisk-validator

=== Require the transaction and params schema

To create, validate, and sign transactions offline with Lisk Elements, it is necessary to access their schemas.
Create a new file `schemas.js` and add all required schemas in this file, as shown in the snippet below.

The corresponding param schemas can be found in the module reference pages listed below:

* xref:{}[Register Mainchain]
* xref:{}[Register Sidechain]
* xref:{url_register_delegate_asset}[Register Validator]
* xref:{url_pom_asset}[Report Delegate Misbehavior]
* xref:{url_vote_delegate_asset}[Stake]
* xref:{url_unlock_asset}[Unlock Tokens]
* xref:{url_transfer_asset}[Transfer Token]

In this example, we will send a Transfer Token transaction, therefore two different schemas are required:

. The transaction schema (always required).
. The Transfer Token params schema.

.schemas.js
[source,js]
----
const transactionSchema = {
  $id: '/lisk/transaction',
  type: 'object',
  required: ['module', 'command', 'nonce', 'fee', 'senderPublicKey', 'params'],
  properties: {
    module: {
      dataType: 'string',
      fieldNumber: 1,
      minLength: 1,
      maxLength: 32,
    },
    command: {
      dataType: 'string',
      fieldNumber: 2,
      minLength: 1,
      maxLength: 32,
    },
    nonce: {
      dataType: 'uint64',
      fieldNumber: 3,
    },
    fee: {
      dataType: 'uint64',
      fieldNumber: 4,
    },
    senderPublicKey: {
      dataType: 'bytes',
      fieldNumber: 5,
      minLength: 32,
      maxLength: 32,
    },
    params: {
      dataType: 'bytes',
      fieldNumber: 6,
    },
    signatures: {
      type: 'array',
      items: {
        dataType: 'bytes',
      },
      fieldNumber: 7,
    },
  },
};

const transferParamsSchema = {
  $id: '/lisk/transferParams',
  title: 'Transfer transaction params',
  type: 'object',
  required: ['tokenID', 'amount', 'recipientAddress', 'data'],
  properties: {
    tokenID: {
      dataType: 'bytes',
      fieldNumber: 1,
      minLength: 8,
      maxLength: 8,
    },
    amount: {
      dataType: 'uint64',
      fieldNumber: 2,
    },
    recipientAddress: {
      dataType: 'bytes',
      fieldNumber: 3,
      format: 'lisk32',
    },
    data: {
      dataType: 'string',
      fieldNumber: 4,
      minLength: 0,
      maxLength: 64,
    },
  },
};
----

=== Creating and signing the transaction

Require the schemas and the necessary Lisk Elements packages to sign a transaction.

Then, create the unsigned transaction object manually by following the transaction schema.
It is recommended to verify the correct format of the transaction with the lisk-validator afterwards.

Then, manually create the parameters for the Transfer Tokens command, and add them to the unsigned transaction.

Finally, use the `signTransaction()` function of the `@liskhq/lisk-transactions` library to sign the transaction.

.offline.js
[source,js]
----
const { validator, transactions } = require('@liskhq/lisk-client');
const { transactionSchema, transferParamsSchema } = require('./schemas');

// Example account credentials
const account = {
  "passphrase": "chalk story jungle ability catch erupt bridge nurse inmate noodle direct alley",
  "privateKey": "713406a2cf2bdf6b951c1bcba85d44eddbc06d003e8d3faf433b22be28333d97840c66741a76f936bed0a4c308e4f670156e1e1f6b91640bb8d3dd0ae2b3581e",
  "publicKey": "840c66741a76f936bed0a4c308e4f670156e1e1f6b91640bb8d3dd0ae2b3581e",
  "binaryAddress": "85c12d39041bc09e1f89dfeffe4b87cfcfe79fb2",
  "address": "lskuwzrd73pc8z4jnj4sgwgjrjnagnf8nhrovbwdn"
};

// Create the unsigned transaction manually
const unsignedTransaction = {
  module: "token",
  command: "transfer",
  fee: BigInt(10000000),
  nonce: BigInt(23),
  senderPublicKey: Buffer.from(account.publicKey,'hex'),
  params: Buffer.alloc(0),
  signatures: [],
};

// Validate the transaction
const transactionErrors = validator.validator.validate(transactionSchema, unsignedTransaction);

if (transactionErrors && transactionErrors.length) {
  throw new validator.LiskValidationError([...transactionErrors]);
}

// Create the params for the Transfer Token transaction
const transferParams = {
  tokenID: Buffer.from('0000000000000000','hex'),
  amount: BigInt(2000000000),
  recipientAddress: Buffer.from(account.binaryAddress,'hex'),
  data: 'Happy birthday!'
};

// Add the transaction params to the transaction object
unsignedTransaction.params = transferParams;

console.log(unsignedTransaction);
/*
{
  module: 'token',
  command: 'transfer',
  fee: 10000000n,
  nonce: 23n,
  senderPublicKey: <Buffer 84 0c 66 74 1a 76 f9 36 be d0 a4 c3 08 e4 f6 70 15 6e 1e 1f 6b 91 64 0b b8 d3 dd 0a e2 b3 58 1e>,
  params: {
    tokenID: <Buffer 00 00 00 00 00 00 00 00>,
    amount: 2000000000n,
    recipientAddress: <Buffer 85 c1 2d 39 04 1b c0 9e 1f 89 df ef fe 4b 87 cf cf e7 9f b2>,
    data: 'Happy birthday!'
  },
  signatures: []
}
*/

const chainID = '00000000';

// Sign the transaction
const signedTransaction = transactions.signTransaction(
  unsignedTransaction,
  Buffer.from(chainID, 'hex'),
  Buffer.from(account.privateKey,'hex'),
  transferParamsSchema
);

console.log(signedTransaction);
/*
{
  module: 'token',
  command: 'transfer',
  fee: 10000000n,
  nonce: 23n,
  senderPublicKey: <Buffer 84 0c 66 74 1a 76 f9 36 be d0 a4 c3 08 e4 f6 70 15 6e 1e 1f 6b 91 64 0b b8 d3 dd 0a e2 b3 58 1e>,
  params: {
    tokenID: <Buffer 00 00 00 00 00 00 00 00>,
    amount: 2000000000n,
    recipientAddress: <Buffer 85 c1 2d 39 04 1b c0 9e 1f 89 df ef fe 4b 87 cf cf e7 9f b2>,
    data: 'Happy birthday!'
  },
  signatures: [
    <Buffer c4 9c c0 7a 53 f9 79 8e c6 29 b5 08 2c a3 c5 e6 c9 22 a7 7b 40 84 f2 53 67 e4 53 9d 35 49 ca b7 ef fd 93 84 1e 3d 6b a6 aa 7d 7a d7 26 35 d7 fd d6 9d ... 14 more bytes>
  ],
  id: <Buffer a0 a8 07 5e 9b 6f 51 6f c2 78 fb ac bb bb d6 d3 66 10 89 5d ae e4 a7 d6 7b a5 79 dd c3 a6 86 c0>
}
*/
----

As shown in the example output, values for `signatures` and `id` are added to a transaction when it is signed by a user.

=== Verifying the transaction
//TODO: Add link to section explaining dry-runs
A transaction dry-run can only be performed *online*, by connecting to a node.

Without dry-running the transaction, its' validity cannot be verified, and the transaction might fail.

To connect to a node, create a function that provides an instance of the Lisk API client.

[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');

const RPC_ENDPOINT = 'ws://localhost:7887/rpc-ws';
let clientCache;

const getClient = async () => {
  if (!clientCache) {
    clientCache = await apiClient.createWSClient(RPC_ENDPOINT);
  }
  return clientCache;
};
----

Call the function to retrieve the API client, and use it to perform a dry-run of the transaction which was created offline.

[source,js]
----
getClient().then(client => {
  const encTx = client.transaction.encode(signedTransaction);
  client.invoke('txpool_dryRunTransaction',{"transaction":encTx.toString("hex") }).then(res => {
    console.log("Dry-un result: ", res);
    process.exit(0);
  }).catch(err => {
    console.log("Error1: " + err);
    process.exit(1);
  });
});
----

If the dry-run finishes without errors, the transaction is valid.