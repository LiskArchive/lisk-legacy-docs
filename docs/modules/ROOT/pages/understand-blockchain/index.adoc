= Understand Lisk blockchain
Muhammad Talha <muhammad.talha@lightcurve.io>
//Settings
:toc: preamble
:toclevels: 5
:page-toclevels: 3
:idprefix:
:idseparator: -
:fn_gpk: footnote:generatorPublicKey[Previously the `generatorPublicKey` property (see https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md#change-generator-public-key-to-generator-address[LIP 0055^] for more information).]
:fn_eventroot: footnote:eventroot[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0065.md[LIP 0065^] for the reason why it needs to be included in a block header.]
:fn_stateroot: footnote:stateroot[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0040.md[LIP 0040^] for the reason why it needs to be included in a block header.]
:fn_aggregate: footnote:aggregate[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0061.md[LIP 0061^] for more details.]
// URLs
:url_lip55: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md
// Project URLs
:url_what_is_blockchain: intro/what-is-blockchain.adoc
:url_intro_how_blockchain_works: intro/how-blockchain-works.adoc#state-machine
:url_intro_consensus: intro/how-blockchain-works.adoc#consensus-mechanisms
:url_understand_state_machine: understand-blockchain/state-machine.adoc
:url_understand_consensus: understand-blockchain/consensus/index.adoc
:url_understand_network: understand-blockchain/lisk-protocol/network.adoc
:url_understand_state_machine_tree: understand-blockchain/state-machine.adoc#the-blockchain-state-as-sparse-merkle-tree
:url_understand_sdk_commands: understand-blockchain/sdk/modules-assets.adoc#assets
:url_understand_sdk_modules: understand-blockchain/sdk/modules-assets.adoc
:lisk_service: lisk-service::
:docs_sdk: lisk-sdk::
:lisk_cross_chain_communication: understand-blockchain/interoperability/communication.adoc
:url_lisk_default_modules: {docs_sdk}modules/index.adoc
:url_lisk_service_intro: {lisk_service}index.adoc
:url_consensus: understand-blockchain/consensus.adoc

:url_introduction_modules: understand-blockchain/sdk/modules-commands.adoc
:url_introduction_plugins: understand-blockchain/sdk/plugins.adoc
:url_advanced_communication: understand-blockchain/sdk/rpc.adoc
:url_advanced_architecture_config: {docs_sdk}config.adoc
:url_advanced_communication_endpoints: understand-blockchain/sdk/rpc.adoc#endpoints
:url_advanced_communication_events: understand-blockchain/sdk/rpc.adoc#events
:url_protocol: understand-blockchain/lisk-protocol/index.adoc
:url_protocol_blocks: understand-blockchain/lisk-protocol/blocks.adoc
:url_protocol_consensus: understand-blockchain/lisk-protocol/consensus-algorithm.adoc#voting_and_weight
:url_protocol_transactions: understand-blockchain/lisk-protocol/transactions.adoc
:url_references_forger_plugin: {docs_sdk}plugins/forger-plugin.adoc
:url_references_monitor_plugin: {docs_sdk}plugins/monitor-plugin.adoc
:url_references_report_misbbehavior_plugin: {docs_sdk}plugins/report-misbehavior-plugin.adoc
:url_references_dpos_module: {docs_sdk}modules/dpos-module.adoc
:url_references_token_module: {docs_sdk}modules/token-module.adoc
:url_tutorials_nft: tutorial/nft.adoc
:url_tutorials_srs: tutorial/srs.adoc
:url_integrate_ui: integrate-blockchain/create-user-interface.adoc
:url_lisk_service: {lisk_service}index.adoc
:url_sdk_plugins: {docs_sdk}plugins/index.adoc
:url_fork_choice_rule: understand-blockchain/lisk-protocol/consensus-algorithm.adoc#fork_choice_rules


//External URLs
:url_lisk_roadmap: https://lisk.com/roadmap
:url_github_lns_dashboard: https://github.com/LiskHQ/lisk-sdk-examples/tree/nh-lisk-name-service/tutorials/lisk-name-service/lns-dashboard-plugin
:url_github_srs: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/social-recovery
:url_blog_benchmark: https://lisk.com/blog/development/benchmarking-lisk-core-v3.0.0-against-lisk-core-v2.1.6-0
:url_lisk_apps: https://lisk.com/ecosystem
//Project URLs

In the "Understand Lisk blockchain" category you learn the basic concepts of Lisk blockchain, Network, and Protocol. The page discusses the topics and terms that are important to know when developing within the Lisk ecosystem.

This page gives an overview of what Lisk blockchain is. what are the key elements of a Lisk blockchain? what Lisk Network and Protocol is? what are blockchain applications and a basic structure for blockchain applications?




== What is Lisk Blockchain?

A xref:{url_what_is_blockchain}[blockchain] is a chain of interconnected blocks on various nodes distributed across a P2P network.
Each node keeps its copy of the blockchain protocol and its related data. It syncs periodically with other nodes to ensure that the nodes' records are up to date.

The Lisk blockchain also follows the same principle.
It is a combination of the mainchain and many interconnected sidechains.
Each sidechain is registered to the mainchain and is specific to a blockchain application.
Unlike Ethereum, where dApps have to share the same chain for their blockchain needs, Lisk provides the opportunity for each application to have its sidechain.

This enables slower chain growth as information is only received from a single blockchain application.
It also provides faster block generation, reduces the burden on the network, and increases scalability.
These sidechains can also communicate with other sidechains with the help of xref:{lisk_cross_chain_communication}[Lisk Cross Chain Communication].

**Applications built with Lisk blockchains are called "blockchain applications". **These applications can have customized logic, UIs, and a blockchain as their application's database.
An overview of Lisk Blockchain can be seen below in the following diagram.

.Overview of Lisk Blockchain
image::understand-blockchain/lisk-blockchain-overview.png["Lisk blockchain overview", 600, align="center"]

xref:{url_lisk_service}[Lisk Service] is an enriched node API that provides a convenient method of sending or getting data from the Lisk blockchain. It supports all the Lisk APIs posting data to the blockchain. It also allows data aggregation of the relevant data for external services, enriching it if needed with off-chain data as well. Lisk Service also provides additional endpoints to get the data efficiently.

=== The three domains of a blockchain

At a high level, there are three domains of a blockchain:

.The three domains of a blockchain
image::understand-blockchain/3-domains.png["3 domains of blockchain", 300, align="center"]

. **Application domain**: Responsible for verifying data and transitioning the blockchain state with deterministic logic via the xref:{url_understand_state_machine}[state machine].
. xref:{url_understand_consensus}[*Consensus domain*]: Responsible for the replication of the same sequence of states among all nodes in the network.
This is achieved by nodes in the network following a xref:{url_intro_consensus}[consensus protocol] and utilizing the application and network domains.
. xref:{url_understand_network}[*Network domain*]: Responsible for the communication of the peer-to-peer network.


=== Lisk Network

A blockchain application generally consists of a network of servers, which are also called *nodes* in this context.

A typical network of nodes is illustrated in the diagram below:

image:intro/node-network.png[Side chain's node network, 900 ,align="center"]

.Shared on-chain logic, optional off-chain logic
****
All nodes in the network need to share the same on-chain logic as described in <<Modules>>. On the contrary, the off-chain logic as discussed in <<Plugins>> can differ from node to node.
****

==== P2P: Unstructured partial mesh network
The P2P network of nodes is unstructured, which means that all nodes are equal participants in the network.
It is also a partial mesh network, therefore every node is only connected to a small subset of nodes in the network.

Unstructured partial mesh networks allow nodes to share information in a very expeditious and secure manner with all other nodes.
In addition, they also have the ability to scale extremely well, even for large networks with thousands of connected nodes.

=== Lisk Protocol

As mentioned earlier, a blockchain application consists of a network of nodes connected via P2P. Each node has an instance of Lisk Protocol and together, these nodes form a chain. The on-chain logic present in each instance of the Lisk protocol must be the same for a chain. However, the off-chain logic for each node can differ within a chain.

Each blockchain application has its blockchain known as a sidechain. This sidechain is registered with the mainchain.

A node can only connect to a single network which can either be the mainchain or the sidechain.

The Lisk Protocol is divided into two layers:

* Application layer
* Engine layer

A detailed picture of the Lisk Protocol is present in the following architecture diagram.

image:architecture.png[lisk-framework-architecture, 900 , align="center"]

==== Application layer
The application layer handles state changes to the blockchain.
Its job is to connect with the outside world i.e. external services and software to send and receive data from them.
An application layer consists of a <<State machine>>, <<Modules>>, <<Plugins>>, and <<Configuration>>.

===== State machine

As the name suggests, a state machine is relevant to the states of a machine. Lisk protocol relies heavily on its state machine to mutate the state of a blockchain. 

* *States:* A state machine typically has a set of different states that it can enter. For example, a padlock represented as a state machine would have the two states "Open" and "Locked".

* *Transitions*: A set of allowable operations that change one state to another. For example, to change from the state "Open" to "Locked", a transition would be "Close padlock", and from "Locked" to "Open", it would be "Insert key & turn".

Lisk Protocol changes states with the help of modules, which define the on-chain logic for the blockchain application.

===== Modules

Modules aid the state machine to transition the state of the blockchain with verified and validated data.
They contain on-chain logic which is part of the blockchain protocol.

For example, if Bob wants to send 10 LSKs to Alice then, behind the scenes a module will verify the validity of such a request.
Upon validation and verification, the module will ask the state machine to transfer 10 LSKs from Bob's account to Alice's account.

TIP: Lisk provides a range of modules out of the box, for more information see xref:{url_lisk_default_modules}[].

====== When to create a module

xref:{url_introduction_modules}[Modules] are able to perform the following functions:

* Define how data is stored on the blockchain.
* Define logic that is executed per block footnote:block_footnote[For more information about blocks, check out xref:{url_protocol_blocks}[].]
* Define logic that is executed per transaction footnote:tx_footnote[For more information about transactions, see xref:{url_protocol_transactions}[].].

===== Plugins

Plugins represent the off-chain logic.
A plugin is not part of the Lisk protocol and must be registered with the application layer before its use.
Each node inside the network can deploy various kinds of plugins to support their off-chain logic.

For example, consider a case where a node wants to investigate possible misbehaviors in the Lisk network. For that, the node operator must gather all the blocks' data from the network, store it somewhere and analyze it to catch misbehavior.

A node manager can write a script to perform the aforementioned task. However,  Lisk provides the xref:{url_references_report_misbbehavior_plugin}[Report Misbehavior Plugin] which listens to blocks' data and reports a node about a generator's misbehavior.

To add a new plugin to your application, either reuse an existing plugin from another blockchain application or create a new plugin based on the specific requirements of your application.

TIP: Lisk provides a set of plugins that can be injected into the Application layer when needed. For more information, see xref:{url_sdk_plugins}[Plugins].

====== When to create a plugin

xref:{url_introduction_plugins}[] are able to perform the following:

* Search the blockchain data.
* Aggregate the blockchain data.
* Provide a UI for the blockchain application.
* Automate the blockchain logic, such as automatically sending transactions.
* Add a proxy to the application interfaces.

===== Configuration
Lisk understands the need for flexibility in terms of how a node should be run or how specific on-chain and off-chain logic should execute. 
To serve this purpose, the Lisk protocol accepts a configuration that is part of the state machine.

A set of default configurations are passed to a blockchain application.
These configurations can be tweaked as per necessity.
For off-chain domains and logic e.g. Plugins etc., the configurations can differ for each node.
However, the configurations for on-chain logic e.g. Modules etc., must be the same across the network of a blockchain application.

TIP: For more information about the available configurations, see xref:{url_advanced_architecture_config}[].

==== Engine layer
The Engine layer acts as a bridge between the *Blockchain* and the *Application layer*. The engine is responsible for managing upcoming transactions, generating blocks, reaching consensus, storing the chain\'s data in data stores, and dispersing the new blocks to other nodes on the network.
An engine layer consists of the following domains:

* Transaction Pool
* Generator
* Consensus
* Chain
* P2P

===== Transaction Pool
A transaction pool is where new transactions exist before they become part of the blockchain.
It is similar to mempool in Ethereum.
Whenever a new transaction is created, it has to be sent to a transaction pool.
The transaction pool receives the new transaction, verifies it with the help of the Application layer, and then stores it in the transaction pool until its part of a block.

A node operator can configure the Transaction pool via the *Configurations* passed to the Application layer.
Node operator can change transaction properties like _maximumTransactionsLimit_, _transactionPerAccount_, _minimumRequirementFee_, and _minimumReplacementFee_, etc.

Once a set of verified transactions are available in the pool, they are sent to the generator for further processing.

===== Generator
A generator handles the generation of new blocks.
The generator picks up the transactions from the transaction pool and orders them in terms of higher fees.
The generator then executes each transaction with the help of the state machine to check its validity.
Once verified, the transactions are added to the block header.
A generator uses the _last generated block_ and _generator keys_ to generate a block.
//For more information about Generator and Block Generation, see <<URL>>

===== Consensus
The consensus domain applies the xref:{url_fork_choice_rule}[fork choice rule] and checks the properties contained in the block header.
It is also responsible for the replication of the same sequence of states among all nodes in the network.
For more information, see xref:{url_consensus}[Consensus].

===== Chain
After a consensus for a block is reached and the state has been changed, the new block's information is passed to the Chain.
The chain stores the transaction data in a data store.

A chain is also responsible for fetching blockchain data from the data stores.

===== P2P
The P2P domain handles sending and receiving data from nodes. 
It also maintains an active connection with the Lisk Network. 
Every node receives new blocks generated by other nodes via the P2P network.
The receiver node in that case repeats all the steps mentioned in the Engine layer. 
If the received block is verified, the receiving node adds it to their instance of blockchain.

===== Data Stores
Each blockchain node keeps data on various data stores inside its Lisk protocol instance. This data is of two types: on-chain and off-chain.

* *On-chain* data includes but is not limited to state data of the chain, account balance, nonce, multi-signature keys, generators' information, and the Sparse Merkel tree, etc.
The blocks, transactions, events, and assets are also part of the on-chain data among various other properties.

* *Off-chain* data includes but is not limited to node information, peer list, random hash, etc. 
It also contains information for generators i.e. last generated block, encrypted keys, etc.
Lisk also maintains off-chain data about the legacy chains.
Legacy data consists of blocks from depreciated versions of the protocol.

==== Communication interfaces / APIs

image::intro/communication-architecture.png[ communication-interfaces,1000 ,align="center"]

The communication architecture of the Lisk protocol allows internal application components and external services to communicate to the blockchain application via various channels.

The Lisk protocol provides three industry-standard communication protocols: Inter-Process Communication (IPC), Web Sockets (WS), and Hypertext Transfer Protocol (HTTP).
The communication protocol of the blockchain application can be changed through xref:{url_advanced_architecture_config}[configurations].

It is possible to communicate to modules and plugins directly by invoking xref:{url_advanced_communication_endpoints}[endpoints] via an RPC request, or by subscribing to xref:{url_advanced_communication_events}[events].

It is recommended to use the IPC/WebSocket protocols where possible, as they provide more enhanced performance regarding the response times, (see the blog post: {url_blog_benchmark}[Benchmarking Lisk Core v3.0.0 against Lisk Core v2.1.6]).

For more information about the communication architecture, see xref:{url_advanced_communication}[Communicating to a Lisk node via RPC].

=== What are blockchain applications?

A blockchain application is any kind of application that uses its own blockchain as a database layer.

More specifically, within the Lisk documentation, every time we talk about blockchain applications, we are referring to applications running on blockchains that are compatible with <<lisk-protocol>>.

Blockchain applications are highly customizable as the Lisk protocol allows, creating a scalable UI and business logic on top of the Lisk Service. 

.Examples of blockchain applications
****
Examples of blockchain applications can be found in the tutorials, such as the xref:{url_tutorials_nft}[], or the xref:{url_tutorials_srs}[] application.

Additionally, check out the apps list at the {url_lisk_apps}[Blockchain applications powered by Lisk^] page.
****

==== Structure of blockchain applications

image::intro/ui-diagrams.png[different-structures-of-blockchain-application,700 ,align="center"]

Blockchain applications usually consist of a frontend and a backend, like normal web applications.

In contrast to normal server-client applications, there is not one central backend, but rather a whole network of nodes that together secure and maintain the status of the blockchain.
Each node can handle complex business logic and provides a flexible and customizable API.
The blockchain itself is used as a database layer for the application.

The frontend allows users to interact with the blockchain application.
The implementation of a frontend is flexible.
For example, this can be achieved in the following ways:

TIP: Although it is possible to build a UI through plugins, It is recommended to separate the UI from the backend of the application to increase scalability.

[loweralpha]
. Plugins can be used to develop a UI for a blockchain application. You can create and register a UI xref:{url_introduction_plugins}[plugin] for your blockchain application.
An example implementation of a *frontend as a plugin* is the {url_github_lns_dashboard}[LNS UI plugin] for the example application Lisk Name Service.


. Use your favorite framework/ programming language to develop a *standalone user interface*, and communicate to the node via the available <<communication-interfaces-apis>>.
One example is the frontend of the {url_github_srs}[SRS example application^], which has been developed with React.js.
Another example is the UI for the Hello World application, detailed in the guide xref:{url_integrate_ui}[].

. For later requirements in a production environment, a *middleware* similar to xref:{url_lisk_service_intro}[Lisk Service] should be used, which will aggregate the data from the blockchain network and other 3rd party sources as well.
With middleware, you can also create a custom service as per your business needs to support various UI projects like mobile and web applications.
The frontend can then request this data via API requests from the middleware.





==== Blockchain applications vs. dApps
As blockchain applications are also in a sense decentralized applications, you may wonder what is the difference between blockchain applications and dApps, or if there is any difference at all.

In short, the main difference between dApps and blockchain applications is that each blockchain application runs on its own blockchain known as a sidechain. However, dApps share the blockchain network with other dApps.

dApps are generally constructed as smart contracts, for example on the Ethereum blockchain.
The development of blockchain applications is quite different because it is much similar to building a normal web application.

Most functionalities of smart contracts can be implemented in blockchain applications in a very straightforward manner. 
However, there is one important difference here to dApps, when it comes to applying new on-chain logic to the application.
New smart contracts can be directly applied on the running blockchain while adding new on-chain logic to blockchain applications always requires a hard fork in the network. 

If the flexible characteristics of smart contracts are desired inside a blockchain application, it is of course also possible to develop a blockchain application that supports smart contracts.
For example, a new module could be added to the application, which accepts smart contracts.
This way it is possible to have the best of both worlds combined.

Additionally, smart contracts can reuse an already existing blockchain, which saves time when launching the application, as it is not necessary to take care of setting up an independent blockchain network, and finding generators footnote:delegate_footnote[For more information about generators, check the xref:{url_protocol_consensus}[Consensus algorithm] page of the Lisk protocol.], etc.

Blockchain applications on the contrary rely on their blockchain, and therefore also need to take care of maintaining their network.
In the beginning, this will make the launch of the application slightly more complex, however, having an independent network comes with numerous benefits which are covered in the following paragraphs.

The Lisk documentation refers to applications built with the Lisk protocol as "blockchain applications" and not "dApps". To clarify the difference, blockchain applications do not share a common blockchain, but instead, each runs on its chain.
As a result blockchain applications have the following advantages:

* Lower transaction fees, as the high traffic of one blockchain application, does not affect other blockchain applications.

* The blockchain for the application can be designed with the optimal characteristics for the specific use case, (for example by adjusting the block time or the number of generators or even changing the whole consensus algorithm).

* A much more scalable blockchain, as it only handles the data from one blockchain application.
Hence it is growing much slower in size and doesn't suffer as much from potential bottlenecks in the network, which can happen during times of high workload on many different dApps.

* Interoperability is another perk of Lisk. Various sidechains registered to the mainchain can communicate with each other and exchange value through the mainchain.  
A detailed account of Lisk interoperability features is discussed in the xref:{lisk_cross_chain_communication}[Lisk Cross Chain Communication] page.














