= How to create a command
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc: preamble
:idseparator: -
:idprefix:
:docs_sdk: lisk-sdk::
// URLs
:url_json_schema: https://json-schema.org/understanding-json-schema/reference/index.html
:url_json_schema_length: https://json-schema.org/understanding-json-schema/reference/string.html#length
:url_github_hello_command: https://github.com/LiskHQ/lisk-sdk-examples/tree/188-hello-v6/tutorials/hello/hello_client/src/app/modules/hello/commands/create-hello.ts
// Project URLs
:url_guides_setup: build-blockchain/create-blockchain-app.adoc
:url_guides_module: build-blockchain/module/index.adoc
:url_guides_module_config: build-blockchain/module/configuration.adoc
:url_guides_module_stores: build-blockchain/module/stores.adoc
:url_guides_index_helloapp: build-blockchain/index.adoc#the-hello-world-application
:url_understand_modules: understand-blockchain/sdk/modules-commands.adoc
:url_understand_modules_commands: {url_understand_modules}#commands
:url_sdk_references_commander: {docs_sdk}references/lisk-commander
:url_transaction_asset: glossary.adoc#transaction-asset
:url_module_asset: glossary.adoc#module-asset

====
On this page, you'll learn how to:

* [x] Create a new command
* [x] Write verification for a command
* [x] Use module config values for command verification
* [x] Write execution logic for a command
* [x] Get and set data from module stores

.Sample code
[NOTE]
=====
View the complete sample code of this guide on GitHub in the {url_github_hello_command}[Lisk SDK examples repository^].
=====
====

As defined on the xref:{url_guides_module}[] page, the command shall provide the following functionality:

* A Hello message shall be stored in the user accounts.
** The Hello message has to be of type `string`.
** The Hello message shall have a minimum and maximum length.
** A blacklist of excluded words should exist.
The Hello message should be rejected, if it includes one of the words in the blacklist.

== Generating the command skeleton

In the root folder of the blockchain application, generate a skeleton for the new command with Lisk Commander.

The command `lisk generate:command` expects two arguments:

. *Module name*: The name of the module the asset belongs to.
. *Command name*: The name of the new command.
It needs to be a string that only consists of lower case and upper case letters [a-z, A-Z].
No numbers, hyphens, etc., are allowed.

For a complete overview of all available options of `lisk generate:command`, see the xref:{url_sdk_references_commander}[Lisk Commander reference] or type `lisk generate:command --help`.

For our example, we choose `createHello` as command name, and `hello`  as module name:

[[generate-command]]
.In the client root folder
[source,bash]
----
lisk generate:command hello createHello
----

This will generate the following files:

.hello/hello_client/
----
├── bin/
├── config/
├── src/
│    ├── app/
│    │    ├── app.ts
│    │    ├── index.ts
│    │    ├── modules/
│    │    │   └── hello/
│    │    │      ├── commands/
│    │    │      │     └──  create_hello_command.ts <1>
│    │    │      ├── endpoint.ts
│    │    │      ├── events/
│    │    │      ├── method.ts
│    │    │      ├── module.ts
│    │    │      └── stores/
│    │    ├── modules.ts
│    │    ├── plugins/
│    │    └── plugins.ts
│    └── commands/
└── test/
    ├── integration/
    ├── network/
    └── unit/
        ├── modules/
        │    └── hello/
        │       ├── commands/
        │       │     └──  create_hello_command.ts <2>
        │       └── modules.spec.ts
        └── plugins/
----

<1> Will contain the code for the command.
Currently, it contains the auto-generated command skeleton.
<2> Will contain unit tests for the command.
Currently, it contains the auto-generated test skeletons.

Additionally, it will already import and register the new command in the Hello module:

[source,typescript]
----
import { CreateHelloCommand } from "./commands/create_hello_command";
// [...]
export class HelloModule extends BaseModule {
    // [...]
	public commands = [new CreateHelloCommand(this.stores, this.events)];
    // [...]
}
----

== Command class & skeleton

The command `lisk generate:command` already created the class `CreateHelloCommand` which contains skeletons for the most important components of the command.

The command class always extends from the `BaseCommand`, which is imported from the `lisk-sdk` package.

However, this command is not performing any functions yet.
To change this, we implement the methods of the command in the following chapters.

Open the command skeleton in `create_hello_command.ts`:

.src/app/modules/hello/commands/create_hello_command.ts
[source,typescript]
----
import {
    BaseCommand,
    CommandVerifyContext,
    CommandExecuteContext,
	VerificationResult,
	VerifyStatus,
} from 'lisk-sdk';

interface Params {
}

export class CreateHelloCommand extends BaseCommand {
	public schema = {
		$id: 'CreateHelloCommand',
		type: 'object',
		properties: {},
	};

	// eslint-disable-next-line @typescript-eslint/require-await
	public async verify(_context: CommandVerifyContext<Params>): Promise<VerificationResult> {
		return { status: VerifyStatus.OK };
	}

	public async execute(_context: CommandExecuteContext<Params>): Promise<void> {
	}
}
----

== Command params & schema

The command parameters are data that is provided by the transaction, that is required by the command to execute its' business logic.
The parameters interface and schema define the data type, order of the command.

The command schema can also define additional properties like min and max length of a parameter.

For creating a Hello message, define the parameters like so:

[source,typescript]
----
interface Params {
	message: string;
}
----

The only property needed by the module is the `message` that the sender posted.

For the corresponding schema, create a new file `schema.ts` in the root folder of the Hello module.

This file will be used to store all schemas that the module requires, for a better overview.

.schema.ts
[source,typescript]
----
export const createHelloSchema = {
	$id: 'hello/createHello-params',
	title: 'CreateHelloCommand transaction parameter for the Hello module',
	type: 'object',
	required: ['message'],
	properties: {
		message: {
			dataType: 'string',
			fieldNumber: 1,
			minLength: 3,
			maxLength: 256,
		},
	},
};
----

Note that we add two additional properties to the schema: {url_json_schema_length}[minLength & maxLength].
These properties define the minimum and maximum length of the message, according to the *JSON schema*.

By setting these properties already in the schema, we don't need to validate these properties later in the <<command-verification>>.
Please check the {url_json_schema}[JSON schema reference^] for information about other available keywords.

Now, import the schema to the Hello module and use it for the `schema` attribute of the module.:

[source,typescript]
----
import { createHelloSchema } from '../schema';
// [...]
export class CreateHelloCommand extends BaseCommand {
    public schema = createHelloSchema;
    // [...]
}
----

== Getting the module config

Next, we need to get the blacklist of words from the xref:{url_guides_module_config}[module config], because it is required in the next step during the <<command-verification>>.
Also, we want to update the minimum and maximum message length of the command schema with the values from the module configuration.

To do this, create a new method `init()` in the command, that can be called int he `init()` function of the module, after the module received the values from the config:

.hello/commands/create_hello_command.ts
[source,typescript]
----
// [...]
export class CreateHelloCommand extends BaseCommand {
    public schema = createHelloSchema;
	private _blacklist!: string[];

    public async init(blacklist: string[], maxLength: number, minLength: number): Promise<void> {
		this._blacklist = blacklist;
		this.schema.properties.message.maxLength = maxLength;
		this.schema.properties.message.minLength = minLength;
	}
    // [...]
}
----

To store the blacklisted words form the module config in the command, create a new private command attribute `_blacklist`.
Inside the method, assign the blacklist defined in the module config to `this._blacklist`, and also update the command schema with the minimum and maximum message length values defined in the config.

Then, call the method at the bottom of the `init()` function of the module and use the respective config values as parameters:

.hello/module.ts
[source,typescript]
----
// [...]
export class HelloModule extends BaseModule {
    // [...]
    // eslint-disable-next-line @typescript-eslint/require-await
    public async init(blacklist: string[]): Promise<void> {
        // [...]
        this.commands[0].init(config.blacklist,config.maxMessageLength,config.minMessageLength).then(res => {
            console.log("Result: ", res);
        }).catch(err => {
            console.log("Error: ", err);
        });
    }
    // [...]
}
----

Now, the `blacklist`, `minMessageLength` and `maxMessageLength`, which are defined in the config, are available in the command.

== Command verification

The command is always verified, before it is executed by the node like defined in the <<command-execution>>.
The verification of the command is defined in the `verify()` method of the command.

There `CreateHello` command expects only one single parameter in the transaction, and this is the Hello message.
Therefore, only the message needs to be verified here.

The following points should be validated:

. the message should not be shorter than the minimum message length defined in the command schema.
. the message should not be longer than the maximum message length defined in the command schema.
. the message should not contain any of the words defined in the blacklist of module config.

We don't need to validate point 1. and 2. in the `verify()` method, because it is already validated by the schema.

Point 3. however, the blacklisted words, cannot be checked with the schema.
So let's implement the `verify()` method to filter the message for words in the blacklist, and throw an error if any word is found.

.hello/commands/create_hello_command.ts
[source,typescript]
----
// [...]
export class CreateHelloCommand extends BaseCommand {
    public schema = createHelloSchema;
    private _blacklist!: string[];
    // [...]
    // eslint-disable-next-line @typescript-eslint/require-await
    public async verify(context: CommandVerifyContext<Params>): Promise<VerificationResult> {
        let validation: VerificationResult;
        const wordList = context.params.message.split(" ");
        const found = this._blacklist.filter(value => wordList.includes(value));
        if (found.length > 0) {
            validation = {
                status: VerifyStatus.FAIL,
                error: new Error(
                    `Illegal word in hello message: ${  found.toString()}`
                )
            };
        } else {
            validation = {
                status: VerifyStatus.OK
            };
        }
        context.logger.info(validation,"validation");
        return validation;
    }
    // [...]
}
----

The `context` of the `verify(context)` method contains the parameters of the command to be verified.
So first, access the `message` parameter through `context.params.message` and split the different words of the message by space, and save the resulting words in a word list.
Now, filter the blacklisted words, and store any word which is also present in the message word list in a new list called `found`.

Next, check the length of the `found` list. If it is greater than 0, it means, the message contains at least one word that is also included in the blacklist.
In that case, set the status to `VerifyStatus.FAIL` and include a descriptive error message under the `error` property as well.

If no blacklisted words are found, set the status to `VerifyStatus.OK`.

== Command execution

The `execute()` function is the place in the command where the state changes on the blockchain are made.

A command will only be executed, if the <<command-verification>> was successful.

The purpose of this command is to save a Hello message for the corresponding sender account.
Also, we need to increment the Hello counter by one, each time a command is executed.

Following this, the general business logic of the `execute()` method looks like this:

. Get account data of the sender of the CreateHello transaction.
. Get message and counter stores, that we created in the example in xref:{url_guides_module_stores}[].
. Save the Hello message to the message store, using the senderAddress as key, and the message as value
. Get the Hello counter from the counter store.
. Increment the Hello counter +1.
. Save the Hello counter to the counter store.

The corresponding code is shown below:

.hello/commands/create_hello_command.ts
[source,typescript]
----
// [...]
export class CreateHelloCommand extends BaseCommand {
    public schema = createHelloSchema;
    private _blacklist!: string[];
    // [...]
    public async execute(context: CommandExecuteContext<Params>): Promise<void> {
		// 1. Get account data of the sender of the CreateHello transaction.
		const {senderAddress} = context.transaction;
        // 2. Get message and counter stores.
		const messageSubstore = this.stores.get(MessageStore);
		const counterSubstore = this.stores.get(CounterStore);

		// 3. Save the Hello message to the message store, using the senderAddress as key, and the message as value.
		await messageSubstore.set(context, senderAddress, {
			message: context.params.message,
		});

		// 4. Get the Hello counter from the counter store.
		const helloBuffer = Buffer.from('hello','utf8');
		let helloCounter: CounterStoreData;
		try {
			helloCounter = await counterSubstore.get(context, helloBuffer);
		} catch (error) {
			helloCounter = {
				counter: 0,
			}
		}
		// 5. Increment the Hello counter +1.
		helloCounter.counter+=1;

		// 6. Save the Hello counter to the counter store.
		await counterSubstore.set(context, helloBuffer, helloCounter);
	}
}
----

== Using the new command