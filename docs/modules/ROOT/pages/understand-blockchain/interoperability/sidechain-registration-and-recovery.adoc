= Sidechain Registration & Recovery
Chris Braithwaite <christopher.braithwaite@lightcurve.io> Mona Bärenfänger <mona@lightcurve.io>
:description: How to register, terminate, and recover a sidechain.
:toc:
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images

:url_ccm: understand-blockchain/interoperability/communication.adoc
:url_ccu: understand-blockchain/interoperability/communication.adoc#-relaying-ccms-in-a-ccu
:url_ccm1: understand-blockchain/interoperability/communication.adoc#inducing_state_changes_across_chains_with_ccms
:url_bls: pages/glossary.adoc#bls
:url_bft_weights: pages/glossary.adoc#bft
:url_outbox_rootwitness: understand-blockchain/interoperability/communication.adoc

//:url_how_blockchain_works: intro/how-blockchain-works.adoc
//:url_transactions: understand-blockchain/lisk-protocol/transactions.adoc

== Overview - What is a Sidechain?

A sidechain is actually a separate blockchain that is attached to its mainchain using a two-way peg.
Sidechains are aligned in parallel with the main blockchain.
Sidechains can facilitate moving digital assets from their origin, namely the original blockchain to a separate blockchain which is known as a sidechain.
Furthermore, it is possible to move these assets back to the original blockchain if necessary, resulting in being able to securely interchange data and assets.
Simply put, a sidechain will allow nodes containing assets or data from the parent blockchain to be securely used in a separate blockchain (the sidechain), and hence, these assets and data can then be transferred back to the original blockchain.
In turn, the advent of sidechains will further increase the performance of the parent blockchain by taking some of the workload, and furthermore this increases the level of security as all transactions that are executed, are secured by the participants (generators/forgers), of the mainchain.

image:understand-blockchain/interop/sidechain.png[, align="center" ,500]

== Sidechains in Lisk

Within the Lisk network, the sidechain technique deployed collects a series of xref:{url_ccm}[cross-chain messages], (CCM) before to executing a transaction.
After these messages reach the receiving platform, they can then be verified and added to the block.

The xref:{url_ccu}[cross-chain update], (CCU) transactions can be considered as the carriers of the information transmitted between different chains.
By posting a cross-chain update, the receiving chain receives the information required about the advancement of the sending chain.
This transaction can also include cross-chain messages, as described below, and thus serves as an envelope for messages from one chain to another.

The cross-chain messages are responsible for verifying the state transition which ensures that the information is valid, and in turn allows for the simple validation of the state of the chain as well as the acceptance into a separate network.
The sidechains function by the way of using certificates to communicate between chains.
Before a transaction can be performed, it is necessary to receive updates from several blocks first, which are then collected and sent to the receiving chain.
This is where cross chain updates (CCUs) are used, as they contain the cross chain messages (CCMs), a certificate, and the necessary information regarding the current validator set of the sending chain.

The system functions whereby the CCUs are then validated in conjunction with the most recent message from the receiving chain.
Hence, this enables the transfer of data and assets to be administered via these messages.

These CCUs are then validated by the receiving chain in accordance with the most recent message, therefore confirming that the afore-mentioned messages were sent.
Further more in-depth information regarding the CCUs and CCMs can be found here on the xref:{url_ccm}[Cross-chain communication page].

== Life Cycle of a Sidechain

The life cycle of a sidechain can be broken down into 3 parts, corresponding to the following 3 values of the account status property: ''registered'', ''active'', and ''terminated''.

Firstly, a sidechain registers on the mainchain with a *sidechain registration command*.
This command creates the sidechain account on the mainchain.
Specifically it creates an entry in the chain data substore, with the initial status set to 'registered'; an entry in the channel data substore, with an empty inbox and outbox; coupled with an entry in the validators data substore, holding the initial sidechain validators set.
Thereafter, the mainchain account is similarly created on a sidechain with a *mainchain registration command*.

After a sidechain has been registered on the mainchain, it cannot receive any cross-chain message and does not need to follow the liveness rule, until the first sidechain CCU has been included in the mainchain.
At this point, the status of the sidechain account on the mainchain is updated to ''active'' and the liveness requirement rule is then enforced.
(The liveness rule requires active sidechains to prove their liveness once every 30 days, or the sidechain account is terminated).

Therefore, if no CCU is received within 30 days, the *chain account is terminated* and no more CCMs can be sent to or received from the sidechain.
A sidechain account can also be terminated if the sidechain posts a CCU containing a CCM with an invalid schema or with an invalid sending chain ID.
A message targeting a terminated chain is bounced on the mainchain instead of being forwarded.
When this happens, a "terminated sidechain" message is emitted by the mainchain, targeting the original sending chain.
When this message is processed, the chain is also terminated in the sending chain, blocking future messages.

When a chain is terminated, a "terminated state" account is created, storing the last certified state root of the terminated chain.
Then, users can recover tokens from the terminated sidechain with a state recovery command or proceed with the message recovery initialization command to kick-off the recovery of pending cross-chain messages.





== Sidechain Registration

// Explain why sidechain registration is needed referencing the introduction
// Explain why sidechain will be terminated and how/what can recover from the sidechain

Firstly sidechain registration is required to ultimately ensure interoperability with a separate chain can be achieved with the Lisk mainchain.
In effect this is managed by a registration command that creates a sidechain account within the Lisk mainchain.
This can be thought of as the initial step, being the creation and initiation of the communication channel that is required for two separate, different chains to interoperate and function seamlessly together.
To bring this to fruition a cross channel chain protocol needs to be established, which is the chain registration process defining the necessary protocol rules and data structures.
At this point it should be noted that there are two registration commands which are utilized dependent on whether it is the Lisk mainchain or the sidechain we are dealing with.
To explain this briefly, for the Lisk mainchain the sidechain registration command is used.
From the sidechain perspective, this is performed by the mainchain registration command, both of these are covered further in this section.




== How to register a sidechain

As mentioned in the previous paragraph to enable a sidechain to operate, it first has to be registered in the Lisk mainchain via a sidechain registration command.
This requires that the sidechain registration command is processed, which will then result in the sidechain account status being set to registered.
However, at this point the cross-channel is not active, so it is not possible for any cross-chain messages (CCMs) to be sent yet.

For the processing of this command, it signifies that as sidechain account in the mainchain state exists, and is associated with a name and a unique network identifier.
Therefore, each new sidechain occupies a certain namespace in the ecosystem.

==== Registration Message

The role of the registration message is to allow for a safe activation of the channel between the sending and receiving chains.
It guarantees that when the CCU activating the channel is executed, a registration transaction has been included on the partner chain.
When a sidechain is registered on the mainchain, as previously mentioned, an ecosystem wide chain ID and name are assigned to this chain.
The chain name, network ID, and the token used for the message fees are included in a registration message that is appended to the sidechain outbox.
When the first cross-chain update containing messages is sent to the sidechain, the equality between the properties in the registration message and the ones in the interoperability store is verified.


==== Sidechain Registration Process

Firstly, for a sidechain to be interoperable, it has to be registered in the Lisk mainchain via a <<Sidechain Registration Command>>.
A transaction with this command can be sent by any user account in the Lisk Mainchain that possesses adequate funds to pay the required fee.
The processing of this command signifies the creation of a sidechain account in the mainchain state that is associated with a unique network identifier and a name.
Therefore, each new sidechain occupies a certain namespace in the ecosystem.
Additionally, every newly registered sidechain can increase the size of every cross-chain update command, (CCU) posted on the mainchain (due to the increasing size of the xref:{url_outbox_rootwitness}[outboxRootWitness] property of the command).
For these two reasons, the minimum fee for this command has an added constant similar to the extra fee in a *delegate registration command*.
The value of this extra registration fee is `REGISTRATION_FEE` is LSK.

Once the sidechain registration command is processed, the sidechain account status is set to registered.
In this state, the cross-chain channel is still not active, so the users on the mainchain or other chains cannot send xref:{url_ccm1}[cross-chain messages] (CCMs) to this sidechain yet. Moreover, the *liveness condition* to maintain the channel is not enforced, this means that there is no specific time requirement for a sidechain to be activated on the mainchain, it can stay in the registered status for any period of time.
When a first valid cross-chain update command from this sidechain is processed, the sidechain status is changed to active, making it active in the ecosystem. Now it is possible to send CCMs to the sidechain and the liveness condition is enforced.

=== Sidechain Structure on the Mainchain

As discussed, once a new sidechain is registered on the mainchain by using the registration command, this results in a sidechain account being created in the Lisk mainchain state.
//Therefore, this implies that the corresponding key-value entries for the sidechain are added to the interoperability module store as shown below in Figure 1.
// (LIP 0045 find info on the properties of the interoperability module store to refer to this...)

The values of these entries are initialized, and the `name`, `networkID`, and `initValidators`, properties are computed from the sidechain registration command.

This sidechain registration command assigns a unique integer as the chain ID that identifies the sidechain in the ecosystem.
Furthermore, new data structures are inserted for the sidechain in the Lisk mainchain state.
This results in a new entry being created in the five different substores of the interoperability module store listed below, and can also be seen in the diagram in figure 1.

The following substores are used:
*outbox root substore*, *chain data substore*, *channel data substore*, *chain validators substore*, and *registered names*.
//This chain ID integer is also part of the key of the interoperability store entries for the registered sidechain as shown below in Figure 1.
image:understand-blockchain/interop/interoperability-module-store.png[ align="center" ,800]

Figure 1: A summary of the Interoperability module store:
Each box represents a substore, where we indicate the `storeKey --> storeValue relation`.
For the Lisk mainchain, the 'own chain' substore exists by default in the state whereas there is one entry per registered sidechain for five other substores (outbox root, chain data, channel data, chain validators, registered names), created by a sidechain registration command.
For sidechains, the 'own chain' and one entry for the mainchain account for four other substores (outbox root, chain data, channel data, and chain validators) are created by the mainchain registration command.

==== Sidechain Registration Command

The sidechain registration command is used to register a sidechain on the Lisk mainchain.
Once this command is processed, a new account for the sidechain is created in the mainchain state under the interoperability store.
The account is initialized with an empty inbox and outbox, while the sidechain name and the initial validators set are given in the command parameters.
The network ID is calculated from the address of the command sender and the genesis block ID, also given in the command parameters.

In order to connect a new sidechain into the ecosystem, the sidechain registration command contains the following parameters:

* `name` -  The name property sets the name of the sidechain as a string of characters, and has to be unique within the Lisk ecosystem, and contain only characters from the set *a-z0-9!@$&_.*

* `initValidators`: This property defines the set of eligible xref:{url_bls}[BLS public keys] with their respective xref:{url_bft_weights}[BFT weights] required to sign the first certificate from the sidechain.

* `certificateThreshold`: An integer setting the minimum signatures weight required for the first sidechain certificate to be valid.


* `sidechainRegistrationFee` :The sidechainRegistrationFee property accounts for the extra fee required to register the sidechain. It should be set to the value of the `REGISTRATION_FEE` constant.


** `Chain ID`: The Chain ID is responsible for uniquely identifying a chain in the Lisk ecosystem .
Just as addresses are used for identification for the user accounts, the chain ID has a similar purpose.
When processing the sidechain registration command, the chain ID for a sidechain is deterministically computed.
Specifically, the chain ID of a new sidechain is assigned as an incremental integer similar to transaction nonces.
The format of chain IDs aims to provide an efficient and compact way to uniquely identify chains in the ecosystem.
Furthermore, an additional advantage, is that it is easy to remember the integer assigned as the chain ID for a users favorite blockchain application.
The chain ID is a 4-byte constant set in the chain configuration.
Chain IDs serve the following two purposes:

. They are prepended to the input of the signing function of every transaction, block, or message of the chain to avoid transaction replays between different chains in the ecosystem.

. dd

ccccc
ccccccccccc
The command ID of this transaction is `COMMAND_ID_SIDECHAIN_REG`.

This command has an additional fee, whereby the REGISTRATION_FEE is a constant in the protocol.
[source,js]
----
extra fee = REGISTRATION_FEE
----

* Parameters

[source,js]
----
sidechainRegParams = {
  "type":"object",
  "properties":{
     "name":{
        "dataType":"string",
        "fieldNumber":1
     },
     "genesisBlockID":{
        "dataType":"bytes",
        "fieldNumber":2
     },
     "initValidators":{
        "type":"object",
        "properties":{
           "keys":{
              "type":"array",
              "items":{
                 "dataType":"bytes"
              },
              "fieldNumber":1
           },
           "weights":{
              "type":"array",
              "items":{
                 "dataType":"uint64"
              },
              "fieldNumber":2
           },
           "certificateThreshold":{
              "dataType":"uint64",
              "fieldNumber":3
           },
           "required":[
              "keys",
              "weights",
              "certificateThreshold"
           ],
           "fieldNumber":3
        }
     }
  },
  "required":[
     "name",
     "genesisBlockID",
     "initValidators"
  ]
}


----

==== Sidechain Network Identifier

The network identifier, or network ID, is a byte sequence unique to a chain that has to be prepended to the input of the signing function of every transaction, block, or message of the chain.
It is necessary to avoid transaction replays between different chains in the ecosystem.

In the Lisk ecosystem, the network ID for a sidechain is computed as the hash digest of the sidechain genesis block ID given in a transaction with the registration command and the address of the account sending this transaction.
This is beneficial, as sidechain developers can pre-compute the network ID of their sidechain as soon as they set the genesis block and an account to send the transaction on the mainchain.
It is then possible to start the sidechain at this point without being registered on the mainchain.
In addition, the network ID is known to the mainchain as soon as the sidechain is registered, therefore it can validate cross-chain update commands coming from the sidechain without any further context.


dd


== Sidechain termination

wwwww

=== Sidechain Terminated Message

The role of the sidechain terminated message is to inform sidechains that another sidechain has been terminated on the mainchain and is unable to receive messages. The message contains the ID of the terminated chain as well as the last certified state root of the terminated sidechain (as certified on the mainchain). This value is used for the creation of the terminated state account (on the sidechain receiving the CCM), allowing state recoveries.
This message allows to inform sidechains about other terminated sidechains efficiently. Indeed, this message will automatically trigger the creation of the terminated sidechain account as soon as the first message is unable to be delivered. This also prevents further messages to be sent to already terminated sidechains.


== How to recover information from a sidechain
Explain steps to recover information from sidechain


=== Mainchain registration on a sidechain

ddd (use section fom lip 043)

=== Mainchain Registration Command
The mainchain registration command is used to register the Lisk mainchain on a sidechain.
When this command is processed, a new account for the mainchain is created in the sidechain state under the <<interoperability store>>.
The account is initialized with an empty inbox and outbox, while the initial validators set is given in the command parameters.
The name and network ID of the mainchain are global protocol constants in the whole ecosystem.

This command also initializes another data structure in the interoperability store, containing certain information about the sidechain.
In particular, it sets the sidechain name and chain ID to the ones that have been previously registered on the mainchain via the <<Sidechain Registration Command>>.
//To do create entry in glossary for nteroperability store and add in link

Once the sidechain has been registered on the mainchain, a similar registration process should happen in the sidechain before the interoperable channel is opened between the two chains.
This is done by submitting a transaction with the mainchain registration command in the sidechain, which implies the creation of a mainchain account in the sidechain state associated with the Lisk mainchain.
The mainchain account possesses a similar structure as depicted in the chain interoperability store diagram above in figure 1.

* `mainchainValidators`

xxxx

* `name`

xxx

* `ownChainID`

xx

* `ownName`

xxx

// etc from lip 43
* Interoperability Constants

[cols="2,1,2,4"]
|===
|Name|Type|Value|Description
|MODULE_ID_INTEROPERABILITY|uint32|64|ID of the interoperability module.
|MAINCHAIN_ID|bytes|1|Chain ID of the Lisk mainchain.
|MAINCHAIN_NAME|string|"lisk-mainchain"|Name of the Lisk mainchain.
//|MAINCHAIN_NETWORK_ID|bytes|TBD|Network identifier of the Lisk mainchain.
|===

* Interoperability Store

[cols="2,1,2,4"]
|===
|Name|Type|Value|Description
|STORE_PREFIX_OUTBOX_ROOT|bytes|0x0000|Store prefix of the outbox root substore.
|STORE_PREFIX_CHAIN_DATA|bytes|0x8000|Store prefix of the chain data substore.
|STORE_PREFIX_REGISTERED_NAMES|bytes|0xe000|Store prefix of the chain names substore.
|STORE_PREFIX_REGISTERED_NETWORK_IDS|bytes|0xf000|Store prefix of the chain network IDs substore.
|===

* Interoperability Command IDs

[cols="2,1,2,4"]
|===
|Name|Type|Value|Description
|COMMAND_ID_SIDECHAIN_REG|uint32|0|Command ID of sidechain registration command.
|COMMAND_ID_MAINCHAIN_REG|uint32|1|Command ID of mainchain registration command.
|CROSS_CHAIN_COMMAND_ID_REGISTRATION|uint32|0|Cross-chain command ID of chain registration CCM.
|===

* General Constants

[cols="2,1,2,4"]
|===
|Name|Type|Value|Description
|MIN_FEE_PER_BYTE|uint64|1000|Minimum fee per byte.
|REGISTRATION_FEE|uint64|1000000000|Fee to pay for a sidechain registration command.
|MAX_NUM_VALIDATORS|uint32|199|	Maximum number of validators in a sidechain.
|MAX_LENGTH_NAME|uint32|40|Maximum allowed name for a sidechain.
|TAG_CHAINREG_MESSAGE|bytes|ASCII encoded string “LSK_CHAIN_REGISTRATION_”|
|===





=== Posting Cross-chain Updates on Mainchain and on Sidechains//?
As the roles of both mainchain and sidechain are quite different, so are the transactions used to post cross-chain updates. The most notable differences are:

On the mainchain, all CCMs included in the inboxUpdate must have their sendingChainID equal to the chainID sending the cross-chain update.
On sidechains, all CCMs included in the inboxUpdate must have their receivingChainID equal to the chainID of the sidechain receiving the cross-chain update.
As the mainchain accepts CCMs with receivingChainID corresponding to another sidechain, the cross-chain update processing on the mainchain is responsible for the inclusion of those CCMs in the corresponding outbox.
These points guarantee that the CCMs are always forwarded to the correct chains and that the receiving chain can be confident that the chain specified in CCM.sendingChainID was truly the chain issuing the CCM.