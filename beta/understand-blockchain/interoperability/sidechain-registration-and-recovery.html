<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Sidechain Registration &amp; Recovery :: Lisk documentation</title>
    <link rel="canonical" href="https://liskhq.github.io/lisk-docs/beta/understand-blockchain/interoperability/sidechain-registration-and-recovery.html">
    <link rel="prev" href="communication.html">
    <link rel="next" href="../blocks-txs.html">
    <meta name="description" content="How to register, terminate, and recover a sidechain.">
    <meta name="generator" content="Antora 3.1.1">

  <link id="theme" rel="stylesheet" title="Default" href="../../../_/css/site.css">
  <link rel="stylesheet" title="Dark" href="../../../_/css/dark-site.css">

    <script>var uiRootPath = '../../../_'</script>
    <script src="../../../_/js/vendor/medium-zoom.js"></script>
    <script type="text/javascript" id="Cookiebot" src="https://consent.cookiebot.com/uc.js" data-cbid="e4db29b5-cd94-4bcf-87e4-04f4ca564240" data-blockingmode="manual"></script>

<link rel="icon" href="../../../_/img/favicon.png" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="top-logo">
        <a href="../../.." class="lisk-logo"></a>
        <a href="../../.." class="docs-logo"></a>
      </div>
      <!--<a class="navbar-item" href="https://liskhq.github.io/lisk-docs">Lisk documentation</a>-->
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">APIs</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="../../../api/lisk-node-http.html">Lisk node HTTP API</a>
            <a class="navbar-item" href="../../../api/lisk-node-rpc.html">Lisk node RPC API</a>
            <a class="navbar-item" href="../../../api/lisk-service-http.html">Lisk Service HTTP API</a>
            <a class="navbar-item" href="../../../api/lisk-service-rpc.html">Lisk Service RPC API</a>
            <a class="navbar-item" href="../../../api/lisk-service-pubsub.html">Lisk Service Pub/Sub API</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Explorers</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://lisk.observer/" target="_blank">Lisk Observer</a>
            <a class="navbar-item" href="https://liskscan.com/" target="_blank">LiskScan</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="../../../lisk-sdk/">Lisk SDK</a>
            <a class="navbar-item" href="../../../lisk-service/">Lisk Service</a>
            <a class="navbar-item" href="../../../lisk-core/">Lisk Core</a>
            <a class="navbar-item" href="https://lisk.com/wallet" target="_blank">Lisk Wallets</a>
          </div>
        </div>
        <button onclick="switch_style('toggle')" id="theme-toggle" class="theme-toggle navbar-item"></button>
        <!-- <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div> -->
      </div>
    </div>
  </nav>
</header>
<div class="toolbar" role="navigation">
  <button class="nav-toggle"></button>
  <div class="components-versions">
      <div class="page-components">
    <button class="component-menu-toggle" title="Show other documentations">Lisk Documentation</button>
    <div class="component-menu">
        <a class="component" href="../../../lisk-core/index.html">Lisk Core</a>
        <a class="component" href="../../../lisk-docs-manual/index.html">Lisk docs manual</a>
        <a class="component is-current" href="../../../index.html">Lisk Documentation</a>
        <a class="component" href="../../../lisk-sdk/index.html">Lisk SDK</a>
        <a class="component" href="../../../lisk-service/index.html">Lisk Service</a>
    </div>
  </div>
    <span></span>
    <div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">beta</button>
  <div class="version-menu">
    <a class="version is-missing" href="../../../index.html">default</a>
    <a class="version is-current" href="sidechain-registration-and-recovery.html">beta</a>
  </div>
</div>
  </div>
  <span></span>
  <span></span>
  <a href="../../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Lisk Documentation</a></li>
    <li><a href="../index.html">Understand Lisk Blockchain</a></li>
    <li><a href="index.html">Lisk Interoperability</a></li>
    <li><a href="sidechain-registration-and-recovery.html">Sidechain Registration &amp; Recovery</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/LiskHQ/lisk-docs/edit/development/docs/modules/ROOT/pages/understand-blockchain/interoperability/sidechain-registration-and-recovery.adoc"><img class="pencil">Edit this Page</a></div>
  </div>
<div class="body">
<div class="nav-container" data-component="ROOT" data-version="beta">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../index.html">Lisk Documentation</a></h3>
<ul class="nav-list">
  <li class="nav-item parent" data-depth="0">
<ul class="nav-list">
  <li class="nav-item parent" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../intro/what-is-blockchain.html">What is blockchain?</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../intro/how-blockchain-works.html">How blockchain works</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../intro/blockchain-scalability.html">Blockchain Scalability</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../intro/lisk-products.html">Lisk products</a>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="1">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="../index.html">Understand Lisk Blockchain</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../state-machine.html">State machine</a>
  </li>
  <li class="nav-item parent" data-depth="2">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="../consensus/index.html">Consensus protocols</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../consensus/dpos-poa.html">Block generator selection algorithms</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../consensus/bft.html">Lisk BFT</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../consensus/certificates.html">Lisk Certificates</a>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="2">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="index.html">Lisk Interoperability</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="communication.html">Cross-chain communication</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="sidechain-registration-and-recovery.html">Sidechain Registration &amp; Recovery</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../blocks-txs.html">Blocks and Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../sdk/modules-commands.html">Modules and Commands</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../sdk/plugins.html">Plugins</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../sdk/rpc.html">Communicating to a Lisk node via RPC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../sdk/codec-schema.html">Codec &amp; schema</a>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="1">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="../../build-blockchain/index.html">Build Blockchain</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../build-blockchain/create-blockchain-app.html">Creating a new sidechain application</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../build-blockchain/configuration.html">Sidechain client configuration</a>
  </li>
  <li class="nav-item parent" data-depth="2">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="../../build-blockchain/module/index.html">How to create a module</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/module/configuration.html">1. How to create a module configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/module/stores.html">2. How to create stores</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/module/command.html">3. How to create a command</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/module/endpoints-methods.html">4. How to create endpoints and methods</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/module/blockchain-event.html">5. How to create a blockchain event</a>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="2">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="../../build-blockchain/plugin/index.html">How to create a plugin</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/plugin/schema-types.html">1. Defining off-chain data structures</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/plugin/offchain-db.html">2. Setting up an Off-chain database</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/plugin/configuring-plugin.html">3. Configuring a Plugin</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/plugin/plugin-class.html">4. Updating the Plugin Class</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../build-blockchain/plugin/plugin-endpoints.html">5. Creating an endpoint &amp; Testing the plugin</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../build-blockchain/create-genesis-block.html">How to create a new genesis block</a>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="1">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="../../run-blockchain/index.html">Run Blockchain</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../run-blockchain/forging.html">Enabling forging</a>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="1">
    <button class="nav-item-toggle"></button>
        <span>
    <a class="nav-link" href="../../integrate-blockchain/index.html">Integrate Blockchain</a>
        </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../integrate-blockchain/connecting-endpoints.html">Connecting to endpoints</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="0">
<ul class="nav-list">
  <li class="nav-item parent" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">APIs</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../api/lisk-node-rpc.html">RPC API for Lisk nodes</a>
  </li>
</ul>
  </li>
  <li class="nav-item parent" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Products</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../lisk-sdk/index.html">Lisk SDK</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../lisk-core/index.html">Lisk Core</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../bug-bounty-program.html">Lisk Bug Bounty Program</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Lisk Documentation</span>
    <span class="version">beta</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../lisk-core/index.html">Lisk Core</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../lisk-core/index.html">3.0.4 (latest)</a>
        </li>
        <li class="version">
          <a href="../../../lisk-core/v4/index.html">4.0.0-beta.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../lisk-docs-manual/index.html">Lisk docs manual</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../lisk-docs-manual/index.html">0.1.0</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../../index.html">Lisk Documentation</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../index.html">default</a>
        </li>
        <li class="version is-current">
          <a href="../../index.html">beta</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../lisk-sdk/index.html">Lisk SDK</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../lisk-sdk/index.html">5.2.2 (latest)</a>
        </li>
        <li class="version">
          <a href="../../../lisk-sdk/v6/index.html">6.0.0 (beta)</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../lisk-service/index.html">Lisk Service</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../lisk-service/index.html">0.6.4 (latest)</a>
        </li>
        <li class="version">
          <a href="../../../lisk-service/v0.7/index.html">0.7.0 (beta)</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Sidechain Registration &amp; Recovery</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview-what-is-a-sidechain">Overview - What is a Sidechain?</a></li>
<li><a href="#sidechains-in-lisk">Sidechains in Lisk</a></li>
<li><a href="#life-cycle-of-a-sidechain">Life Cycle of a Sidechain</a></li>
<li><a href="#how-to-register-a-sidechain">How to register a sidechain</a>
<ul class="sectlevel2">
<li><a href="#sidechain-registration-process">Sidechain Registration Process</a></li>
<li><a href="#sidechain-registration-command">Sidechain Registration Command</a></li>
<li><a href="#mainchain-registration-on-a-sidechain">Mainchain Registration on a Sidechain</a></li>
<li><a href="#mainchain-registration-command">Mainchain Registration Command</a></li>
<li><a href="#sidechain-registration-transaction-commands">Sidechain Registration Transaction Commands</a></li>
<li><a href="#mainchain-registration-transaction-commands">Mainchain Registration Transaction Commands</a></li>
</ul>
</li>
<li><a href="#sidechain-termination">Sidechain termination</a>
<ul class="sectlevel2">
<li><a href="#termination-causes">Termination causes</a></li>
<li><a href="#sidechain-terminated-message">Sidechain Terminated Message</a></li>
</ul>
</li>
<li><a href="#how-to-recover-information-from-a-sidechain">How to recover information from a sidechain</a>
<ul class="sectlevel2">
<li><a href="#state-recovery-from-the-sidechain-root">State recovery from the Sidechain Root</a></li>
<li><a href="#message-recovery-command">Message Recovery Command</a></li>
</ul>
</li>
<li><a href="#recovery-process-workflow">Recovery Process Workflow</a>
<ul class="sectlevel2">
<li><a href="#recovery-from-the-terminated-chain-outbox">Recovery from the terminated chain outbox</a></li>
<li><a href="#mainchain">Mainchain</a></li>
<li><a href="#sidechain">Sidechain</a></li>
<li><a href="#recovery-process-summary-overview">Recovery Process Summary Overview</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="overview-what-is-a-sidechain"><a class="anchor" href="#overview-what-is-a-sidechain"></a>Overview - What is a Sidechain?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A sidechain is a separate blockchain registered on the mainchain, where the inclusion of a transaction in one of the blockchains can have an effect on the other blockchain.
These effects on the other blockchain can facilitate, for example, moving digital assets between the mainchain and the sidechain.
Having a mainchain and some sidechains in parallel results in a higher overall transaction throughput.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sidechains-in-lisk"><a class="anchor" href="#sidechains-in-lisk"></a>Sidechains in Lisk</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Within the Lisk network, a transaction that can have an effect on another blockchain is called a <a href="communication.html" class="xref page">cross-chain transaction</a>.
Such a transaction emits one or more <a href="communication.html#sending-cross-chain-transactions-to-generate-ccms" class="xref page">cross-chain messages</a> from the sending chain.
The emitted cross-chain messages on the sending chain are then collected by a relayer and transferred to the receiving chain via a so-called <a href="communication.html#relaying-ccms-in-a-ccu" class="xref page">cross-chain updated transaction</a> (CCU).
When the CCU is included in the receiving chain, the cross-chain messages induce some state changes.
This is how a transaction from a sidechain can have an effect on the mainchain.</p>
</div>
<div class="paragraph">
<p>The main purpose of deploying sidechains in the Lisk ecosystem is to increase scalability. Therefore, the more sidechains that exist in the ecosystem mean the more transactions can be processed per second.
It is intended that each sidechain serves one application, which means, for instance, there could be a sidechain dedicated to a decentralized exchange application.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="life-cycle-of-a-sidechain"><a class="anchor" href="#life-cycle-of-a-sidechain"></a>Life Cycle of a Sidechain</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The life cycle of a sidechain can be broken down into 3 parts, corresponding to the following 3 values of the account status property: ''registered'', ''active'', and ''terminated''.</p>
</div>
<div class="paragraph">
<p>Firstly, a sidechain registers on the mainchain with a <strong>sidechain registration command</strong>.
This command creates the sidechain account on the mainchain with the initial status set to <code>registered</code>.
Thereafter, the mainchain account is similarly created on a sidechain with a <strong>mainchain registration command</strong>.</p>
</div>
<div class="paragraph">
<p>After a sidechain has been registered on the mainchain, it cannot receive any cross-chain message and does not need to follow the liveness rule, until the first sidechain CCU containing some cross-chain messages has been included in the mainchain.
The liveness rule requires active sidechains to prove their liveness once every 30 days by including a CCU in the mainchain, or the sidechain account is terminated.
At this point, the status of the sidechain account on the mainchain is updated to ''active'' and the liveness requirement rule is then enforced.</p>
</div>
<div class="paragraph">
<p>Therefore, if no CCU is received within 30 days, the <strong>chain account is terminated</strong> and no more CCMs can be sent to or received from the sidechain.
A sidechain account can also be terminated if the sidechain posts a CCU containing a CCM with an invalid schema or with an invalid sending <code>chainID</code>.
A message targeting a terminated chain is bounced back to the mainchain instead of being forwarded.
When this happens, a "terminated sidechain" message is emitted by the mainchain, targeting the original sending chain.
When this message is processed, the chain is also terminated in the sending chain, blocking future messages.</p>
</div>
<div class="paragraph">
<p>When a chain is terminated, a "terminated state" account is created, storing the last certified state root of the terminated chain.
Then, users can recover tokens from the terminated sidechain with a <a href="#state-recovery-command">State Recovery Command</a> or proceed with the <a href="#message-recovery-initialization-command">Message Recovery Initialization Command</a> to kick off the recovery of pending cross-chain messages.
The sidechain termination and recovery process is covered later on this page.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-to-register-a-sidechain"><a class="anchor" href="#how-to-register-a-sidechain"></a>How to register a sidechain</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As mentioned in the previous paragraph to enable a sidechain to operate, it first has to be registered in the Lisk mainchain via a sidechain registration command.
This requires that the sidechain registration command is processed, which will then result in the sidechain account status being set to registered.
However, at this point, the channel is not active, so no cross-chain messages (CCMs) can be sent yet.
Hence, a sidechain account that is already associated with a name and a unique chain ID, exists in the mainchain state.
Therefore, each new sidechain occupies a certain namespace in the ecosystem.</p>
</div>
<div class="sect2">
<h3 id="sidechain-registration-process"><a class="anchor" href="#sidechain-registration-process"></a>Sidechain Registration Process</h3>
<div class="paragraph">
<p>A transaction with a <a href="#sidechain-registration-command">Sidechain Registration Command</a> can be sent by any user account in the Lisk Mainchain that possesses adequate funds to pay the required fee.
As described in the <a href="#life-cycle-of-a-sidechain">Life Cycle of a Sidechain</a> section above, once the Sidechains registration process has been completed, it does not need to be activated on the mainchain, and will remain inactive until the first valid CCU containing some cross-chain messages has been sent and processed.
At this point, it will become active in the ecosystem.</p>
</div>
<div class="sect3">
<h4 id="registration-message"><a class="anchor" href="#registration-message"></a>Registration Message</h4>
<div class="paragraph">
<p>The role of the registration message is to allow for a safe activation of the channel between the sending and receiving chains.
It guarantees that when the CCU activating the channel is executed, a registration transaction has been included on the partner chain.
When a sidechain is registered on the mainchain, as previously mentioned, an ecosystem-wide chain ID and name are assigned to this chain.
The chain name, network ID, and the token used for the message fees are included in a registration message that is appended to the sidechain outbox.
When the first cross-chain update containing messages is sent to the sidechain, the equality between the properties in the registration message and the ones in the interoperability store is verified.</p>
</div>
</div>
<div class="sect3">
<h4 id="sidechain-structure-on-the-mainchain"><a class="anchor" href="#sidechain-structure-on-the-mainchain"></a>Sidechain Structure on the Mainchain</h4>
<div class="paragraph">
<p>As discussed, once a new sidechain is registered on the mainchain by using the registration command, this results in a sidechain account being created in the Lisk mainchain state.</p>
</div>
<div class="paragraph">
<p>The values of the account entries are initialized, and the <code>name</code>, <code>chainID</code>, and <code>initValidators</code>, properties are computed from the sidechain registration command.</p>
</div>
<div class="paragraph">
<p>This <a href="#sidechain-registration-command">Sidechain Registration Command</a> assigns a unique bytes value as the chain ID that identifies the sidechain in the ecosystem.
Furthermore, new data structures are inserted for the sidechain in the Lisk mainchain state.
This results in a new entry being created in the five different substores of the interoperability module store listed below, and can also be seen in the diagram below in figure 2.</p>
</div>
<div class="paragraph">
<p>The following substores are used:
<strong>outbox root substore</strong>, <strong>chain data substore</strong>, <strong>channel data substore</strong>, <strong>chain validators substore</strong>, and <strong>registered names</strong>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../_images/understand-blockchain/interop/interop-store_v1.png" alt="interop store v1" width="800">
</div>
<div class="title">Figure 1. The Interoperability module store.</div>
</div>
<div class="paragraph">
<p>Each box represents a substore, where we indicate the <code>storeKey &#8594; storeValue relation</code>.
For the Lisk mainchain, the 'own chain' substore exists by default in the state whereas there is one entry per registered sidechain for five other substores (outbox root, chain data, channel data, chain validators, registered names), created by a sidechain registration command.
For sidechains, the 'own chain' and one entry for the mainchain account for four other substores (outbox root, chain data, channel data, and chain validators) are created by the <a href="#mainchain-registration-command">Mainchain Registration Command</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sidechain-registration-command"><a class="anchor" href="#sidechain-registration-command"></a>Sidechain Registration Command</h3>
<div class="paragraph">
<p>The sidechain registration command is used to register a sidechain on the Lisk mainchain.
Once this command is processed, a new account for the sidechain is created in the mainchain state under the interoperability store.
The account is initialized with an empty inbox and outbox, while the sidechain name, chain ID, and the initial validators set are given in the command parameters.</p>
</div>
<div class="paragraph">
<p>In order to connect a new sidechain to the ecosystem, the sidechain registration command contains the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>name</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>name</code> property sets the name of the sidechain as a string of characters. It has to be unique within the Lisk ecosystem, and should contain only characters from the set <strong>a-z0-9!@$&amp;_.</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>initValidators</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>initValidators</code> property defines the set of eligible BLS public keys with their respective BFT weights required to sign the first certificate from the sidechain.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>certificateThreshold</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>certificateThreshold</code> property is an integer setting the minimum signatures weight required for the first sidechain certificate to be valid.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>sidechainRegistrationFee</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>sidechainRegistrationFee</code> property accounts for the extra fee required to register the sidechain. It should be set to the value of the <code>REGISTRATION_FEE</code> constant.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>chainID</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>chainID</code> property is responsible for uniquely identifying a chain in the Lisk ecosystem.
Just as addresses are used for the identification of user accounts, the chain ID has a similar purpose.
When processing the sidechain registration command, the chain ID for a sidechain is given as a parameter in the registration transaction.
The <code>chainID</code> is a 4-byte (8-character) hexadecimal string, which is set in the chain&#8217;s configuration.</p>
</div>
<div class="paragraph">
<p>The <code>chainID</code> properties serve the following two purposes:</p>
</div>
<div class="paragraph">
<p><strong>(1)</strong> The <code>chainID</code> properties are prepended to the input of the signing function of every transaction, block, or message of the chain to avoid transaction replays between different chains in the ecosystem.</p>
</div>
<div class="paragraph">
<p><strong>(2)</strong> The <code>chainID</code> properties uniquely identify a chain in the Lisk ecosystem.
Furthermore, the chain ID has to be stated in every cross-chain interaction.
For example, it has to be specified in the <code>receivingChainID</code> property of a CCM and in the <code>sendingChainID</code> property of a cross-chain update command.</p>
</div>
<div class="paragraph">
<p>In the sidechain registration command, the <code>chainID</code> property of the sidechain is given as a parameter.
In the case whereby the given value is already taken by another sidechain, the sidechain registration fails.
Therefore, the sidechain has to change the chain ID with a hardfork and resubmit the sidechain registration command with a new value.
The chain identifiers are of a value of 4 bytes, and dependent on the network on which the chain is running, the first byte must always be set to the correct value.</p>
</div>
<div class="paragraph">
<p>An example can be seen below in the following table depicting the chain-identifiers prefixes currently specified.
The first byte is set to  <code>CHAIN_ID_PREFIX_MAINNET</code> for chains running in the mainnet network and to <code>CHAIN_ID_PREFIX_TESTNET</code> for chains running in the testnet network.
The other 3 bytes must be uniquely chosen for the respective blockchain, hence, no other blockchain created with the Lisk SDK should use the same 3 bytes.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 44.4445%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CHAIN_ID_PREFIX_MAINNET</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chain-identifier prefix for mainnet blockchains.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CHAIN_ID_PREFIX_TESTNET</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chain-identifier prefix for testnet blockchains.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The chain ID is known to the mainchain as soon as the sidechain is registered, therefore it can validate cross-chain update commands coming from the sidechain without any further context.</p>
</div>
</div>
<div class="sect2">
<h3 id="mainchain-registration-on-a-sidechain"><a class="anchor" href="#mainchain-registration-on-a-sidechain"></a>Mainchain Registration on a Sidechain</h3>
<div class="paragraph">
<p>Once the sidechain has been registered on the mainchain, a similar registration process should happen in the sidechain before the interoperable channel is opened between the two chains.
This is performed by submitting a transaction with the mainchain registration command in the sidechain, which implies the creation of a mainchain account in the sidechain state associated with the Lisk mainchain, and other structures needed for interoperability.
This mainchain account has a similar structure as the one depicted in Figure 2 above.
By protocol, the chain ID of the mainchain is a constant equal to <code>0x00000000</code> in the ecosystem.</p>
</div>
<div class="paragraph">
<p>This registration process always has to occur after the sidechain registration on the mainchain, since the sidechain has no prior knowledge of its name and must be certain that the correct chain ID has been registered.
Similar to the sidechain registration case, the mainchain account status will not change to active until a valid cross-chain update command from the mainchain containing a valid registration <a href="communication.html#sending-cross-chain-transactions-to-generate-ccms" class="xref page">CCM</a> is processed.</p>
</div>
</div>
<div class="sect2">
<h3 id="mainchain-registration-command"><a class="anchor" href="#mainchain-registration-command"></a>Mainchain Registration Command</h3>
<div class="paragraph">
<p>The mainchain registration command is used to register the Lisk mainchain on a sidechain.
When this command is processed, a new account for the mainchain is created in the sidechain state under the interoperability store.</p>
</div>
<div class="paragraph">
<p>Certain parameters are set by the mainchain registration command in the sidechain that is related to the interoperability module. It also initializes the corresponding mainchain data structures.
This command requires the approval of the sidechain validators, as they have to agree on the content of this command and provide their signature accordingly.
Based on the individual signatures, an aggregate signature must be added to the transaction.
It is of key importance that the sidechain validators ensure that they are signing the registration command with the correct information, otherwise the sidechain interoperable functionality may be unusable.</p>
</div>
<div class="paragraph">
<p>The command has the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ownChainID</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The chain ID is set on the mainchain after processing the corresponding sidechain registration command.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ownName</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ownName</code> property sets the name of the sidechain in its own state according to the name given in the mainchain.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>mainchainValidators</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is similar to the <code>initValidators</code> property in the sidechain registration command, it defines the set of mainchain validators with their respective <a href="../../glossary.html#bft-weight" class="xref page">BFT weight</a> expected to sign the first certificate from the mainchain.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>signature</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>signature</code> property is an aggregate signature of the sidechain validators.
It ensures that the sidechain validators agree on registering the mainchain in the sidechain.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>aggregationBits</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>aggregationBits</code> property is a bit vector used to validate the aggregate signature.</p>
</div>
</div>
<div class="sect2">
<h3 id="sidechain-registration-transaction-commands"><a class="anchor" href="#sidechain-registration-transaction-commands"></a>Sidechain Registration Transaction Commands</h3>
<div class="paragraph">
<p>Firstly, the transactions executing the sidechain registration command and the required parameters, verification, and execution are listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>module = MODULE_NAME_INTEROPERABILITY</code></p>
</li>
<li>
<p><code>command = COMMAND_SIDECHAIN_REG</code></p>
</li>
</ul>
</div>
<details>
<summary class="title">Sidechain Registration Parameters</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">sidechainRegParams = {
    "type": "object",
    "required": [
        "name",
        "chainID",
        "initValidators",
        "certificateThreshold",
        "sidechainRegistrationFee"
    ],
    "properties": {
        "name": {
            "dataType": "string",
            "minLength": MIN_CHAIN_NAME_LENGTH,
            "maxLength": MAX_CHAIN_NAME_LENGTH,
            "fieldNumber": 1
        },
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 2
        },
        "initValidators": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "required": ["blsKey", "bftWeight"],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "length": BLS_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "certificateThreshold": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "sidechainRegistrationFee": {
            "type": "uint64",
            "fieldNumber": 5
        }
    }
}</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">Sidechain Verification Parameters</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def verify(trs: Transaction) -&gt; None:
    # The name property has to contain only characters from the set [a-z0-9!@$&amp;_.].
    if not re.match(r"^[a-z0-9!@$&amp;_.]+$", trs.params.name):
        raise Exception("Invalid name property. It should contain only characters from the set [a-z0-9!@$&amp;_.].")
    # The name property has to be unique with respect to the set of already registered sidechain names.
    if there exists an entry in the registered names substore with store key equal to trs.params.name.encode("utf-8"):
        raise Exception("Name already registered.")

    # Chain ID has to be unique with respect to the set of already registered sidechains.
    if there exists an entry in the chain data substore with store key equal to trs.params.chainID:
        raise Exception("Chain ID already registered.")

    # Check that the first byte of the chainID, indication the network, matches.
    if trs.params.chainID[0] != CHAIN_ID_MAINCHAIN[0]:
        raise Exception("Chain ID does not match the mainchain network.")
    # Chain ID cannot be the mainchain chain ID.
    if trs.params.chainID == CHAIN_ID_MAINCHAIN:
        raise Exception("Chain ID cannot be the mainchain chain ID.")
    # initValidators must have at least 1 element and at most MAX_NUM_VALIDATORS elements.
    if len(trs.params.initValidators) &lt; 1 or len(trs.params.initValidators) &gt; MAX_NUM_VALIDATORS:
        raise Exception(f"Invalid initValidators array. It must have at least 1 element and at most {MAX_NUM_VALIDATORS} elements.")

    validatorKeys = [validator.blsKey for validator in trs.params.initValidators]
    # All validator keys must be distinct.
    if len(validatorKeys) != len(set(validatorKeys)):
        raise Exception("Duplicate BLS keys.")

    # Validator keys must be in lexicographic order.
    if not all(validatorKeys[i] &lt; validatorKeys[i + 1] for i in range(len(validatorKeys) - 1)):
        raise Exception("Validator keys are not in lexicographic order.")

    totalWeight = 0
    for validator in trs.params.initValidators:
        # The bftWeight property of each element is a positive integer.
        if validator.bftWeight == 0:
            raise Exception("Invalid bftWeight property.")
        totalWeight += validator.bftWeight
    # Total BFT weight has to be less than or equal to MAX_UINT64.
    if totalWeight &gt; MAX_UINT64:
        raise Exception("Total BFT weight exceeds maximum value.")

    # The range of valid values of the certificateThreshold property is given by the total sum of the validators weights:
    # Minimum value: floor(1/3 * total BFT weight) + 1.
    # Maximum value = total BFT weight.
    if trs.params.certificateThreshold &lt; totalWeight//3 + 1:
        raise Exception("Certificate threshold is too small.")
    if trs.params.certificateThreshold &gt; totalWeight:
        raise Exception("Certificate threshold is too large.")

    # sidechainRegistrationFee must equal REGISTRATION_FEE.
    if trs.params.sidechainRegistrationFee != REGISTRATION_FEE:
        raise Exception("Invalid extra command fee.")
    # Sender must have enough balance to pay for extra command fee.
    senderAddress = sha256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    if Token.getAvailableBalance(senderAddress, TOKEN_ID_LSK_MAINCHAIN) &lt; REGISTRATION_FEE:
        raise Exception("Sender does not have enough balance.")</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">Sidechain Execution Parameters</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def execute(trs: Transaction) -&gt; None:
    senderAddress = sha256(trs.senderPublicKey)[:ADDRESS_LENGTH]

    # Create chain account.
    sidechainAccount = {
        "name": trs.params.name,
        "lastCertificate": {
            "height": 0,
            "timestamp": 0,
            "stateRoot": EMPTY_HASH,
            "validatorsHash": computeValidatorsHash(trs.params.initValidators, trs.params.certificateThreshold)
        },
        "status": CHAIN_STATUS_REGISTERED
    }

    chainID = trs.params.chainID
    create an entry in the chain data substore with
        storeKey = chainID,
        storeValue = encode(chainAccountSchema, sidechainAccount)

    # Create channel.
    sidechainChannel = {
        "inbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "outbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "partnerChainOutboxRoot": EMPTY_HASH,
        "messageFeeTokenID": TOKEN_ID_LSK_MAINCHAIN
    }
    create an entry in the channel data substore with
        storeKey = chainID
        storeValue = encode(channelSchema, sidechainChannel)

    # Create validators account.
    sidechainValidators = {
        "activeValidators": trs.params.initValidators,
        "certificateThreshold": trs.params.certificateThreshold
    }
    create an entry in the chain validators data substore with
        storeKey = chainID
        storeValue = encode(validatorsSchema, sidechainValidators)

    # Create outbox root entry.
    create an entry in the outbox root substore with
        storeKey = chainID
        storeValue = encode(outboxRootSchema, {"root": sidechainChannel.outbox.root})

    # Create registered names entry.
    create an entry in the registered names substore with
        storeKey = trs.params.name
        storeValue = encode(chainIDSchema, {"chainID": chainID})

    # Burn the registration fee.
    Token.burn(senderAddress, TOKEN_ID_LSK_MAINCHAIN, REGISTRATION_FEE)

    # Emit chain account updated event.
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CHAIN_ACCOUNT_UPDATED,
        data = sidechainAccount,
        topics = [chainID]
    )

    # Send registration CCM to the sidechain.
    registrationCCMParams = {
        "name": trs.params.name,
        "messageFeeTokenID": sidechainChannel.messageFeeTokenID
    }

    ccm = {
        "nonce": ownChainAccount.nonce,
        "module": MODULE_NAME_INTEROPERABILITY,
        "crossChainCommand": CROSS_CHAIN_COMMAND_REGISTRATION,
        "sendingChainID": ownChainAccount.chainID,
        "receivingChainID": chainID,
        "fee": 0,
        "status": CCM_STATUS_CODE_OK,
        "params": encode(registrationCCMParamsSchema, registrationCCMParams) # registrationCCMParamsSchema is defined in LIP0049
    }

    addToOutbox(chainID, ccm)
    ownChainAccount.nonce += 1

    # Emit CCM Sent Event.
    ccmID = sha256(encode(crossChainMessageSchema, ccm))
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CCM_SENT_SUCCESS,
        data = {"ccmID": ccmID},
        topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
    )</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect2">
<h3 id="mainchain-registration-transaction-commands"><a class="anchor" href="#mainchain-registration-transaction-commands"></a>Mainchain Registration Transaction Commands</h3>
<div class="paragraph">
<p>Secondly, the transactions executing the mainchain registration command and the required parameters, verification, and execution are listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>module = MODULE_NAME_INTEROPERABILITY</code></p>
</li>
<li>
<p><code>command = COMMAND_MAINCHAIN_REG</code></p>
</li>
</ul>
</div>
<details>
<summary class="title">Mainchain Registration Parameters</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">mainchainRegParams = {
    "type": "object",
    "required": [
        "ownChainID",
        "ownName",
        "mainchainValidators",
        "signature",
        "aggregationBits"
    ],
    "properties": {
        "ownChainID": {
            "dataType": "uint32",
            "fieldNumber": 1
        },
        "ownName": {
            "dataType": "string",
            "minLength": MIN_CHAIN_NAME_LENGTH,
            "maxLength": MAX_CHAIN_NAME_LENGTH,
            "fieldNumber": 2
        },
        "mainchainValidators": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "required": ["blsKey", "bftWeight"],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "length": BLS_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "signature": {
            "dataType": "bytes",
            "length": BLS_SIGNATURE_LENGTH,
            "fieldNumber": 4
        },
        "aggregationBits": {
            "dataType": "bytes",
            "fieldNumber": 5
        }
    }
}</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">Mainchain Verification Parameters</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def verify(trs: Transaction) -&gt; None:
# The ownChainID property has to match with the chain identifier.
chainID = chain identifier of the current chain
if trs.params.ownChainID != chainID:
raise Exception("Invalid ownChainID property.")

    # The ownName property has to contain only characters from the set [a-z0-9!@$&amp;_.].
    if not re.match(r"^[a-z0-9!@$&amp;_.]+$", trs.params.ownName):
        raise Exception("Invalid ownName property. It should contain only characters from the set [a-z0-9!@$&amp;_.].")

    # mainchainValidators must have exactly MAINCHAIN_NUMBER_ACTIVE_VALIDATORS elements.
    if len(trs.params.mainchainValidators) != MAINCHAIN_NUMBER_ACTIVE_VALIDATORS:
        raise Exception(f"Invalid mainchainValidators property. It must have exactly {MAINCHAIN_NUMBER_ACTIVE_VALIDATORS} elements.")

    validatorKeys = [validator.blsKey for validator in trs.params.mainchainValidators]
    # All validator keys must be distinct.
    if len(validatorKeys) != len(set(validatorKeys)):
        raise Exception("Duplicate BLS keys.")

    # Validator keys must be in lexicographic order.
    if not all(validatorKeys[i] &lt; validatorKeys[i + 1] for i in range(len(validatorKeys) - 1)):
        raise Exception("Validator keys are not in lexicographic order.")

    for validator in trs.params.initValidators:
        # The bftWeight property of each element is equal to 1.
        if validator.bftWeight != 1:
            raise Exception("Invalid bftWeight property.")</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">Mainchain Execution Parameters</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def execute(trs: Transaction) -&gt; None:
# Check signature property.
height = height of the block in which trs was included
sidechainValidators = validatorsModule.getCurrentValidators()
certificateThreshold = validatorsModule.getCertificateThreshold()
# Sort sidechainValidators by BLS key.
sidechainValidators.sort(key=lambda v: validatorsModule.getValidatorAccount(v.address).blsKey)
blsKeys = [validatorsModule.getValidatorAccount(v.address).blsKey for v in sidechainValidators]
bftWeights = [v.bftWeight for v in sidechainValidators]

    registrationSignatureMessageSchema = {
        "type": "object",
        "required": ["ownChainID", "ownName", "mainchainValidators"],
        "properties": {
            "ownChainID": {
                "dataType": "bytes",
                "length": CHAIN_ID_LENGTH,
                "fieldNumber": 1
            },
            "ownName": {
                "dataType": "string",
                "minLength": MIN_CHAIN_NAME_LENGTH,
                "maxLength": MAX_CHAIN_NAME_LENGTH,
                "fieldNumber": 2
            },
            "mainchainValidators": {
                "type": "array",
                "fieldNumber": 3,
                "items": {
                    "type": "object",
                    "required": ["blsKey", "bftWeight"],
                    "properties": {
                        "blsKey": {
                            "dataType": "bytes",
                            "length": BLS_PUBLIC_KEY_LENGTH,
                            "fieldNumber": 1
                        },
                        "bftWeight": {
                            "dataType": "uint64",
                            "fieldNumber": 2
                        }
                    }
                }
            }
        }
    }

    message = encode(registrationSignatureMessageSchema,
        {
        "ownChainID": trs.params.ownChainID,
        "ownName": trs.params.ownName,
        "mainchainValidators": trs.params.mainchainValidators
        }
    )

    # verifyWeightedAggSig is specified in LIP 0062.
    if verifyWeightedAggSig(blsKeys, MESSAGE_TAG_CHAIN_REG, trs.params.ownChainID, trs.params.aggregationBits, trs.params.signature, bftWeights, certificateThreshold, message) == False:
        emitPersistentEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_INVALID_REGISTRATION_SIGNATURE,
            data = {},
            topics = [trs.params.ownChainID]
        raise Exception("Invalid signature property.")

    # Create chain account.
    mainchainAccount = {
        "name": CHAIN_NAME_MAINCHAIN,
        "lastCertificate": {
            "height": 0,
            "timestamp": 0,
            "stateRoot": EMPTY_HASH,
            "validatorsHash": computeValidatorsHash(trs.params.mainchainValidators, THRESHOLD_MAINCHAIN)
        },
        "status": CHAIN_STATUS_REGISTERED
    }
    create an entry in the chain data substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(chainAccountSchema, mainchainAccount)

    # Create channel.
    mainchainChannel = {
        "inbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "outbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "partnerChainOutboxRoot": EMPTY_HASH,
        "messageFeeTokenID": TOKEN_ID_LSK_MAINCHAIN
    }
    create an entry in the channel data substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(channelSchema, mainchainChannel)

    # Create validators account.
    mainchainValidators = {
        "activeValidators": trs.params.mainchainValidators,
        "certificateThreshold": THRESHOLD_MAINCHAIN
    }
    create an entry in the chain validators data substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(validatorsSchema, mainchainValidators)

    # Create outbox root entry.
    create an entry in the outbox root substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(outboxRootSchema, {"root": mainchainChannel.outbox.root})

    # Create own chain account.
    ownChainAccount = {
        "name": trs.params.ownName,
        "chainID": trs.params.ownChainID,
        "nonce": 0
    }
    create an entry in the own chain data substore with
        storeKey = EMPTY_BYTES
        storeValue = encode(ownChainAccountSchema, ownChainAccount)

    # Emit chain account updated event.
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CHAIN_ACCOUNT_UPDATED,
        data = mainchainAccount,
        topics = [CHAIN_ID_MAINCHAIN]
    )

    # Send registration CCM to the mainchain.
    # Notice that we do not use the send function because the channel
    # has not been activated yet.
    registrationCCMParams = {
        "name": CHAIN_NAME_MAINCHAIN,
        "messageFeeTokenID": mainchainChannel.messageFeeTokenID
    }

    ccm = {
        "nonce": ownChainAccount.nonce,
        "module": MODULE_NAME_INTEROPERABILITY,
        "crossChainCommand": CROSS_CHAIN_COMMAND_REGISTRATION,
        "sendingChainID": ownChainAccount.chainID,
        "receivingChainID": CHAIN_ID_MAINCHAIN,
        "fee": 0,
        "status": CCM_STATUS_CODE_OK,
        "params": encode(registrationCCMParamsSchema, registrationCCMParams) # registrationCCMParamsSchema is defined in LIP0049
    }

    # We cannot use the send function because the channel is not active yet.
    addToOutbox(CHAIN_ID_MAINCHAIN, ccm)
    ownChainAccount.nonce += 1

    # Emit CCM Sent Event.
    ccmID = sha256(encode(crossChainMessageSchema, ccm))
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CCM_SENT_SUCCESS,
        data = {"ccmID": ccmID},
        topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
    )</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sidechain-termination"><a class="anchor" href="#sidechain-termination"></a>Sidechain termination</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once a sidechain is terminated, it is not possible to send or receive cross-chain messages anymore.
Therefore, the ability of a sidechain to interoperate with other chains can be revoked, i.e., terminated, permanently.
In effect, the sidechain is disconnected from the rest of the ecosystem, and any assets (e.g. fungible or non-fungible tokens), cannot be moved either to or from the respective sidechain.
Therefore, this means that users will not be able to send any assets that they originally held on the sidechain, back to the original native chain, in other words, the chain where the assets were initially created.</p>
</div>
<div class="paragraph">
<p>The following section covers the recovery mechanism deployed by Lisk to address this problem, which will noticeably improve the user experience of the Lisk ecosystem without affecting the security guarantees of the general interoperability solution.
Using dedicated commands that are part of the Interoperability module, users can recover their assets directly on the native chain.
Furthermore, pending messages that were stuck unprocessed in the outbox of the terminated chain can be recovered as well, and their effect reverted on the sending chain.</p>
</div>
<div class="paragraph">
<p>Sidechain termination specifically occurs when the sidechain in question has been inactive for too long, or in the case whereby a malicious cross-chain message is sent.
For example, this could be caused by not posting a transaction with a cross-chain update (CCU) command for more than 30 days, or in the case whereby one was posted with a malicious CCU command on the mainchain.
Hence, it is useful to provide a trustless on-chain mechanism to recover tokens, messages, and information from terminated sidechains.</p>
</div>
<div class="sect2">
<h3 id="termination-causes"><a class="anchor" href="#termination-causes"></a>Termination causes</h3>
<div class="paragraph">
<p>A sidechain can be terminated for various reasons as described below in the following paragraphs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Liveness requirement</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As previously mentioned, active sidechains are required to prove they are still live and functioning by posting a CCU at least once within 30 days.
Therefore violating the liveness requirement (only on the mainchain), result in terminating the sidechain.
This rule guarantees that users do not send funds to inactive sidechains and that users who have tokens in a sidechain that stops communicating with the ecosystem can recover their tokens.
Furthermore, whenever a sidechain has violated the liveness condition, any user can submit a liveness termination on the mainchain, and this will result in the sidechain being terminated.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Violation of the Token-Module Protocol</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With regard to the Token module, when tokens are transferred across the ecosystem, the native chain of the token keeps track of their location in an escrow account.
When tokens are returned back from a chain, the amount stored in the escrow account is reduced, hence ensuring that no extra tokens were minted in the other chain.</p>
</div>
<div class="paragraph">
<p>However, if a cross-chain message tries to transfer back a number of tokens greater than the one stored in the escrow account, the sending chain is terminated and a terminated state account is created.
If the native chain is the mainchain (hence, the token is the LSK token), the terminated state account stores the state root of the sidechain; otherwise it stores the root of the mainchain, which can then be used to initialize the recovery with a <a href="#state-recovery-initialization-command">State Recovery Initialization Command</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Violation of the Custom-Module Protocol</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sidechains can be terminated if they violate the protocol of a <a href="#{:url_custom_module}">custom module</a>.
This is done by calling the <code>terminateChain</code> API of the Interoperability module.
Notice that a sidechain terminated for this reason is not terminated in the whole ecosystem.
For example, it could very well still be active and able to exchange messages with other chains.
However, communication with the sidechain that terminated it is interrupted.</p>
</div>
</div>
<div class="sect2">
<h3 id="sidechain-terminated-message"><a class="anchor" href="#sidechain-terminated-message"></a>Sidechain Terminated Message</h3>
<div class="paragraph">
<p>The role of the sidechain terminated message is to inform sidechains that another sidechain has been terminated on the mainchain, and is unable to receive messages.
The message contains the ID of the terminated chain as well as the last certified state root of the terminated sidechain (as certified on the mainchain).
This value is used for the creation of the terminated state account (on the sidechain receiving the CCM), allowing state recoveries.
This message allows informing sidechains about other terminated sidechains efficiently.
Subsequently, this message will automatically trigger the creation of the terminated sidechain account as soon as the first message is unable to be delivered.
This also prevents further messages to be sent to sidechains that have already been terminated.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-to-recover-information-from-a-sidechain"><a class="anchor" href="#how-to-recover-information-from-a-sidechain"></a>How to recover information from a sidechain</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The commands introduced to the Lisk ecosystem to provide a recovery mechanism for sidechain users are part of the Interoperability module.
There are 5 recovery commands which can be used and are described further in this section below.
These consist of the <a href="#state-recovery-command">State Recovery Command</a>, the <a href="#message-recovery-command">Message Recovery Command</a>, the <a href="#state-recovery-initialization-command">State Recovery Initialization Command</a>, the <a href="#message-recovery-initialization-command">Message Recovery Initialization Command</a>, and the <a href="#liveness-termination-command">Liveness Termination Command</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On the Lisk mainchain:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The users can recover the balance of LSK they had on a terminated sidechain by submitting a transaction with a <a href="#state-recovery-command">State Recovery Command</a>.
The users can recover a pending cross-chain message (CCM) from the sidechain account outbox by submitting a transaction with a <a href="#message-recovery-command">Message Recovery Command</a> on the Lisk mainchain.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On sidechains:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The users can recover the balance of any custom token they had on a terminated sidechain by submitting a transaction with a state recovery command.
The users can recover any assets they had on a terminated sidechain by submitting a transaction with a state recovery command.
The stored data of certain custom modules can be recovered from a terminated sidechain by submitting a transaction with a state recovery command.</p>
</div>
<div class="sect2">
<h3 id="state-recovery-from-the-sidechain-root"><a class="anchor" href="#state-recovery-from-the-sidechain-root"></a>State recovery from the Sidechain Root</h3>
<div class="paragraph">
<p>This mechanism has been enabled in order to ensure that it is possible to recover a specific entry from a substore (i.e. the collection of key-value pairs with a common store prefix), of a module store of a terminated sidechain.
In this context, the term "recover" is referring to triggering a specific state transition defined as part of the relevant module protocol logic.
Specifically, it is based on the sidechain state root, <code>stateRoot</code>, set in the last certificate before sidechain termination.</p>
</div>
<div class="paragraph">
<p>In the context of the mainchain, a valid state recovery command can recover the assets that were held in the terminated sidechain.
In the context of a sidechain, it can recover an entry in a recoverable module store from a terminated sidechain.
A recoverable module is classed as any module that exposes a recover function, which includes the Token module (for any custom token), and the <a href="../../tutorial/nft.html#the-nft-module" class="xref page">NFT module</a>.
This recovery mechanism requires the initialization commands.</p>
</div>
<div class="sect3">
<h4 id="state-recovery-initialization-command"><a class="anchor" href="#state-recovery-initialization-command"></a>State Recovery Initialization Command</h4>
<div class="paragraph">
<p>This command is used to initialize a terminated state account, or to update the state root stored in it if it was not actually set yet.
It can only be submitted on a sidechain.</p>
</div>
<div class="paragraph">
<p>It contains an inclusion proof against the mainchain state root stored in the terminated state account, proving the value of the state root of the terminated sidechain.
Any user on the corresponding sidechain can send a transaction with this command and initiate the state recoveries with respect to the terminated sidechain.
A sidechain account can be terminated on a sidechain using the <code>terminateChain</code> function exposed by the Interoperability module.
In this case, the state root is generally not available and the terminated state account is created without setting the sidechain state root.
Instead, the account stores the mainchain state root at the time of termination.
A state recovery initialization command will in the future set the sidechain state root by giving an inclusion proof against this mainchain state root.</p>
</div>
<div class="paragraph">
<p>The command sets the sidechain state root in the terminated state account so that state recovery commands can be issued.</p>
</div>
<div class="paragraph">
<p>The transactions executing this command have the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>module = MODULE_NAME_INTEROPERABILITY</code></p>
</li>
<li>
<p><code>command = COMMAND_STATE_RECOVERY_INITIALIZATION</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The state recovery initialization command schema can be seen below:</p>
</div>
<details>
<summary class="title">State Recovery Initialization Command</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">stateRecoveryInitializationParams = {
    "type": "object",
    "required": [
        "chainID",
        "sidechainAccount",
        "bitmap",
        "siblingHashes"
    ],
    "properties": {
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "sidechainAccount": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "bitmap": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "siblingHashes": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length": HASH_LENGTH
            },
            "fieldNumber": 4
        }
    }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="ulist">
<ul>
<li>
<p><code>chainID</code>: The ID of the sidechain whose terminated state account is to be initialized or updated.</p>
</li>
<li>
<p><code>sidechainAccount</code>: The sidechain chain account stored on the mainchain.</p>
</li>
<li>
<p><code>bitmap</code>: The bitmap of the inclusion proof of the sidechain account in the mainchain state tree.</p>
</li>
<li>
<p><code>siblingHashes</code>: The sibling hashes of the inclusion proof of the sidechain account in the mainchain state tree.</p>
</li>
</ul>
</div>
<details>
<summary class="title">State Recovery Initialization Command Validation</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def verify(trs: Transaction) -&gt; None:
    if trs.params.chainID == CHAIN_ID_MAINCHAIN or trs.params.chainID == ownChainAccount.chainID:
        raise Exception("Chain ID is not valid.")

    # The commands fails if the sidechain is already terminated on this chain
    if terminatedStateAccount(trs.params.chainID) exists and terminatedStateAccount(trs.params.chainID).initialized == True:
        raise Exception("Sidechain is already terminated.")

    sidechainAccount = decode(chainAccountSchema, trs.params.sidechainAccount)
    # The commands fails if the sidechain is not terminated and did not violate the liveness requirement
    if sidechainAccount.status != CHAIN_STATUS_TERMINATED
        and chainAccount(CHAIN_ID_MAINCHAIN).lastCertificate.timestamp - sidechainAccount.lastCertificate.timestamp &lt;= LIVENESS_LIMIT:
        raise Exception("Sidechain is not terminated.")

    queryKey = STORE_PREFIX_INTEROPERABILITY + SUBSTORE_PREFIX_CHAIN_DATA + sha256(trs.params.chainID)

    query = {
        "key": queryKey,
        "value": sha256(trs.params.sidechainAccount),
        "bitmap": trs.params.bitmap
    }

    proofOfInclusion = { "siblingHashes": trs.params.siblingHashes, "queries" : [query] }

    if terminatedStateAccount(trs.params.chainID) exists:
        if SMTVerify([queryKey], proofOfInclusion, terminatedStateAccount(trs.params.chainID).mainchainStateRoot) == False:
            raise Exception("State recovery initialization proof of inclusion is not valid.")
    else:
        if SMTVerify([queryKey], proofOfInclusion, chainAccount(CHAIN_ID_MAINCHAIN).lastCertificate.stateRoot) == False:
            raise Exception("State recovery initialization proof of inclusion is not valid.")</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">State Recovery Initialization Command Execution</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def execute(trs: Transaction) -&gt; None:
    sidechainAccount = decode(chainAccountSchema, trs.params.sidechainAccount)
    if terminatedStateAccount(trs.params.chainID) exists:
        terminatedStateAccount(trs.params.chainID).stateRoot = sidechainAccount.lastCertificate.stateRoot
        terminatedStateAccount(trs.params.chainID).mainchainStateRoot = EMPTY_BYTES
        terminatedStateAccount(trs.params.chainID).initialized = True
    else:
        createTerminatedStateAccount(trs.params.chainID, sidechainAccount.lastCertificate.stateRoot)</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>Further information including, the <code>createTerminatedStateAccount</code> function can be found in <a href="https://github.com/LiskHQ/lips/blob/master/proposals/lip-0045.md">LIP 0045</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="state-recovery-command"><a class="anchor" href="#state-recovery-command"></a>State Recovery Command</h4>
<div class="paragraph">
<p>This command is used to recover a certain state (for example, fungible and non-fungible tokens), from a sidechain that has been terminated.
The user proves the existence of an entry in the terminated state substore with an inclusion proof against the state root stored in the sidechain terminated account.
The recovery of the state is then handled by the relevant module (for example, the token module would refund the user), and the state root is updated.</p>
</div>
<div class="paragraph">
<p>The proof is validated against the current state root stored in the terminated chain account.
The recovery of the state is then handled by the relevant module (for example the token module would refund the user).</p>
</div>
<div class="paragraph">
<p>The module name is <code>MODULE_NAME_INTEROPERABILITY</code>, and the command name is <code>COMMAND_STATE_RECOVERY</code>. The state recovery command schema, verification, and execution can be seen in the following code snippet below:</p>
</div>
<details>
<summary class="title">State Recovery Command</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">stateRecoveryParams = {
    "type": "object",
    "required": ["chainID", "module", "storeEntries", "siblingHashes"],
    "properties": {
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "module": {
            "dataType": "bytes",
            "length": MODULE_ID_LENGTH,
            "fieldNumber": 2
        },
        "storeEntries": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "properties": {
                    "substorePrefix": {
                        "dataType": "bytes",
                        "fieldNumber": 1
                    },
                    "storeKey": {
                        "dataType": "bytes",
                        "fieldNumber": 2
                    },
                    "storeValue": {
                        "dataType": "bytes",
                        "fieldNumber": 3
                    },
                    "bitmap": {
                        "dataType": "bytes",
                        "fieldNumber": 4
                    }
                },
                "required": ["substorePrefix", "storeKey", "storeValue", "bitmap"]
            }
        },
        "siblingHashes": {
            "type": "array",
            "items": {
                "dataType": "bytes"
            },
            "fieldNumber": 4
        }
    }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="ulist">
<ul>
<li>
<p><code>chainID</code>: The ID of the terminated sidechain identifying the terminated state account from which assets will be recovered.</p>
</li>
<li>
<p><code>module</code>: The ID of the module store to recover.</p>
</li>
<li>
<p><code>storeEntries</code>: An array of store entries to recover. Each store entry is an object with the following properties:</p>
<div class="ulist">
<ul>
<li>
<p><code>substorePrefix</code>: The substore prefix of the substore to recover.</p>
</li>
<li>
<p><code>storeKey</code>: The store key of the entry to recover.</p>
</li>
<li>
<p><code>storeValue</code>: The value of the entry to recover.</p>
</li>
<li>
<p><code>bitmap</code>: The bitmap of inclusion proof.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>siblingHashes</code>: The sibling hashes of the inclusion proof of the store entries in the terminated sidechain state account.</p>
</li>
</ul>
</div>
<details>
<summary class="title">State Recovery Command Verification</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def verify(trs: Transaction) -&gt; None:
    # The terminated account has to exist for this sidechain.
    if terminatedStateAccount(trs.params.chainID) does not exist:
        raise Exception("Terminated state account does not exist.")
    if terminatedStateAccount(trs.params.chainID).initialized == False:
        raise Exception("Terminated state account is not initialized.")

    # Interoperability module cannot be recovered.
    if trs.params.module == MODULE_NAME_INTEROPERABILITY:
        raise Exception("Interoperability module cannot be recovered.")

    if trs.params.module is not associated with a module registered on the chain:
        raise Exception("Module is not registered on the chain.")
    # The module indicated in the transaction params must have a recover function.
    recoveryModule = module associated with trs.params.module
    if recoveryModule does not have a recover function:
        raise Exception("Module is not recoverable.")

    terminatedStateRoot = terminatedStateAccount(trs.params.chainID).stateRoot

    queryKeys = []
    storeQueries = []

    # Calculate store prefix from the module name according to LIP 0040.
    storePrefix = module_name_to_store_prefix(trs.params.module)

    for entry in trs.params.storeEntries:
        if entry.value is EMPTY_BYTES:
            raise Exception("Recovered store value cannot be empty.")

        queryKeys.append(entry.storeKey)
        query = {
            "key": storePrefix + entry.substorePrefix + entry.storeKey,
            "value": sha256(entry.storeValue),
            "bitmap": entry.bitmap
        }
        storeQueries.append(query)

    proofOfInclusionStores = { siblingHashes: trs.params.siblingHashes, queries : storeQueries }

    if SMTVerify(queryKeys, proofOfInclusionStores, terminatedStateRoot) == False:
        raise Exception("State recovery proof of inclusion is not valid.")</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">State Recovery Command Execution</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def execute(trs: Transaction) -&gt; None:
    storeQueries = []

    recoveryModule = module associated with trs.params.module
    for entry in trs.params.storeEntries:
        # The recover function corresponding to trs.params.module applies the recovery logic.
        recoveryModule.recover(trs.params.chainID, entry.substorePrefix, entry.storeKey, entry.storeValue)

        emptyStore = EMPTY_BYTES
        query = {
            "key": trs.params.module + entry.substorePrefix + entry.storeKey,
            "value": sha256(emptyStore),
            "bitmap": entry.bitmap
        }
        storeQueries.append(query)

    terminatedStateAccount(trs.params.chainID).stateRoot = SMTCalculateRoot(trs.params.siblingHashes, storeQueries)</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>Regarding the recovery function, the module given by the <code>trs.params.module</code> must expose a <code>recover</code> function for the execution of this command.
This can be achieved with the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>def recover(terminatedChainID: ChainID, substorePrefix: bytes, storeKey: bytes, storeValue: bytes) -&gt; None:
...</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-recovery-command"><a class="anchor" href="#message-recovery-command"></a>Message Recovery Command</h3>
<div class="paragraph">
<p>This command is used to recover cross-chain messages from a terminated outbox.
Hence, this mechanism allows recovering any CCM that are pending in the sidechain channel outbox.
That is, those CCMs sent from the sidechain that have not been included in the (terminated), receiving chain yet.</p>
</div>
<div class="paragraph">
<p>Transactions executing this command are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>module = <code>MODULE_NAME_INTEROPERABILITY</code></p>
</li>
<li>
<p>command name = <code>COMMAND_MESSAGE_RECOVERY</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The state recovery command schema can be seen below:</p>
</div>
<details>
<summary class="title">Message Recovery Command</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">messageRecoveryParams = {
    "type": "object",
    "required": ["chainID", "crossChainMessages", "idxs", "siblingHashes"],
    "properties": {
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "crossChainMessages": {
            "type": "array",
            "items": {
                "dataType": "bytes"
            },
            "fieldNumber": 2
        },
        "idxs": {
            "type": "array",
            "items": {
                "dataType": "uint32"
            },
            "fieldNumber": 3
        },
        "siblingHashes": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length": HASH_LENGTH
            },
            "fieldNumber": 4
        }
    }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="ulist">
<ul>
<li>
<p><code>chainID</code>: The ID of the terminated sidechain identifying the terminated outbox from which messages will be recovered.</p>
</li>
<li>
<p><code>crossChainMessages</code>: The cross-chain messages to be recovered.</p>
</li>
<li>
<p><code>idxs</code>: The indices of the messages to be recovered.</p>
</li>
<li>
<p><code>siblingHashes</code>: The sibling hashes of the inclusion proof of the cross-chain messages in the sidechain outbox.</p>
</li>
</ul>
</div>
<details>
<summary class="title">Message Recovery Command Verification</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def verify(trs: Transaction) -&gt; None:
    if terminatedOutboxAccount(trs.params.chainID) does not exist:
        raise Exception("Terminated outbox account does not exist.")

    # Check that the idxs are sorted in ascending order
    if trs.params.idxs != sorted(trs.params.idxs):
        raise Exception("Cross-chain message indexes are not sorted in ascending order.")

    # Check that the CCMs are still pending
    for index in trs.params.idxs:
        if index &lt; terminatedOutboxAccount(trs.params.chainID).partnerChainInboxSize:
            raise Exception("Cross-chain message is not pending.")

    # Process basic checks for all CCMs.
    for ccmBytes in crossChainMessages:
        # Verify general format. Past this point, we can access ccm root properties.
        ccm = decode(crossChainMessageSchema, ccmBytes)
        validateFormat(ccm)

        if ccm.status != CCM_STATUS_CODE_OK:
            raise Exception("Cross-chain message status is not valid.")
        # The receiving chain must be the terminated chain
        if ccm.receivingChainID != trs.params.chainID:
            raise Exception("Cross-chain message receiving chain ID is not valid.")
        # The sending chain must be live
        if not isLive(ccm.sendingChainID):
            raise Exception("Cross-chain message sending chain is not live.")

    # Check the inclusion proof against the sidechain outbox root
    proof = {
        size: terminatedOutboxAccount(trs.params.chainID).outboxSize,
        idxs: trs.params.idxs,
        siblingHashes: trs.params.siblingHashes
    }

    if RMTVerify(
        [sha256(ccmBytes) for ccmBytes in trs.params.crossChainMessages],
        proof,
        terminatedOutboxAccount(trs.params.chainID).outboxRoot
        ) == False:
        raise Exception("Message recovery proof of inclusion is not valid.")</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">Message Recovery Command Execution</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def execute(trs: Transaction) -&gt; None:
    senderAddress = sha256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    # Set CCM status to recovered and assign fee to trs sender
    crossChainMessages = [decode(crossChainMessageSchema, ccmBytes) for ccmBytes in trs.params.crossChainMessages]
    recoveredCCMs = []

    for ccmBytes in crossChainMessages:
        ccmID = sha256(ccmBytes)
        # Set ccmID as default topic to all events emitted in applyRecovery and forwardRecovery
        # (instead of the transaction ID).
        defaultEventsTopic = ccmID

        ccm = decode(crossChainMessageSchema, ccmBytes)
        # If the sending chain is the mainchain, recover the CCM.
        # This function never raises an error.
        if ccm.sendingChainID == CHAIN_ID_MAINCHAIN:
            applyRecovery(trs, ccm)
        # If the sending chain is not the mainchain, forward the CCM.
        # This function never raises an error.
        elif ccm.sendingChainID != CHAIN_ID_MAINCHAIN:
            forwardRecovery(trs, ccm)

        # Append the recovered CCM to the list of recovered CCMs.
        # Notice that the ccm has been mutated in the applyRecovery and forwardRecovery functions
        # as the status is set to CCM_STATUS_CODE_RECOVERED (so that it cannot be recovered again).
        recoveredCCMs.append(encode(crossChainMessageSchema, ccm))

    # Update sidechain outbox root
    proof = {
        "size": terminatedOutboxAccount(trs.params.chainID).outboxSize,
        "idxs": trs.params.idxs,
        "siblingHashes": trs.params.siblingHashes
    }

    terminatedOutboxAccount(trs.params.chainID).outboxRoot = RMTCalculateRoot([sha256(ccmBytes) for ccmBytes in recoveredCCMs], proof)



def applyRecovery(trs: Transaction, ccm: CCM) -&gt; None:
    # Calculate CCM ID, used later in events.
    ccmID = sha256(encode(crossChainMessageSchema, ccm))
    ccm.status = CCM_STATUS_CODE_RECOVERED
    ccm.sendingChainID, ccm.receivingChainID = ccm.receivingChainID, ccm.sendingChainID

    try:
        # Modules can verify the CCM.
        # The Token module verifies the escrowed balance in the CCM sending chain for the message fee.
        for each module mdl for which verifyCrossChainMessage exists:
            mdl.verifyCrossChainMessage(trs, ccm)
    except:
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_INVALID_CCM_VERIFY_CCM_EXCEPTION},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
        return

    if ccm.module is not supported:
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_MODULE_NOT_SUPPORTED},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
        return
    elif crossChainCommand is not supported:
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_CROSS_CHAIN_COMMAND_NOT_SUPPORTED},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
        return

    crossChainCommand = cross-chain command associated with (ccm.module, ccm.crossChainCommand)
    try:
        crossChainCommand.verify(trs, ccm)
    except:
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_INVALID_CCM_VERIFY_EXCEPTION},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
        return

    # Create a state snapshot.
    baseSnapshot = snapshot of the current state
    try:
        # Call the beforeCrossChainCommandExecution functions from other modules.
        # For example, the Token module assigns the message fee to the transaction sender.
        for each module mdl for which beforeCrossChainCommandExecution exists:
            mdl.beforeCrossChainCommandExecution(trs, ccm)
    except:
        revert state to baseSnapshot
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_INVALID_CCM_BEFORE_CCC_EXECUTION_EXCEPTION},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
        return
    # Create a state snapshot.
    executionSnapshot = snapshot of the current state
    try:
        # Execute the cross-chain command.
        crossChainCommand.execute(trs, ccm)
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_APPLIED, "code": CCM_PROCESSED_CODE_SUCCESS},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
    except:
        revert state to executionSnapshot
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_FAILED_CCM},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )

    try:
        # Call the afterCrossChainCommandExecution functions from other modules.
        for each module mdl for which afterCrossChainCommandExecution exists:
            mdl.afterCrossChainCommandExecution(trs, ccm)
    except:
        revert state to baseSnapshot
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_INVALID_CCM_AFTER_CCC_EXECUTION_EXCEPTION},
            topics = [ccm.sendingChainID, ccm.receivingChainID


def forwardRecovery(trs: Transaction, ccm: CCM) -&gt; None:
    # Calculate CCM ID, used later in events.
    ccmID = sha256(encode(crossChainMessageSchema, ccm))

    ccm.status = CCM_STATUS_CODE_RECOVERED
    ccm.sendingChainID, ccm.receivingChainID = ccm.receivingChainID, ccm.sendingChainID

    try:
        # Modules can verify the CCM.
        # The Token module verifies the escrowed balance in the CCM sending chain for the message fee.
        for each module mdl for which verifyCrossChainMessage exists:
            mdl.verifyCrossChainMessage(trs, ccm)
    except:
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_INVALID_CCM_VERIFY_CCM_EXCEPTION},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
        return

    # Create a state snapshot.
    baseSnapshot = snapshot of the current state
    try:
        # Call the beforeCrossChainMessageForwarding functions from other modules.
        # For example, the Token module transfers the fee from escrow to escrow.
        for each module mdl for which beforeCrossChainMessageForwarding exists:
            mdl.beforeCrossChainMessageForwarding(trs, ccm)
    except:
        revert state to baseSnapshot
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_PROCESSED,
            data = {"ccmID": ccmID, "result": CCM_PROCESSED_RESULT_DISCARDED, "code": CCM_PROCESSED_CODE_INVALID_CCM_BEFORE_CCC_FORWARDING_EXCEPTION},
            topics = [ccm.sendingChainID, ccm.receivingChainID]
        )
        return

    addToOutbox(ccm.receivingChainID, ccm)
    # Emit CCM forwarded event.
    # Recalculate CCM ID. This differs because of new status, sending, and receiving chains.
    # We use the updated ID as this CCM is appended to the outbox.
    recoveredCCMID = sha256(encode(crossChainMessageSchema, ccm))
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CCM_PROCESSED,
        data = {"ccmID": recoveredCCMID, "result": CCM_PROCESSED_RESULT_FORWARDED, "code": CCM_PROCESSED_CODE_SUCCESS},
        topics = [ccm.sendingChainID, ccm.receivingChainID]</code></pre>
</div>
</div>
</div>
</details>
<div class="sect3">
<h4 id="message-recovery-initialization-command"><a class="anchor" href="#message-recovery-initialization-command"></a>Message Recovery Initialization Command</h4>
<div class="paragraph">
<p>Once a terminated state account has been created on the mainchain, users can send this command to initialize the corresponding terminated outbox account.
This command contains the channel account of the mainchain stored in the state of the terminated sidechain and an inclusion proof for it against the state root stored in the corresponding terminated state account.
The mainchain channel data is needed to acquire the number of messages that were processed in the terminated sidechain (corresponding to the inbox size of the channel).</p>
</div>
<div class="paragraph">
<p>This command sets the outbox root and the inbox size in the terminated outbox account, so that message recovery commands can be issued.</p>
</div>
<div class="paragraph">
<p>Transactions executing this command have the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>module = <code>MODULE_NAME_INTEROPERABILITY</code></p>
</li>
<li>
<p>command = <code>COMMAND_MESSAGE_RECOVERY_INITIALIZATION</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The command name is <code>COMMAND_MESSAGE_RECOVERY_INITIALIZATION</code> and the message recovery initialization command schema can be seen below:</p>
</div>
<details>
<summary class="title">Message Recovery Initialization Command</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">messageRecoveryInitializationParams = {
    "type": "object",
    "required": [
        "chainID",
        "channel",
        "bitmap",
        "siblingHashes"
    ],
    "properties": {
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "channel": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "bitmap": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "siblingHashes": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length": HASH_LENGTH
            },
            "fieldNumber": 4
        }
    }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="ulist">
<ul>
<li>
<p><code>chainID</code> : The ID of the sidechain whose terminated outbox account is to be initialized.</p>
</li>
<li>
<p><code>channel</code> : The channel of this chain stored on the terminated sidechain.</p>
</li>
<li>
<p><code>bitmap</code> : The bitmap of the inclusion proof of the channel in the sidechain state tree.</p>
</li>
<li>
<p><code>siblingHashes</code> : The sibling hashes of the inclusion proof of the channel in the sidechain state tree.</p>
</li>
</ul>
</div>
<details>
<summary class="title">Message Recovery Initialization Command Verification</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def verify(trs: Transaction) -&gt; None:
    if trs.params.chainID == CHAIN_ID_MAINCHAIN or trs.params.chainID == ownChainAccount.chainID:
        raise Exception("Chain ID is not valid.")

    # The commands fails if the  chain is not registered
    if chainAccount(trs.params.chainID) does not exist:
        raise Exception("Chain is not registered.")

    # The commands fails if the chain is not terminated
    if terminatedStateAccount(trs.params.chainID) does not exist or terminatedStateAccount(trs.params.chainID).initialized == False:
        raise Exception("Chain is not terminated.")

    # The commands fails if there exist already a terminated outbox account
    if terminatedOutboxAccount(trs.params.chainID) exists:
        raise Exception("Terminated outbox account already exists.")

    queryKey = STORE_PREFIX_INTEROPERABILITY + SUBSTORE_PREFIX_CHANNEL_DATA + sha256(CHAIN_ID_MAINCHAIN)

    query = {
        key: queryKey,
        value: sha256(trs.params.channel),
        bitmap: trs.params.bitmap
    }

    proofOfInclusion = { siblingHashes: trs.params.siblingHashes, queries : [query] }

    if SMTVerify([queryKey], proofOfInclusion, terminatedStateAccount(trs.params.chainID).stateRoot) == False:
        raise Exception("Message recovery initialization proof of inclusion is not valid.")</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">Message Recovery Initialization Command Execution</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def execute(trs: Transaction) -&gt; None:
    partnerChannel = decode(channelSchema, trs.params.channel)
    createTerminatedOutboxAccount(
        trs.params.chainID,
        channel(trs.params.chainID).outbox.root,
        channel(trs.params.chainID).outbox.size,
        partnerChannel.inbox.size</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="liveness-termination-command"><a class="anchor" href="#liveness-termination-command"></a>Liveness Termination Command</h4>
<div class="paragraph">
<p>This command is used to terminate a sidechain that violated the liveness condition.
As such, it can only be submitted on the mainchain.
The required parameters, verification, and execution are listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>module = MODULE_NAME_INTEROPERABILITY</code></p>
</li>
<li>
<p><code>command = COMMAND_LIVENESS_TERMINATION</code></p>
</li>
</ul>
</div>
<details>
<summary class="title">Liveness Termination Command</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">livenessTerminationParams = {
    "type": "object",
    "required": ["chainID"],
    "properties": {
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="ulist">
<ul>
<li>
<p>The chain ID is the ID of the respective sidechain to be terminated.</p>
</li>
</ul>
</div>
<details>
<summary class="title">Liveness Termination Verification</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def verify(trs: Transaction) -&gt; None:

    if chainAccount(trs.params.chainID) does not exist:
        raise Exception("Chain account does not exist.")

    # The commands fails if the sidechain is already terminated
    if chainAccount(trs.params.chainID).status == CHAIN_STATUS_TERMINATED:
        raise Exception("Sidechain is already terminated.")

    # or if the sidechain did not violate the liveness condition
    if isLive(trs.params.chainID):
        raise Exception("Sidechain did not violate the liveness condition.")</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">Liveness Termination Execution</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">def execute(trs: Transaction) -&gt; None:
    terminateChain(trs.params.chainID)</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="recovery-process-workflow"><a class="anchor" href="#recovery-process-workflow"></a>Recovery Process Workflow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This final section covers how the recovery process mechanism functions, and how to initiate a recovery from both the mainchain and the sidechain.
As the relevant commands required have already been described above, the process flow is described below.
As can also be seen further below in this section, the process is slightly different on the mainchain and the sidechain.</p>
</div>
<div class="sect2">
<h3 id="recovery-from-the-terminated-chain-outbox"><a class="anchor" href="#recovery-from-the-terminated-chain-outbox"></a>Recovery from the terminated chain outbox</h3>
<div class="paragraph">
<p>Regarding the terminated chain outbox, it is possible to recover any pending messages that may have been unprocessed in the outbox of the terminated chain, and subsequently, their effect can be reverted on the sending chain.
A message recovery initialization command is responsible for setting the outbox root and the inbox size in the terminated outbox account.
This is followed by issuing a message recovery command in order to recover any pending messages present in the outbox of the terminated sidechain.</p>
</div>
</div>
<div class="sect2">
<h3 id="mainchain"><a class="anchor" href="#mainchain"></a>Mainchain</h3>
<div class="paragraph">
<p>Firstly regarding the mainchain, the process required is as follows, and is depicted in the illustration in figure 3 below:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The sidechain is terminated by submitting a <a href="#liveness-termination-command">Liveness Termination Command</a>, or violating the token-module protocol.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>A <strong>terminated state account</strong> containing the last certified state root of the sidechain is created in the state.</p>
</li>
<li>
<p>A User can start recovering assets with a <strong>state recovery command</strong> as covered above.</p>
</li>
</ol>
</div>
</li>
<li>
<p>A <strong>message recovery initialization command</strong> is then sent.
This command contains the inbox size of the mainchain stored on the terminated sidechain, which indicates how many cross-chain messages were processed.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>A <strong>terminated outbox account</strong> is created in the state.
This contains the outbox root of the terminated sidechain channel, and the inbox size provided with the message recovery initialization command.</p>
</li>
<li>
<p>A user can now recover pending messages with a <a href="#message-recovery-command">Message Recovery Command</a>.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../_images/understand-blockchain/interop/mainchain-recovery_v1.png" alt="mainchain recovery v1" height="500">
</div>
<div class="title">Figure 2. Recovery process from the mainchain.</div>
</div>
</div>
<div class="sect2">
<h3 id="sidechain"><a class="anchor" href="#sidechain"></a>Sidechain</h3>
<div class="paragraph">
<p>On a sidechain, the process flow can occur in 3 scenarios which are described below and are also depicted in the corresponding 3 diagrams.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The sidechain is terminated for violating the protocol of the token module or of a custom module.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>A terminated <strong>state account</strong> containing the mainchain last certified state root is created in the sidechain state.</p>
</li>
<li>
<p>A <strong>state recovery initialization command</strong> is sent.
This command contains the last certified state root (on the mainchain), of the terminated sidechain and an inclusion proof against the mainchain state root stored in the terminated state account.</p>
</li>
<li>
<p>A user is able to recover assets native to the sidechain with a <strong>state recovery command</strong>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>The sidechain receives a <strong>sidechain terminated message</strong> from the mainchain, indicating that a cross-chain message could not be delivered because the receiving chain was terminated.
This message contains the last certified state root (on the mainchain), of the terminated sidechain.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>A <strong>terminated state account</strong> containing the sidechains last certified state root is created in the state.
However, it is important to note that in this case, the terminated sidechain state root is set immediately, and there is no need for a state recovery initialization command.</p>
</li>
<li>
<p>A user can recover assets native to the sidechain with a <strong>state recovery command</strong>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>The sidechain is terminated on the mainchain.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>A <strong>state recovery initialization command</strong> is sent.
This command contains the last certified state root (on the mainchain), of the terminated sidechain and an inclusion proof against the last certified mainchain state root, proving the termination.</p>
</li>
<li>
<p>A <strong>terminated state account</strong> containing the sidechains last certified state root is created in the state.</p>
</li>
<li>
<p>A user can recover assets that are native to the sidechain with a <strong>state recovery command</strong>.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>As mentioned above the steps from 1 to 3 are depicted graphically below in figure 4.</p>
</div>
<div class="sect3">
<h4 id="message-recovery-from-the-sidechain-outbox"><a class="anchor" href="#message-recovery-from-the-sidechain-outbox"></a>Message Recovery from the Sidechain Outbox</h4>
<div class="paragraph">
<p>This message recovery mechanism is able to recover any CCM that is pending in the sidechain outbox.
Specifically, those CCMs that have not yet been included in the receiving sidechain.
Hence, this includes all the CCMs whose indices are larger than the last message index that the receiving sidechain reported to have included in its inbox on the mainchain.
Any user can submit a message recovery command to recover several CCMs simultaneously.
When the command is processed, the recovery is dependent on whether the sending chain is the mainchain or a sidechain.</p>
</div>
<div class="paragraph">
<p>However, it is important to note that users are not guaranteed to recover their CCMs in every situation.
Certain state information of the terminated sidechain might have been modified before the termination occurred, and this would make the recovered CCM application fail.
For example, in the case whereby escrowed LSK exists in the sidechain account on the mainchain, which could have been subtracted by prior malicious behavior in the terminated sidechain.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../_images/understand-blockchain/interop/sidechain-recovery1-v2.png" alt="sidechain recovery1 v2" height="500">
</div>
<div class="title">Figure 3. Recovery process from the sidechain (Step 1)</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../_images/understand-blockchain/interop/sidechain-recovery2_v2.png" alt="sidechain recovery2 v2" height="500">
</div>
<div class="title">Figure 4. Recovery process from the sidechain (Step 2)</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../_images/understand-blockchain/interop/sidechain-recovery3-v2.png" alt="sidechain recovery3 v2" height="500">
</div>
<div class="title">Figure 5. Recovery process from the sidechain (Step 3)</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="recovery-process-summary-overview"><a class="anchor" href="#recovery-process-summary-overview"></a>Recovery Process Summary Overview</h3>
<div class="paragraph">
<p>In order to summarize the recovery process, a brief example of recovering assets/tokens from the state of a terminated sidechain is provided below:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A sidechain is terminated on the mainchain due to inactivity.</p>
</li>
<li>
<p>The last certified state root, i.e. the state root contained in the last certificate received from the sidechain, is stored in the terminated state account of the sidechain.</p>
</li>
<li>
<p>The user can recover the assets/tokens by sending a state recovery command.
This command contains an inclusion proof, proving the user balance on the sidechain against the state root stored in the terminated state account.</p>
</li>
<li>
<p>The funds are credited to the user&#8217;s account on the mainchain.</p>
</li>
<li>
<p>Finally, the state root of the terminated sidechain is then updated accordingly.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Finally, there are certain data-availability requirements necessary to prepare a recovery transaction as listed below:</p>
</div>
<div class="paragraph">
<p><strong>Message recovery commands</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to the cross-chain messages in the sidechain outbox.</p>
</li>
<li>
<p>The entire tree of the sidechain outbox must be able to provide the inclusion proof.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>State recovery commands</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to the specific asset to recover from the sidechain.</p>
</li>
<li>
<p>The entire state tree authenticated by the last certified state root must be able to provide the inclusion proof.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Furthermore, this information has to be kept updated every time a recovery command is processed.
Additionally, it would be possible to employ third-party services that could offer to recover assets/tokens/messages for a nominal fee on behalf of the users.
It is envisaged that such services would deploy a mainchain and sidechain node to provide the data availability required to perform the recovery.</p>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="communication.html">Cross-chain communication</a></span>
  <span class="next"><a href="../blocks-txs.html">Blocks and Transactions</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <div class="footerdiv">
    <p> 2022 Lisk Foundation</p>
    <!-- <div class="community-section">
      <p class="community-section__text">Follow Lisk on: </p>
      <div class="community-section__icons"> -->
    <div class="community_icons">
        <a href="https://lisk.chat" title="Discord" target="_blank" class="footer_icon icon-discord"><p>Discord</p></a>
        <a href="https://dev.lisk.com" title="Discourse" target="_blank" class="footer_icon icon-discourse"><p>Discourse</p></a>
        <a href="https://github.com/LiskHQ" title="GitHub" target="_blank" class="footer_icon icon-github"><p>GitHub</p></a>
  <!--    </div> -->
    </div>
  </div>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/vendor/tabs-block-behaviour.js"></script>
<script async src="../../../_/js/vendor/swagger-ui.js"></script>
<script async src="../../../_/js/vendor/component-versions.js"></script>
<script src="../../../_/js/vendor/custom.js"></script>
  </body>
</html>
