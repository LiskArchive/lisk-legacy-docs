= Plugins
Mona Bärenfänger <mona@lightcurve.io> Muhammad Talha <muhammad.talha@lightcurve.io>
//Settings
:toc: preamble
:toclevels: 5
:page-toclevels: 4
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:docs_sdk: lisk-sdk::
// URLs
:url_github_hello_plugin: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/hello-world/blockchain_app/hello_plugin/index.js
:url_github_nft_plugin: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/nft/blockchain_app/nft_api_plugin/index.js
:url_github_srs_api_plugin: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/social-recovery/blockchain_app/plugins/srs_api_plugin/index.js
:url_github_srs_data_plugin: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/social-recovery/blockchain_app/plugins/srs_data_plugin/index.js
:url_github_base_plugin: https://github.com/LiskHQ/lisk-sdk/blob/development/framework/src/plugins/base_plugin.ts

:url_github_faucet_endpoints: https://github.com/LiskHQ/lisk-sdk/blob/development/framework-plugins/lisk-framework-faucet-plugin/src/plugin/endpoint.ts

// Project URLs
:url_advanced_architecture_config: understand-blockchain/sdk/architecture.adoc#configuration
:url_advanced_communication: understand-blockchain/sdk/rpc.adoc
:url_subscribe_events: understand-blockchain/sdk/rpc.adoc#how-to-subscribe-to-events
:url_advanced_communication_pluginschannel: {url_advanced_communication}#channel-for-plugins
:url_advanced_communication_alias: {url_advanced_communication}#alias
:url_advanced_communication_interfaces: {url_advanced_communication}#interfaces
:url_advanced_communication_invoke_endpoints: {url_advanced_communication}#how-to-invoke-endpoints
:url_advanced_schemas: understand-blockchain/sdk/codec-schema.adoc
:url_guides_setup: build-blockchain/create-blockchain-app.adoc
:url_guides_setup_helloapp: {url_guides_setup}#the-hello-world-application
:url_guides_plugin: build-blockchain/create-plugin.adoc
:url_introduction_modules: understand-blockchain/sdk/modules-assets.adoc
:url_references_config: {docs_sdk}config.adoc
:url_references_config_default: {docs_sdk}config.adoc#configuration
:url_lisk_commander: {docs_sdk}references/lisk-commander/index.adoc
:url_references_framework_baseplugin: {docs_sdk}references/framework-class-interfaces.adoc#the-baseplugin
:url_rpc_endpoints: understand-blockchain/sdk/rpc.adoc
:url_tutorials_nft: tutorial/nft.adoc
:url_tutorials_srs: tutorial/srs.adoc

Plugins offer useful features to the application and external services, which are part of the off-chain logic of the blockchain application.
In other words, a plugin will never change the state of the blockchain itself, contrary to the xref:{url_introduction_modules}[modules], which hold the on-chain logic of the blockchain application.

.When to create a plugin
****
Plugins are able to perform the following:

* Search the blockchain data.
* Aggregate the blockchain data.
* Provide a UI for the blockchain application.
* Automate the blockchain logic, such as automatically sending transactions.
* Add a proxy to the application interfaces.
****

== Creating a Plugin
Lisk provides a no-brainer method to create a plugin using xref:{url_lisk_commander}[Lisk Commander]. 
By executing the following command in a terminal, a plugin can be created and registered to a blockchain application.

[source,bash]
----
lisk generate:plugin NAME_OF_PLUGIN
----

[TIP]
====
For a more practical guide how to create a new plugin, check out the guide xref:{url_guides_plugin}[].

If you wish to view an example of a fully implemented plugin, check out the following examples:

* The {url_github_hello_plugin}[Hello plugin] from the xref:{url_guides_setup_helloapp}[Hello World] blockchain application.
* The {url_github_nft_plugin}[NFT plugin] from the xref:{url_tutorials_nft}[].
* The {url_github_srs_api_plugin}[SRS API plugin] and the {url_github_srs_data_plugin}[SRS data plugin] from the xref:{url_tutorials_srs}[].
====

Each plugin can have a set of files for defining schemas, types and endpoints of a plugin.
By default, Lisk Commander only creates the *example_plugin.ts* file and registers into the *plugins.ts* file. The structure of the plugins folder can similar to one mentioned below:

.Sample "plugins" directory inside a blockchain application
----
src/
├── plugins/
│   ├── example/
│   │   ├── example_plugin.ts
│   │   ├── types.ts
│   │   ├── endpoint.ts
│   │   └── schema.ts
│   └── faucet/
│   │   ├── faucet_plugin.ts
│   │   ├── types.ts
│   │   ├── endpoint.ts
│   │   └── schema.ts
└── plugins.ts
----

It's worth noting that the directory structure of a plugin can be customized as per need by the blockchain application developer and the separation of *types*, *schemas* and *endpoints* is purely made to ease scalability.

Once a plugin is bootstrapped, it is registered with the `plugins.ts` file.

.src/plugins.ts
[source,typescript]
----
import { Application } from 'lisk-sdk';
import { ExamplePlugin } from "./plugins/example/example_plugin";

export const registerPlugins = (app: Application): void => {
    app.registerPlugin(new ExamplePlugin());
};
----



== Plugin Anatomy




Every plugin in a blockchain application must be based on the `base_Plugin` class. The `base_Plugin` class provides a basic skeleton for what is required of a custom plugin created by a developer of BAap. For more information see {url_github_base_plugin}[base_plugin.ts^] on GitHub.
 
Each Plugin has three essentials parts, that are:

* Elements
* Interfaces
* Execution Logic

.Anotomy of an ExamplePlugin class based on the BasePlugin class
image::intro/plugin-diagram.png[plugin-diagram, 1000 ,align="center"]


=== Elements
Each plugin inherits functions and properties from the `base_Plugin` class. These are the elements of a plugin.  

==== nodeModulePath() 
Whenever a plugin is bootstrapped with the Lisk Commander, a `nodeModulePath()` function is created automatically. This function return the path of the *plugin.ts* file. The plugin.ts file contains links to all the plugins registered with a blockchain application.

.Example: nodeModulePath() function of a custom plugin
[source,typescript]
----
public get nodeModulePath(): string {
    return __filename;
}
----

==== name()
The `name()` function returns the name of the Plugin. It is inherited from the `base_plugin` class. The plugin names are used for routing RPC requests to or from the plugin.

.Example: name() function of the base_Plugin class
[source,typescript]
----
public get name(): string {
    const name = this.constructor.name.replace('Plugin', '');
    return name.charAt(0).toLowerCase() + name.substr(1);
}
----

==== datapath()
Lisk stores the blockchain application's data to the `~/.lisk/APPLICATION_NAME` directory. The `datapath()` function returns that path to the plugin so that data specific to the application can be retrieved.

.Example: datapath() function of the base_Plugin class
[source,typescript]
----
public get dataPath(): string {
    const dirs = systemDirs(this.appConfig.system.dataPath);
    return join(dirs.plugins, this.name, 'data');
}
----


==== Configuration
Each plugin either inherits the default application's configuration or it can inject custom configurations relating to a plugin. For more information about default configuration see, xref:{url_references_config_default}[Configuration].

===== Default Configuration
Whenever your create a plugin with Lisk Commander, by default, it inherits the application's configurations as defined in the `base_Plugin` class. A plugin with default configurations will look similar to the following: 

.Example: 
[source,typescript]
----
import { BasePlugin } from 'lisk-sdk';

export class ExamplePlugin extends BasePlugin {

	public name: 'example';

	public get nodeModulePath(): string {
		return __filename;
	}

	public async load(): Promise<void> {}

	public async unload(): Promise<void> { }
}
----

===== Custom Configuration
A plugin can also have its own set of configurations that are passed to it as shown in the following code snippet. 

.Example: plugins/faucet/faucet_plugin.ts
[source,typescript]
----
import { BasePlugin, PluginInitContext, cryptography } from 'lisk-sdk';
import * as express from 'express';
import { join } from 'path';
import { Server } from 'http';
import { configSchema } from './schemas';
import { FaucetPluginConfig, State } from './types';
import { Endpoint } from './endpoint';

export class FaucetPlugin extends BasePlugin<FaucetPluginConfig> {
	public configSchema = configSchema;

}
----
Each custom configuration's schema and type of values must be defined for each plugin.

NOTE: It is not necassary to follow the directory structure defined earlier, however, schemas and types must be defined somewhere and passed to the plugin for a plugin to work correctly.


==== Schemas
A Schemas of a plugin contains the structural information of the data accepted by a plugin. A schema can be for a custom configuration or for a specific kind of data that must be passed to a plugin to fulfill the business logic. Schemas are passed to the plugin class and are later verified by the Lisk framework. Schemas are present inside the `schema.ts` file inside a plugin's folder.

.Example: plugins/faucet/schema.ts
[source,typescript]
----
export const configSchema = {
	$id: '#/plugins/liskFaucet/config',
	type: 'object',
	properties: {
		port: {
			type: 'integer',
			minimum: 1,
			maximum: 65535,
		},
		host: {
			type: 'string',
			format: 'ip',
		},
		encryptedPassphrase: {
			type: 'string',
			format: 'encryptedPassphrase',
			description: 'Encrypted passphrase of the genesis account',
		},
		applicationUrl: {
			type: 'string',
			format: 'uri',
			description: 'URL to connect',
		},
		fee: {
			type: 'string',
			description: 'The transaction fee used to faucet an account',
		},
		amount: {
			type: 'string',
			description: 'Number of tokens to fund an account per request',
		},
		tokenPrefix: {
			type: 'string',
			description: 'The token prefix associated with your application',
		},
		logoURL: {
			type: 'string',
			format: 'uri',
			description: 'The URL of the logo used on the UI',
		},
		captchaSecretkey: {
			type: 'string',
			description: 'The re-captcha secret key',
		},
		captchaSitekey: {
			type: 'string',
			description: 'The re-captcha site key',
		},
	},
	required: ['encryptedPassphrase', 'captchaSecretkey', 'captchaSitekey'],
	default: {
		port: 4004,
		host: '127.0.0.1',
		applicationUrl: 'ws://localhost:8080/ws',
		fee: '0.1',
		amount: '100',
		tokenPrefix: 'lsk',
	},
};

export const fundParamsSchema = {
	$id: '/lisk/faucet/fund',
	type: 'object',
	required: ['address'],
	properties: {
		address: {
			type: 'string',
			format: 'hex',
		},
		token: {
			type: 'string',
		},
	},
};

----

==== Types
All the types of variables used by a plugin are usually defined in the `types.ts` file. Whilst Schemas describe the schema of data, the *Types* file contains the definitions of all the variables that are used by a plugin.

.Example: 
[source,typescript]
----
export interface FaucetPluginConfig {
	port: number;
	host: string;
	encryptedPassphrase: string;
	captchaSitekey: string;
	captchaSecretkey: string;
	applicationUrl: string;
	fee: string;
	amount: string;
	tokenPrefix: string;
	captchaSecret: string;
	logoURL?: string;
}

export interface State {
	publicKey?: Buffer;
	passphrase?: string;
}
----


=== Interfaces

Plugins can expose <<endpoints>>, which allow other plugins and external tools to interact with the plugin. Plugins can also subscribe to <<events>> emitted by the Lisk Blockchain. 

TIP: View the "Interfaces" section of the xref:{url_advanced_communication_interfaces}[Communication] page to see an overview of the different interfaces and their accessibility in modules, plugins, and external services.

==== Endpoints

Endpoints are functions which can be xref:{url_advanced_communication_invoke_endpoints}[invoked] via Remote-Procedure-Calls (RPC) by plugins and external services, to request data from the plugin.

Endpoints of a plugins should be defined in the `Endpoint` class. The `Endpoint` class usually resides in the endpoint.ts file inside each plugin's directory. The `Endpoint` class inherits from the `BasePluginEndpoint` class. A sample `Endpoint` class and its endpoint is available in the following code snippet:

.Example: Endpoints of the Faucet plugin
[source,typescript]
----

export class Endpoint extends BasePluginEndpoint {
    
    // ...

    public async authorize(context: PluginEndpointContext): Promise<{ result: string }> {
		validator.validate(authorizeParamsSchema, context.params);
		const { enable, password } = context.params;
		try {
			const parsedEncryptedPassphrase = cryptography.encrypt.parseEncryptedMessage(
				this._config.encryptedPassphrase,
			);
			const passphrase = await cryptography.encrypt.decryptMessageWithPassword(
				parsedEncryptedPassphrase,
				password as string,
				'utf-8',
			);
			const { publicKey } = cryptography.legacy.getPrivateAndPublicKeyFromPassphrase(passphrase);
			this._state.publicKey = enable ? publicKey : undefined;
			this._state.passphrase = enable ? passphrase : undefined;
			const changedState = enable ? 'enabled' : 'disabled';
			return {
				result: `Successfully ${changedState} the faucet.`,
			};
		} catch (error) {
			throw new Error('Password given is not valid.');
		}
	}

    // ...
}
----
For more information, see {url_github_faucet_endpoints}[Faucet_endpoints.ts].

==== Events
A plugin can subscribe to RPC events emitted by the blockchain. To subscribe to an event see, xref:{url_subscribe_events}[How to subscribe events].




=== Execution Logic

==== load()

The `load()` method will be invoked by the controller to load the plugin.
It contains the plugin logic that is executed when the plugin is loaded in the application.

It can be used to retrieve, mutate, store and/or publish data in a specific manner, depending on the purpose of the plugin.

The `channel`, which is available inside of the `load()` function, allows access to the xref:{url_rpc_endpoints}[] in order to subscribe to events or to invoke certain actions within the application to retrieve the desired data.


The following variables are accessible in the `load()` function:

* `channel`: See xref:{url_advanced_communication_pluginschannel}[Channel for plugins].
* `this.options`: The <<plugin-defaults>>, as defined in the xref:{url_advanced_architecture_config}[application configuration].

.Example: load() function of the "faucet" plugin
[source,typescript]
----
public async load(): Promise<void> {
    const app = express();
    app.get('/api/config', (_req, res) => {
        const config = {
            applicationUrl: this.config.applicationUrl,
            amount: this.config.amount,
            tokenPrefix: this.config.tokenPrefix,
            captchaSitekey: this.config.captchaSitekey,
            logoURL: this.config.logoURL,
            faucetAddress: this._state.publicKey
                ? cryptography.address.getLisk32AddressFromPublicKey(this._state.publicKey)
                : undefined,
        };
        res.json(config);
    });
    app.use(express.static(join(__dirname, '../../build')));
    this._server = app.listen(this.config.port, this.config.host);
}
----

==== unload()

The `unload()` method will be invoked by the controller to unload the plugin correctly.
It is executed on application shutdown.

.Example: unload() function of the "faucet" plugin
[source,typescript]
----
public async unload(): Promise<void> {
    return new Promise((resolve, reject) => {
        this._server.close(err => {
            if (err) {
                reject(err);
                return;
            }
            resolve();
        });
    });
}
----




// == Adding a plugin to the application

// Plugins need to be registered to become available in the application.
// If the application was xref:{url_guides_setup}[bootstrapped] with Lisk Commander, they are registered in the file `src/app/plugins.ts`.

// .Example: How to register a plugin with the application in `plugins.ts`
// [source,typescript]
// ----
// /* eslint-disable @typescript-eslint/no-empty-function */
// import { Application } from 'lisk-sdk';
// import { LatestHelloPlugin } from "./plugins/latest_hello/latest_hello_plugin";

// export const registerPlugins = (app: Application): void => {

//     app.registerPlugin(new LatestHelloPlugin());
// };
// ----

// If no custom config option is provided, the plugin will use the default config options, defined in <<plugin-defaults>>.

// == Plugin anatomy

// image::intro/plugin-diagram.png[plugin-diagram ,500 ,align="center"]

// == The plugin class

// All custom plugins must extend the `BasePlugin` exposed by the SDK.
// The interface for the `BasePlugin` is described in the xref:{url_references_framework_baseplugin}[Lisk Framework reference].

// [source,js]
// ----
// const { BasePlugin } = require("lisk-sdk");

// class somePlugin extends BasePlugin {

// }
// ----

// == Plugin Name

// The unique identifier of the plugin.

// It is used as prefix in the xref:{url_advanced_communication_alias}[alias] of events and endpoints, and as a key label to to add the properties of the <<plugin-defaults>> to the xref:{url_advanced_architecture_config}[application configuration].

// .Example: Alias of the forger plugin
// [source,typescript]
// ----
// public static get alias(): string {
//     return 'forger';
// }
// ----

// == Plugin defaults

// The configuration schema for this plugin.

// After registering the plugin with the application, it can be configured in the xref:{url_advanced_architecture_config}[application configuration], using the defined schema here.
// The configuration options can then be accessed in the plugin under the variable `this.options`.

// .Example: Config schema of the Dashboard plugin
// [source,js]
// ----
// get defaults() {
//     return {
//         $id: '#/plugins/lisk-dashboard/config',
//         type: 'object',
//         properties: {
//             applicationName: {
//                 type: 'string',
//                 description: 'Application name to be shown near Logo',
//             },
//             applicationUrl: {
//                 type: 'string',
//                 format: 'uri',
//                 description: 'URL to connect',
//             },
//             port: {
//                 type: 'integer',
//                 minimum: 1,
//                 maximum: 65535,
//             },
//             host: {
//                 type: 'string',
//                 format: 'ip',
//             },
//         },
//         required: [],
//         default: {
//             applicationUrl: 'ws://localhost:8080/ws',
//             port: 4005,
//             host: '127.0.0.1',
//             applicationName: 'Lisk',
//         },
//     }
// };
// ----




// ----
// .
// ├── plugins/
// │   ├── faucet/
// │   │   ├── faucet_plugin.ts
// │   │   ├── types.ts
// │   │   └── schema.ts
// │   └── example/
// │   │   ├── example_plugin.ts
// │   │   ├── types.ts
// │   │   └── schema.ts
// └── 
// ----