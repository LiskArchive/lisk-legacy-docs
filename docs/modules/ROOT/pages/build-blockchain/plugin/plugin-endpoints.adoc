= Creating endpoint & Testing the application
Muhammad Talha <muhammad.talha@lightcurve.io>

:toc: preamble
:idprefix:
:idseparator: -
// :sectnums:
:docs_sdk: lisk-sdk::
// URLs
:url_github_guides_plugin: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/hello/hello_client/src/app/plugins/hello_info
:url_rocks_db: https://rocksdb.org/
:url_send_transaction: build-blockchain/module/command.adoc#try-the-new-command-out

// Project URLS
:url_lisk_db: {docs_sdk}references/lisk-elements/db.adoc
:url_plugin_schema: build-blockchain/plugin/schema-types.adoc#NewHelloEvent

Now that we have our core logic in place, it is time to create an endpoint for our plugin which will fetch all the NewHello message, sender's address, and height of the block, as stored in our database for each event. So, on this page, you'll learn.

====
* [x] Creating the Endpoint class
* [x] Creating an endpoint for HelloInfo plugin. 
* [x] Testing our plugin.
====


== Creating an Endpoint

All endpoints of a plugin exist in an `endpoint.ts` file, which exist in the root folder of the plugin. So, let's create an `endpoint.ts` file in the `hello_info` directory. This file will contain the `Endpoint` class and an endpoint `getMessageList()`.

The Endpoint class is based on the `BasePluginEndpoint` class, which is available in the `lisk-sdk` package.

.Endpoint class
[source,typescript]
----
import {
    BasePluginEndpoint,
    PluginEndpointContext,
    db as liskDB,
    cryptography,
} from 'lisk-sdk';
import {
    getEventHelloInfo,
} from './db';

import { Event as helloEvent } from './types';

export class Endpoint extends BasePluginEndpoint {
    private _pluginDB!: liskDB.Database;

    // initialize your database intance here
    public init(db: liskDB.Database) {
        this._pluginDB = db;
    }

    // [...]
}
----

Since our data exists on an off-chain database, we would like to have an instance of our plugin database so that an endpoint can query data from there. 

Next up is our endpoint function, every `public` function present in the Endpoint class gets registered to the sidechain client. Our endpoint will return a list of all the hellomessages so we call our endpoint `getMessageList()`.

Our endpoint will have a `messageList` and a `data[]` which will house the information retrieved from the database.

.Endpoint class
[source,typescript]
----
export class Endpoint extends BasePluginEndpoint {
    // [...]

    // Returns all Sender Addresses, Hello Messages and Block Height of the block where the Hello Event was emitted.
    public async getMessageList(_context: PluginEndpointContext): Promise<unknown[]> {
        const data: {
            ID: number;
            senderAddress: string;
            message: string;
            blockHeight;
        }[] = [];
        // 1. Get all the stored events from database.
        const messageList = await getEventHelloInfo(this._pluginDB);
        // 2. Push them into an array for presentation.
        for (const helloMessage of messageList) {
            data.push({
                ID: helloMessage.id.readUInt32BE(0),
                senderAddress: cryptography.address.getLisk32AddressFromAddress(helloMessage['senderAddress']),
                message: helloMessage['message'],
                blockHeight: helloMessage['height'],
            })
        }
        return data;
    }
}
----

The `getEventHelloInfo()` will return all the NewHello events stored inside the plugin's database. Once recieved, the endpoint will push each event's data into an array of objects and will return this array as a response.

[TIP]
====
It is worth mentioning that an endpoint can also have various input arguments. These arguments are passed via the `PluginEndpointContext` class available in `lisk-sdk`. If the endpoint doesn't require any arguments then, the request `"params": {}` property can be left empty.
====

After you add all the aforementioned code, your `endpoint.ts` file should look like this:

.Endpoint of HelloInfoPlugin
[%collapsible]
====
.hello_client/src/app/plugins/hello_info/endpoint.ts
[source,typescript]
----
/* eslint-disable dot-notation */
import {
    BasePluginEndpoint,
    PluginEndpointContext,
    db as liskDB,
    cryptography,
} from 'lisk-sdk';
import {
    getEventHelloInfo,

} from './db';

export class Endpoint extends BasePluginEndpoint {
    private _pluginDB!: liskDB.Database;

    public init(db: liskDB.Database) {
        this._pluginDB = db;
    }

    // Returns all Sender Addresses, Hello Messages and Block Height of the block where the Hello Event was emitted.
    public async getMessageList(_context: PluginEndpointContext): Promise<unknown[]> {
        const data: {
            ID: number;
            senderAddress: string;
            message: string;
            blockHeight;
        }[] = [];
        // 1. Get all the stored events from database.
        const messageList = await getEventHelloInfo(this._pluginDB);
        // 2. Push them into an array for presentation.
        for (const helloMessage of messageList) {
            data.push({
                ID: helloMessage.id.readUInt32BE(0),
                senderAddress: cryptography.address.getLisk32AddressFromAddress(helloMessage['senderAddress']),
                message: helloMessage['message'],
                blockHeight: helloMessage['height'],
            })
        }
        return data;
    }
}
----
====


== Testing HelloInfo Plugin

Its time to test the HelloInfo plugin. Since, you already know how to run the hello client, create and send a hello message as described in xref:{url_send_transaction}[How to create a command â†’ Try the new command out].

Once a transaction is verified and becomes part of the block, wait for your plugin's sync interval to kick in. 
In our case, since we set the `syncInterval` configuration to 30 seconds (60000 milliseconds) in the *custom_config.json*, the sync will happen after every 30 seconds.

