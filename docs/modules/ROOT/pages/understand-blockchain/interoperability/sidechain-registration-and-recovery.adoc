= Sidechain Registration & Recovery
Chris Braithwaite <christopher.braithwaite@lightcurve.io> Mona Bärenfänger <mona@lightcurve.io>
:description: How to register, terminate, and recover a sidechain.
:toc:
:idprefix:
:idseparator: -
:docs-sdk: lisk-sdk::
:imagesdir: ../../assets/images

:url_ccm: understand-blockchain/interoperability/communication.adoc
:url_ccu: understand-blockchain/interoperability/communication.adoc#-relaying-ccms-in-a-ccu
:url_ccm1: understand-blockchain/interoperability/communication.adoc#inducing_state_changes_across_chains_with_ccms
:url_bls: pages/glossary.adoc#bls
:url_bft_weights: pages/glossary.adoc#bft-weight
:url_outbox_rootwitness: understand-blockchain/interoperability/communication.adoc
:url_sdk_token_module: lisk-sdk::modules/token-module.adoc
//:url_how_blockchain_works: intro/how-blockchain-works.adoc
//:url_transactions: understand-blockchain/lisk-protocol/transactions.adoc

== Overview - What is a Sidechain?

A sidechain is actually a separate blockchain that is attached to its mainchain using a two-way peg.
Sidechains are aligned in parallel with the main blockchain.
Sidechains can facilitate moving digital assets from their origin, namely the original blockchain to a separate blockchain which is known as a sidechain.
Furthermore, it is possible to move these assets back to the original blockchain if necessary, resulting in being able to securely interchange data and assets.
Simply put, a sidechain will allow nodes containing assets or data from the parent blockchain to be securely used in a separate blockchain (the sidechain), and hence, these assets and data can then be transferred back to the original blockchain.
In turn, the advent of sidechains will further increase the performance of the parent blockchain by taking some of the workload, and furthermore this increases the level of security as all transactions that are executed, are secured by the participants (generators/forgers), of the mainchain.

image:understand-blockchain/interop/sidechain.png[, align="center" ,500]

== Sidechains in Lisk

Within the Lisk network, the sidechain technique deployed collects a series of xref:{url_ccm}[cross-chain messages], (CCM) before to executing a transaction.
After these messages reach the receiving platform, they can then be verified and added to the block.

The xref:{url_ccu}[cross-chain update], (CCU) transactions can be considered as the carriers of the information transmitted between different chains.
By posting a cross-chain update, the receiving chain receives the information required about the advancement of the sending chain.
This transaction can also include cross-chain messages, as described below, and thus serves as an envelope for messages from one chain to another.

The cross-chain messages are responsible for verifying the state transition which ensures that the information is valid, and in turn allows for the simple validation of the state of the chain as well as the acceptance into a separate network.
The sidechains function by the way of using certificates to communicate between chains.
Before a transaction can be performed, it is necessary to receive updates from several blocks first, which are then collected and sent to the receiving chain.
This is where cross chain updates (CCUs) are used, as they contain the cross chain messages (CCMs), a certificate, and the necessary information regarding the current validator set of the sending chain.

The system functions whereby the CCUs are then validated in conjunction with the most recent message from the receiving chain.
Hence, this enables the transfer of data and assets to be administered via these messages.

These CCUs are then validated by the receiving chain in accordance with the most recent message, therefore confirming that the afore-mentioned messages were sent.
Further more in-depth information regarding the CCUs and CCMs can be found here on the xref:{url_ccm}[Cross-chain communication page].

== Life Cycle of a Sidechain

The life cycle of a sidechain can be broken down into 3 parts, corresponding to the following 3 values of the account status property: ''registered'', ''active'', and ''terminated''.

Firstly, a sidechain registers on the mainchain with a *sidechain registration command*.
This command creates the sidechain account on the mainchain.
Specifically it creates an entry in the chain data substore, with the initial status set to 'registered'; an entry in the channel data substore, with an empty inbox and outbox; coupled with an entry in the validators data substore, holding the initial sidechain validators set.
Thereafter, the mainchain account is similarly created on a sidechain with a *mainchain registration command*.

After a sidechain has been registered on the mainchain, it cannot receive any cross-chain message and does not need to follow the liveness rule, until the first sidechain CCU has been included in the mainchain.
At this point, the status of the sidechain account on the mainchain is updated to ''active'' and the liveness requirement rule is then enforced.
(The liveness rule requires active sidechains to prove their liveness once every 30 days, or the sidechain account is terminated).

Therefore, if no CCU is received within 30 days, the *chain account is terminated* and no more CCMs can be sent to or received from the sidechain.
A sidechain account can also be terminated if the sidechain posts a CCU containing a CCM with an invalid schema or with an invalid sending chain ID.
A message targeting a terminated chain is bounced on the mainchain instead of being forwarded.
When this happens, a "terminated sidechain" message is emitted by the mainchain, targeting the original sending chain.
When this message is processed, the chain is also terminated in the sending chain, blocking future messages.

When a chain is terminated, a "terminated state" account is created, storing the last certified state root of the terminated chain.
Then, users can recover tokens from the terminated sidechain with a <<State Recovery Command>> or proceed with the <<Message Recovery Initialization Command>> to kick-off the recovery of pending cross-chain messages.
The sidechain termination and recovery process is covered later on this page.

== Sidechain Registration

// Explain why sidechain registration is needed referencing the introduction
// Explain why sidechain will be terminated and how/what can recover from the sidechain

Firstly sidechain registration is required to ultimately ensure interoperability with a separate chain can be achieved with the Lisk mainchain.
In effect this is managed by a registration command that creates a sidechain account within the Lisk mainchain.
This can be thought of as the initial step, being the creation and initiation of the communication channel that is required for two separate, different chains to interoperate and function seamlessly together.
To bring this to fruition a cross channel chain protocol needs to be established, which is the chain registration process defining the necessary protocol rules and data structures.
At this point it should be noted that there are two registration commands which are utilized dependent on whether it is the Lisk mainchain or the sidechain we are dealing with.
To explain this briefly, for the Lisk mainchain the sidechain registration command is used.
From the sidechain perspective, this is performed by the mainchain registration command, both of these are covered further in this section.

== How to register a sidechain

As mentioned in the previous paragraph to enable a sidechain to operate, it first has to be registered in the Lisk mainchain via a sidechain registration command.
This requires that the sidechain registration command is processed, which will then result in the sidechain account status being set to registered.
However, at this point the cross-channel is not active, so it is not possible for any cross-chain messages (CCMs) to be sent yet.

For the processing of this command, it signifies that as sidechain account in the mainchain state exists, and is associated with a name and a unique network identifier.
Therefore, each new sidechain occupies a certain namespace in the ecosystem.

==== Registration Message

The role of the registration message is to allow for a safe activation of the channel between the sending and receiving chains.
It guarantees that when the CCU activating the channel is executed, a registration transaction has been included on the partner chain.
When a sidechain is registered on the mainchain, as previously mentioned, an ecosystem wide chain ID and name are assigned to this chain.
The chain name, network ID, and the token used for the message fees are included in a registration message that is appended to the sidechain outbox.
When the first cross-chain update containing messages is sent to the sidechain, the equality between the properties in the registration message and the ones in the interoperability store is verified.

==== Sidechain Registration Process

Firstly, for a sidechain to be interoperable, it has to be registered in the Lisk mainchain via a <<Sidechain Registration Command>>.
A transaction with this command can be sent by any user account in the Lisk Mainchain that possesses adequate funds to pay the required fee.
The processing of this command signifies the creation of a sidechain account in the mainchain state that is associated with a unique network identifier and a name.
Therefore, each new sidechain occupies a certain namespace in the ecosystem.
Additionally, every newly registered sidechain can increase the size of every cross-chain update command, (CCU) posted on the mainchain (due to the increasing size of the xref:{url_outbox_rootwitness}[outboxRootWitness] property of the command).
For these two reasons, the minimum fee for this command has an added constant similar to the extra fee in a *delegate registration command*.
The value of this extra registration fee is `REGISTRATION_FEE` is LSK.

Once the sidechain registration command is processed, the sidechain account status is set to registered.
In this state, the cross-chain channel is still not active, so the users on the mainchain or other chains cannot send xref:{url_ccm1}[cross-chain messages] (CCMs) to this sidechain yet. Moreover, the *liveness condition* to maintain the channel is not enforced, this means that there is no specific time requirement for a sidechain to be activated on the mainchain, it can stay in the registered status for any period of time.
When a first valid cross-chain update command from this sidechain is processed, the sidechain status is changed to active, making it active in the ecosystem. Now it is possible to send CCMs to the sidechain and the liveness condition is enforced.

=== Sidechain Structure on the Mainchain

As discussed, once a new sidechain is registered on the mainchain by using the registration command, this results in a sidechain account being created in the Lisk mainchain state.
//Therefore, this implies that the corresponding key-value entries for the sidechain are added to the interoperability module store as shown below in Figure 1.
// (LIP 0045 find info on the properties of the interoperability module store to refer to this...)

The values of these entries are initialized, and the `name`, `networkID`, and `initValidators`, properties are computed from the sidechain registration command.

This <<Sidechain Registration Command>> assigns a unique integer as the chain ID that identifies the sidechain in the ecosystem.
Furthermore, new data structures are inserted for the sidechain in the Lisk mainchain state.
This results in a new entry being created in the five different substores of the interoperability module store listed below, and can also be seen in the diagram below in figure 1.

The following substores are used:
*outbox root substore*, *chain data substore*, *channel data substore*, *chain validators substore*, and *registered names*.
//This chain ID integer is also part of the key of the interoperability store entries for the registered sidechain as shown below in Figure 1.
image:understand-blockchain/interop/interoperability-module-store.png[ align="center" ,800]

*Figure 1: The Interoperability module store.*

Each box represents a substore, where we indicate the `storeKey --> storeValue relation`.
For the Lisk mainchain, the 'own chain' substore exists by default in the state whereas there is one entry per registered sidechain for five other substores (outbox root, chain data, channel data, chain validators, registered names), created by a sidechain registration command.
For sidechains, the 'own chain' and one entry for the mainchain account for four other substores (outbox root, chain data, channel data, and chain validators) are created by the <<Mainchain Registration Command>>.

=== Sidechain Registration Command

The sidechain registration command is used to register a sidechain on the Lisk mainchain.
Once this command is processed, a new account for the sidechain is created in the mainchain state under the interoperability store.
The account is initialized with an empty inbox and outbox, while the sidechain name and the initial validators set are given in the command parameters.
The network ID is calculated from the address of the command sender and the genesis block ID, also given in the command parameters.

In order to connect a new sidechain into the ecosystem, the sidechain registration command contains the following parameters:

* *name*

The `name` property sets the name of the sidechain as a string of characters, and has to be unique within the Lisk ecosystem, and contain only characters from the set *a-z0-9!@$&_.*

* *initValidators*

The `initValidators` property defines the set of eligible xref:{url_bls}[BLS public keys] with their respective xref:{url_bft_weights}[BFT weights] required to sign the first certificate from the sidechain.

* *certificateThreshold*

The `certificateThreshold` property is an integer setting the minimum signatures weight required for the first sidechain certificate to be valid.

* *sidechainRegistrationFee*

The `sidechainRegistrationFee` property accounts for the extra fee required to register the sidechain. It should be set to the value of the `REGISTRATION_FEE` constant.

* *Chain ID*

The `Chain ID` is responsible for uniquely identifying a chain in the Lisk ecosystem .
Just as addresses are used for identification for the user accounts, the chain ID has a similar purpose.
When processing the sidechain registration command, the chain ID for a sidechain is deterministically computed.
Specifically, the chain ID of a new sidechain is assigned as an incremental integer similar to transaction nonces.
The format of chain IDs aims to provide an efficient and compact way to uniquely identify chains in the ecosystem.
Furthermore, an additional advantage, is that it is easy to remember the integer assigned as the chain ID for a users favorite blockchain application.

The chain ID is a 4-byte constant set in the chain configuration.
Chain IDs serve the following two purposes:

*(1)* Chain IDs are prepended to the input of the signing function of every transaction, block, or message of the chain to avoid transaction replays between different chains in the ecosystem.

*(2)* Chain IDs uniquely identify a chain in the Lisk ecosystem.
Specifically in the Interoperability module, it serves a similar purpose for chains as addresses do for user accounts, as it is used to identify the chain account in the Interoperability module store.
Furthermore, the chain ID has to be stated in every cross-chain interaction.
For example, it has to be specified in the `receivingChainID` property of a CCM to this sidechain and in the `sendingChainId property` of a cross-chain update command from this sidechain.

In the sidechain registration command the sidechain ID is given as a parameter.
In the case whereby the given value is already taken by another sidechain, the sidechain registration fails.
Therefore, the sidechain has to change the chain ID with a hardfork, and resubmit the sidechain registration command with a new value.
The chain identifiers are of a value of 4-bytes, and dependent on the network on which the chain is running, the first byte must always be set to the correct value.

An example can be seen below in the following table depicting the chain-identifiers prefixes currently specified.
The first byte is set to  `CHAIN_ID_PREFIX_MAINNET` for chains running in the mainnet network and to `CHAIN_ID_PREFIX_TESTNET` for chains running in the testnet network.
The other 3 bytes must be uniquely chosen for the respective blockchain, hence, no other blockchain created with the Lisk SDK should use the same 3 bytes.

[cols="2,1,2,4"]
|===
|Name|Type|Value|Description
|`CHAIN_ID_PREFIX_MAINNET`|bytes|0x00|Chain-identifier prefix for mainnet blockchains.
|`CHAIN_ID_PREFIX_TESTNET`|bytes|0x01|Chain-identifier prefix for testnet blockchains.
|===

The chain ID is known to the mainchain as soon as the sidechain is registered, therefore it can validate cross-chain update commands coming from the sidechain without any further context.

=== Sidechain Network Identifier

The network identifier, or network ID, is a byte sequence unique to a chain that has to be prepended to the input of the signing function of every transaction, block, or message of the chain.
It is necessary to avoid transaction replays between different chains in the ecosystem.

In the Lisk ecosystem, the network ID for a sidechain is computed as the hash digest of the sidechain genesis block ID given in a transaction with the registration command and the address of the account sending this transaction.
This is beneficial, as sidechain developers can pre-compute the network ID of their sidechain as soon as they set the genesis block and an account to send the transaction on the mainchain.
It is then possible to start the sidechain at this point without being registered on the mainchain.
In addition, the network ID is known to the mainchain as soon as the sidechain is registered, therefore it can validate cross-chain update commands coming from the sidechain without any further context.

Note that in the case of a sidechain undergoing a community hard fork, one of the competing forks will need to register their fork of the sidechain again on the Lisk Mainchain.
Regardless of the genesis block ID set by this sidechain fork, it has to be registered from a different user account which implies that the chain ID and network ID of the forked chain will be different from the original one.

=== Mainchain Registration on a Sidechain

Once the sidechain has been registered on the mainchain, a similar registration process should happen in the sidechain before the interoperable channel is opened between the two chains.
This is performed by submitting a transaction with the mainchain registration command in the sidechain, which implies the creation of a mainchain account in the sidechain state associated with the Lisk mainchain, and other structures needed for interoperability.
This mainchain account has a similar structure as the one depicted in Figure 1 above.
By protocol, the chain ID of the mainchain is a constant equal to `CHAIN_ID_MAINCHAIN` in the ecosystem.

This registration process always has to occur after the sidechain registration on the mainchain, since the sidechain has no prior knowledge of the current mainchain validators or its name.
Similar to the sidechain registration case, the mainchain account status will not change to active until a valid cross-chain update command from the mainchain containing a valid registration xref:{url_ccm}[CCM] is processed.

=== Mainchain Registration Command

The mainchain registration command is used to register the Lisk mainchain on a sidechain.
When this command is processed, a new account for the mainchain is created in the sidechain state under the interoperability store.

Certain parameters are set by the mainchain registration command in the sidechain that are related to the interoperability module, and also initializes the corresponding mainchain data structures.
This command requires the approval of the sidechain validators, as they have to agree on the content of this command and add their aggregated signatures accordingly.
It is of key importance that the sidechain validators ensure that they are signing the registration command wth the correct information, otherwise the sidechain interoperable functionality may be unusable.

There is not a minimum fee requirement for this command, as it should only be submitted once in a sidechain and approved by a majority of validators.
Taking this into account, a transaction with this command should be treated differently in terms of priority in case it is included in a sidechain node's transaction pool.
Hence, it is recommended that once the transaction is correctly signed by the validators and ready to be submitted, a validator simply includes it in its next forged block, without including it in the transaction pool.
The command has the following parameters:

* *ownChainID*

The chain ID set on the mainchain after processing the corresponding sidechain registration command.

* *ownName*

The `ownName` property sets the name of the sidechain in its own state according to the name given in the mainchain.

* *mainchainValidators*

This is similar to the `initValidators` property in the sidechain registration command, it defines the set of mainchain validators with their respective xref:{url_bft_weights}[BFT weight] expected to sign the first certificate from the mainchain.

* *signature*

The `signature` property is an aggregated signature of the sidechain validators.
It ensures that the sidechain validators agree on registering the mainchain in the sidechain.

* *aggregationBits*

The `aggregationBits` property is a bit vector used to validate the aggregated signature.

=== Sidechain Registration Transaction Commands

Firstly, the transactions executing the sidechain registration command and the required parameters, verification and execution are listed below:

* `module = MODULE_NAME_INTEROPERABILITY`
* `command = COMMAND_SIDECHAIN_REG`

.Sidechain Parameters
[%collapsible]
====
[source,js]
----
sidechainRegParams = {
    "type": "object",
    "required": [
        "name",
        "chainID",
        "initValidators",
        "certificateThreshold",
        "sidechainRegistrationFee"
    ],
    "properties": {
        "name": {
            "dataType": "string",
            "minLength": MIN_CHAIN_NAME_LENGTH,
            "maxLength": MAX_CHAIN_NAME_LENGTH,
            "fieldNumber": 1
        },
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 2
        },
        "initValidators": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "required": ["blsKey", "bftWeight"],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "length": BLS_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "certificateThreshold": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "sidechainRegistrationFee": {
            "type": "uint64",
            "fieldNumber": 5
        }
    }
}
----
.Verification

[source,js]
----
def verify(trs: Transaction) -> None:
    # The name property has to contain only characters from the set [a-z0-9!@$&_.].
    if not re.match(r"^[a-z0-9!@$&_.]+$", trs.params.name):
        raise Exception("Invalid name property. It should contain only characters from the set [a-z0-9!@$&_.].")
    # The name property has to be unique with respect to the set of already registered sidechain names.
    if there exists an entry in the registered names substore with store key equal to trs.params.name.encode("utf-8"):
        raise Exception("Name already registered.")

    # Chain ID has to be unique with respect to the set of already registered sidechains.
    if there exists an entry in the chain data substore with store key equal to trs.params.chainID:
        raise Exception("Chain ID already registered.")

    # Check that the first byte of the chainID, indication the network, matches.
    if trs.params.chainID[0] != CHAIN_ID_MAINCHAIN[0]:
        raise Exception("Chain ID does not match the mainchain network.")

    # initValidators must have at least 1 element and at most MAX_NUM_VALIDATORS elements.
    if len(trs.params.initValidators) < 1 or len(trs.params.initValidators) > MAX_NUM_VALIDATORS:
        raise Exception(f"Invalid initValidators array. It must have at least 1 element and at most {MAX_NUM_VALIDATORS} elements.")

    validatorKeys = [validator.blsKey for validator in trs.params.initValidators]
    # All validator keys must be distinct.
    if len(validatorKeys) != len(set(validatorKeys)):
        raise Exception("Duplicate BLS keys.")

    # Validator keys must be in lexicographic order.
    if not all(validatorKeys[i] < validatorKeys[i + 1] for i in range(len(validatorKeys) - 1)):
        raise Exception("Validator keys are not in lexicographic order.")

    totalWeight = 0
    for validator in trs.params.initValidators:
        # The bftWeight property of each element is a positive integer.
        if validator.bftWeight == 0:
            raise Exception("Invalid bftWeight property.")
        totalWeight += validator.bftWeight
    # Total BFT weight has to be less than or equal to MAX_UINT64.
    if totalWeight > MAX_UINT64:
        raise Exception("Total BFT weight exceeds maximum value.")

    # The range of valid values of the certificateThreshold property is given by the total sum of the validators weights:
    # Minimum value: floor(1/3 * total BFT weight) + 1.
    # Maximum value = total BFT weight.
    if trs.params.certificateThreshold < totalWeight//3 + 1:
        raise Exception("Certificate threshold is too small.")
    if trs.params.certificateThreshold > totalWeight:
        raise Exception("Certificate threshold is too large.")

    # sidechainRegistrationFee must equal REGISTRATION_FEE.
    if trs.params.sidechainRegistrationFee != REGISTRATION_FEE:
        raise Exception("Invalid extra command fee.")
    # Sender must have enough balance to pay for extra command fee.
    senderAddress = sha256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    if Token.getAvailableBalance(senderAddress, TOKEN_ID_LSK_MAINCHAIN) < REGISTRATION_FEE:
        raise Exception("Sender does not have enough balance.")
----
.Execution

[source,js]
----
def execute(trs: Transaction) -> None:
    senderAddress = sha256(trs.senderPublicKey)[:ADDRESS_LENGTH]

    # Create chain account.
    sidechainAccount = {
        "name": trs.params.name,
        "lastCertificate": {
            "height": 0,
            "timestamp": 0,
            "stateRoot": EMPTY_HASH,
            "validatorsHash": computeValidatorsHash(trs.params.initValidators, trs.params.certificateThreshold)
        },
        "status": CHAIN_STATUS_REGISTERED
    }

    chainID = trs.params.chainID
    create an entry in the chain data substore with
        storeKey = chainID,
        storeValue = encode(chainAccountSchema, sidechainAccount)

    # Create channel.
    sidechainChannel = {
        "inbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "outbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "partnerChainOutboxRoot": EMPTY_HASH,
        "messageFeeTokenID": TOKEN_ID_LSK_MAINCHAIN
    }
    create an entry in the channel data substore with
        storeKey = chainID
        storeValue = encode(channelSchema, sidechainChannel)

    # Create validators account.
    sidechainValidators = {
        "activeValidators": trs.params.initValidators,
        "certificateThreshold": trs.params.certificateThreshold
    }
    create an entry in the chain validators data substore with
        storeKey = chainID
        storeValue = encode(validatorsSchema, sidechainValidators)

    # Create outbox root entry.
    create an entry in the outbox root substore with
        storeKey = chainID
        storeValue = encode(outboxRootSchema, {"root": sidechainChannel.outbox.root})

    # Create registered names entry.
    create an entry in the registered names substore with
        storeKey = trs.params.name
        storeValue = encode(chainIDSchema, {"chainID": chainID})

    # Burn the registration fee.
    Token.burn(senderAddress, TOKEN_ID_LSK_MAINCHAIN, REGISTRATION_FEE)

    # Emit chain account updated event.
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CHAIN_ACCOUNT_UPDATED,
        data = sidechainAccount,
        topics = [chainID]
    )

    # Send registration CCM to the sidechain.
    registrationCCMParams = {
        "chainID": chainID,
        "name": trs.params.name,
        "messageFeeTokenID": sidechainChannel.messageFeeTokenID
    }

    ccm = {
        "nonce": ownChainAccount.nonce,
        "module": MODULE_NAME_INTEROPERABILITY,
        "crossChainCommand": CROSS_CHAIN_COMMAND_REGISTRATION,
        "sendingChainID": ownChainAccount.chainID,
        "receivingChainID": chainID,
        "fee": 0,
        "status": CCM_STATUS_CODE_OK,
        "params": encode(registrationCCMParamsSchema, registrationCCMParams) # registrationCCMParamsSchema is defined in LIP0049
    }

    addToOutbox(chainID, ccm)
    ownChainAccount.nonce += 1

    # Emit CCM Processed Event.
    ccmID = sha256(encode(crossChainMessageSchema, ccm))
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CCM_SEND_SUCCESS,
        data = {"ccmID": ccmID},
        topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
    )
----
====

=== Mainchain Registration Transaction Commands

Secondly, the transactions executing the mainchain registration command and the required parameters, verification and execution are listed below:

* `module = MODULE_NAME_INTEROPERABILITY`
* `command = COMMAND_MAINCHAIN_REG`

.Mainchain Parameters
[%collapsible]
====
[source,js]
----
mainchainRegParams = {
"type": "object",
"required": [
"ownChainID",
"ownName",
"mainchainValidators",
"signature",
"aggregationBits"
],
"properties": {
"ownChainID": {
"dataType": "bytes",
"length": CHAIN_ID_LENGTH,
"fieldNumber": 1
},
"ownName": {
"dataType": "string",
"minLength": MIN_CHAIN_NAME_LENGTH,
"maxLength": MAX_CHAIN_NAME_LENGTH,
"fieldNumber": 2
},
"mainchainValidators": {
"type": "array",
"fieldNumber": 3,
"items": {
"type": "object",
"required": ["blsKey", "bftWeight"],
"properties": {
"blsKey": {
"dataType": "bytes",
"length": BLS_PUBLIC_KEY_LENGTH,
"fieldNumber": 1
},
"bftWeight": {
"dataType": "uint64",
"fieldNumber": 2
}
}
}
},
"signature": {
"dataType": "bytes",
"length": BLS_SIGNATURE_LENGTH,
"fieldNumber": 4
},
"aggregationBits": {
"dataType": "bytes",
"fieldNumber": 5
}
}
}
----
.Verification

[source,js]
----
def verify(trs: Transaction) -> None:
# The ownChainID property has to match with the chain identifier.
chainID = chain identifier of the current chain
if trs.params.ownChainID != chainID:
raise Exception("Invalid ownChainID property.")

    # The ownName property has to contain only characters from the set [a-z0-9!@$&_.].
    if not re.match(r"^[a-z0-9!@$&_.]+$", trs.params.ownName):
        raise Exception("Invalid ownName property. It should contain only characters from the set [a-z0-9!@$&_.].")

    # mainchainValidators must have exactly MAINCHAIN_NUMBER_ACTIVE_VALIDATORS elements.
    if len(trs.params.mainchainValidators) != MAINCHAIN_NUMBER_ACTIVE_VALIDATORS:
        raise Exception(f"Invalid mainchainValidators property. It must have exactly {MAINCHAIN_NUMBER_ACTIVE_VALIDATORS} elements.")

    validatorKeys = [validator.blsKey for validator in trs.params.mainchainValidators]
    # All validator keys must be distinct.
    if len(validatorKeys) != len(set(validatorKeys)):
        raise Exception("Duplicate BLS keys.")

    # Validator keys must be in lexicographic order.
    if not all(validatorKeys[i] < validatorKeys[i + 1] for i in range(len(validatorKeys) - 1)):
        raise Exception("Validator keys are not in lexicographic order.")

    for validator in trs.params.initValidators:
        # The bftWeight property of each element is equal to 1.
        if validator.bftWeight != 1:
            raise Exception("Invalid bftWeight property.")
----
.Execution

[source,js]
----

def execute(trs: Transaction) -> None:
# Check signature property.
height = height of the block in which trs was included
sidechainValidators = validatorsModule.getCurrentValidators()
certificateThreshold = validatorsModule.getCertificateThreshold()
# Sort sidechainValidators by BLS key.
sidechainValidators.sort(key=lambda v: validatorsModule.getValidatorAccount(v.address).blsKey)
blsKeys = [validatorsModule.getValidatorAccount(v.address).blsKey for v in sidechainValidators]
bftWeights = [v.bftWeight for v in sidechainValidators]

    registrationSignatureMessageSchema = {
        "type": "object",
        "required": ["ownChainID", "ownName", "mainchainValidators"],
        "properties": {
            "ownChainID": {
                "dataType": "bytes",
                "length": CHAIN_ID_LENGTH,
                "fieldNumber": 1
            },
            "ownName": {
                "dataType": "string",
                "minLength": MIN_CHAIN_NAME_LENGTH,
                "maxLength": MAX_CHAIN_NAME_LENGTH,
                "fieldNumber": 2
            },
            "mainchainValidators": {
                "type": "array",
                "fieldNumber": 3,
                "items": {
                    "type": "object",
                    "required": ["blsKey", "bftWeight"],
                    "properties": {
                        "blsKey": {
                            "dataType": "bytes",
                            "length": BLS_PUBLIC_KEY_LENGTH,
                            "fieldNumber": 1
                        },
                        "bftWeight": {
                            "dataType": "uint64",
                            "fieldNumber": 2
                        }
                    }
                }
            }
        }
    }

    message = encode(registrationSignatureMessageSchema,
        {
        "ownChainID": trs.params.ownChainID,
        "ownName": trs.params.ownName,
        "mainchainValidators": trs.params.mainchainValidators
        }
    )

    # verifyWeightedAggSig is specified in LIP 0062.
    if verifyWeightedAggSig(blsKeys, MESSAGE_TAG_CHAIN_REG, trs.params.ownChainID, trs.params.aggregationBits, trs.params.signature, bftWeights, certificateThreshold, message) == False:
        emitPersistentEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_INVALID_REGISTRATION_SIGNATURE,
            data = {},
            topics = [trs.params.ownChainID]
        raise Exception("Invalid signature property.")

    # Create chain account.
    mainchainAccount = {
        "name": CHAIN_NAME_MAINCHAIN,
        "lastCertificate": {
            "height": 0,
            "timestamp": 0,
            "stateRoot": EMPTY_HASH,
            "validatorsHash": computeValidatorsHash(trs.params.mainchainValidators, THRESHOLD_MAINCHAIN)
        },
        "status": CHAIN_STATUS_REGISTERED
    }
    create an entry in the chain data substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(chainAccountSchema, mainchainAccount)

    # Create channel.
    mainchainChannel = {
        "inbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "outbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_HASH
        },
        "partnerChainOutboxRoot": EMPTY_HASH,
        "messageFeeTokenID": TOKEN_ID_LSK_MAINCHAIN
    }
    create an entry in the channel data substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(channelSchema, mainchainChannel)

    # Create validators account.
    mainchainValidators = {
        "activeValidators": trs.params.mainchainValidators,
        "certificateThreshold": THRESHOLD_MAINCHAIN
    }
    create an entry in the chain validators data substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(validatorsSchema, mainchainValidators)

    # Create outbox root entry.
    create an entry in the outbox root substore with
        storeKey = CHAIN_ID_MAINCHAIN
        storeValue = encode(outboxRootSchema, {"root": mainchainChannel.outbox.root})

    # Create own chain account.
    ownChainAccount = {
        "name": trs.params.ownName,
        "chainID": trs.params.ownChainID,
        "nonce": 0
    }
    create an entry in the own chain data substore with
        storeKey = EMPTY_BYTES
        storeValue = encode(ownChainAccountSchema, ownChainAccount)

    # Emit chain account updated event.
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CHAIN_ACCOUNT_UPDATED,
        data = mainchainAccount,
        topics = [CHAIN_ID_MAINCHAIN]
    )

    # Send registration CCM to the mainchain.
    # Notice that we do not use the send function because the channel
    # has not been activated yet.
    registrationCCMParams = {
        "chainID": CHAIN_ID_MAINCHAIN,
        "name": CHAIN_NAME_MAINCHAIN,
        "messageFeeTokenID": mainchainChannel.messageFeeTokenID
    }

    ccm = {
        "nonce": ownChainAccount.nonce,
        "module": MODULE_NAME_INTEROPERABILITY,
        "crossChainCommand": CROSS_CHAIN_COMMAND_REGISTRATION,
        "sendingChainID": ownChainAccount.chainID,
        "receivingChainID": CHAIN_ID_MAINCHAIN,
        "fee": 0,
        "status": CCM_STATUS_CODE_OK,
        "params": encode(registrationCCMParamsSchema, registrationCCMParams) # registrationCCMParamsSchema is defined in LIP0049
    }

    # We cannot use the send function because the channel is not active yet.
    addToOutbox(CHAIN_ID_MAINCHAIN, ccm)
    ownChainAccount.nonce += 1

    # Emit CCM Processed Event.
    ccmID = sha256(encode(crossChainMessageSchema, ccm))
    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CCM_SEND_SUCCESS,
        data = {"ccmID": ccmID},
        topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
    )
----
====





== Sidechain termination


Once a sidechain is terminated, it is not possible to send or receive cross-chain messages anymore.
Therefore, the ability of a sidechain to interoperate with other chains can be revoked, i.e., terminated, permanently.
In effect, the sidechain is disconnected from the rest of the ecosystem, and any assets (e.g. fungible or non-fungible tokens), cannot be moved either to or from the respective sidechain.
Therefore, this means that users will not be able to send any assets that they originally held on the sidechain, back to the original native chain, in other words, the chain where the assets were initially created.

The following section covers the recovery mechanism deployed by Lisk to address this problem, which will noticeably improve the user experience of the Lisk ecosystem without affecting the security guarantees of the general interoperability solution.
Using dedicated commands that are part of the Interoperability module, users can recover their assets directly on the native chain.
Furthermore, pending messages that were stuck unprocessed in the outbox of the terminated chain can be recovered as well, and their effect reverted on the sending chain.

Sidechain termination specifically occurs when the sidechain in question has been inactive for too long.
For example, this could be caused by not posting a transaction with a cross-chain update (CCU), command for more than 30 days, or in the case whereby one was posted with a malicious CCU command on the mainchain.
Hence, it is useful to provide a trustless on-chain mechanism to recover tokens, messages, and information from terminated sidechains.

=== Termination causes

A sidechain can be terminated for various reasons as described below in the following paragraphs.

* Liveness requirement

As previously mentioned, active sidechains are required to prove they are still live and functioning by posting a CCU at least once within a 30 day time period.
Therefore violating the liveness requirement (only on the mainchain), result in terminating the sidechain.
This rule guarantees that users do not send funds to inactive sidechains, and that users who have tokens in a sidechain which stops communicating with the ecosystem can recover their tokens.

* Violation of Token-Module Protocol

With regard to the xref:{url_sdk_token_module}[token module], when tokens are transferred across the ecosystem, the native chain of the token keeps track of their location in an escrow account.
When tokens are returned back from a chain, the amount stored in the escrow account is reduced, hence ensuring that no extra tokens were minted in the other chain.

However, if a cross-chain message tries to transfer back an amount of tokens greater than the one stored in the escrow account, the sending chain is terminated and a terminated state account is created.
If the native chain is the mainchain (hence, the token is the LSK token), the terminated state account stores the state root of the sidechain; otherwise it stores the root of the mainchain, which can then be used to initialize the recovery with a state recovery initialization command.

// why  sidechain will be termnated..?wwwww



== How to recover information from a sidechain
// Explain steps to recover information from sidechain

The commands introduced to the Lisk ecosystem to provide a recovery mechanism for sidechain users are part of the Interoperability module (add link).



* On the Lisk mainchain:

The users can recover the balance of LSK they had on a terminated sidechain by submitting a transaction with a <<State Recovery Command>>.
The users can recover a pending cross-chain message (CCM) from the sidechain account outbox by submitting a transaction with a <<Message Recovery Command>> on the Lisk mainchain.

* On sidechains:

The users can recover the balance of any custom token they had on a terminated sidechain by submitting a transaction with a state recovery command.
The users can recover any NFT they had on a terminated sidechain by submitting a transaction with a state recovery command.
The stored data of certain custom modules can be recovered from a terminated sidechain by submitting a transaction with a state recovery command.

=== State recovery from the Sidechain Root


xxx

==== State Recovery Initialization Command

xx add in basic description, then command ID and schema and state recovery initialization command validation

=== Sidechain Terminated Message

The role of the sidechain terminated message is to inform sidechains that another sidechain has been terminated on the mainchain, and is unable to receive messages.
The message contains the ID of the terminated chain as well as the last certified state root of the terminated sidechain (as certified on the mainchain).
This value is used for the creation of the terminated state account (on the sidechain receiving the CCM), allowing state recoveries.
This message allows to inform sidechains about other terminated sidechains efficiently.
Subsequently, this message will automatically trigger the creation of the terminated sidechain account as soon as the first message is unable to be delivered.
This also prevents further messages to be sent to sidechains that have already been terminated.

when a CCM reaches a receiving chain that has been terminated, a sidechain terminated message is created and sent back to the sending chain carrying the `stateRoot` of the terminated sidechain.
The application of this CCM on the sidechain will effectively initiate the recovery process.

==== State Recovery Command

This command is used to recover a certain state (for example fungible and non-fungible tokens) from a sidechain that has been terminated.
The user proves the existence of an entry in the terminated state substore with an inclusion proof.
The proof is validated against the current state root stored in the terminated chain account.
The recovery of the state is then handled by the relevant module (for example the token module would refund the user).

xx (Add in description, and  command ID, params, and state recovery command schema)

ten state recovery command verification (and code) and state recovery execution
then recover function then state recovery initialization command execution

==== Message Recovery Command

xxx add in basic description first,, then go to message recovery command id, and schema and message recovery command verification and message recovery execution

==== Message Recovery Initialization Command

xx dsescription, command ID and schema and message recovery initialization command validation and executin

==== Message Recovery from the Sidechain Account Outbox

add in diagram from lip 54 message recovery command

==== Recovery Commands as an Off-chain Service

==== (Add in tabbel of constants)
