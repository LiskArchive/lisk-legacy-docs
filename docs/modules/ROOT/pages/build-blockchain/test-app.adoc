= Testing the blockchain application
Muhammad Talha <muhammad.talha@lightcurve.io>
// Settings
:toc: preamble
:docs_sdk: lisk-sdk::
// URLs
:url_github_guides_tests: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/guides/04-plugin/hello_app/test
// Project URLs
:url_reducerhandler: understand-blockchain/sdk/modules-commands.adoc#the-reducerhandler
:url_guides_setup: build-blockchain/create-blockchain-client.adoc
:url_guides_module: build-blockchain/module/index.adoc
:url_guides_asset: build-blockchain/module/command.adoc
:url_intro_modules_statestore: understand-blockchain/sdk/modules-commands.adoc#the-state-store
:url_tutorials_nft: tutorial/nft.adoc
:url_reference_test_suite: {docs_sdk}references/test-utils.adoc

How to use the test utility of the Lisk SDK to test your application.

.Sample code
[NOTE]
====
View the complete sample code of this guide on GitHub in the {url_github_guides_tests}[Lisk SDK examples repository^].
====

.Prerequisites
[NOTE]
====
To use this guide, it is assumed that the following criteria have been met:

* Lisk Commander is installed, and a basic blockchain application is already initialized, as explained in the guide xref:{url_guides_setup}[].
* A new module has been generated as described in the guide xref:{url_guides_module}[].
* A new asset has been generated as described in the guide xref:{url_guides_asset}[].
====

To conveniently test the functionality of modules, plugins, or assets, adjust the already generated test skeletons in the `test` folder of your application.

After generating a new module and asset, the corresponding skeletons for their unit tests can be found under `test/unit/modules/module_name`:

./new_app/test/
----
├── integration
├── network
├── unit
│   └── modules
│   │   └── hello
│   │       ├── commands
│   │       │   └── create_hello_command.spec.ts
│   │       └── module.spec.ts
│   └── plugins
│       └── hello_info
│           └── hello_info_plugin.spec.ts
├── utils
│   └── config.ts
├── _setup.js
├── .eslintrc.js
└── tsconfig.json
----

== Running the test suite

It is already possible to run the test at this point, though only the most basic tests will be implemented.

To run all test suites, execute the following:

./new_app/
[source,bash]
----
yarn run test
----

The test results can then be viewed in the console:

----
yarn run v1.22.19
warning ../../../../../../package.json: No license field
$ jest --passWithNoTests
ts-jest[versions] (WARN) Version 5.0.2 of typescript installed has not been tested with ts-jest. If you're experiencing issues, consider using a supported version (>=4.3.0 <5.0.0-0). Please do not report issues in ts-jest if you are using unsupported versions.
ts-jest[versions] (WARN) Version 5.0.2 of typescript installed has not been tested with ts-jest. If you're experiencing issues, consider using a supported version (>=4.3.0 <5.0.0-0). Please do not report issues in ts-jest if you are using unsupported versions.
ts-jest[versions] (WARN) Version 5.0.2 of typescript installed has not been tested with ts-jest. If you're experiencing issues, consider using a supported version (>=4.3.0 <5.0.0-0). Please do not report issues in ts-jest if you are using unsupported versions.
 PASS  test/unit/modules/hello/module.spec.ts
 PASS  test/unit/plugins/hello_info/hello_info_plugin.spec.ts
 PASS  test/unit/modules/hello/commands/create_hello_command.spec.ts
 › 1 snapshot written.

Snapshot Summary
 › 1 snapshot written from 1 test suite.

Test Suites: 3 passed, 3 total
Tests:       16 todo, 2 passed, 18 total
Snapshots:   1 written, 1 total
Time:        2.513 s
Ran all test suites.
✨  Done in 4.21s.
----

// [TIP]

// ====
// If the tests of the asset fails, e.g. with the following error:

//  'asset' is declared but its value is never read.

// This is most likely due to the fact that the `validate()` or `apply()` function of the asset isn't implemented yet.
// To fix the error, either remove the unused variables or implement logic which uses them in the corresponding function.
// ====

== The module test skeleton

The test skeleton of a module doesn't contain any real tests in the beginning.

Use the existing structure to implement the tests required for the module, and add more tests as needed.

.test/unit/modules/hello/hello_module.spec.ts
[source,typescript]
----
// import * as modules from '../../../src/app/modules/hello'

describe('HelloModule', () => {
	describe('constructor', () => {
		it.todo('should have valid name');
	});

	describe('beforeTransactionsExecute', () => {
		it.todo('should execute before block execute');
	});
	describe('afterTransactionsExecute', () => {
		it.todo('should execute after block execute');
	});
	describe('beforeCommandExecute', () => {
		it.todo('should execute before transaction execute');
	});
	describe('afterCommandExecute', () => {
		it.todo('should execute after transaction execute');
	});
	describe('beforeTransactionsExecute', () => {
		it.todo('should execute after genesis execute');
	});
	describe('afterTransactionsExecute', () => {
		it.todo('should execute after genesis execute');
	});
});
----

== The command test skeleton

The test skeleton for the command already contains a few simple tests right from the beginning.
They were automatically created during the xref:{url_guides_asset}[generation of the command].
The remainder of the tests will need to be created by the developer, in order to test all the custom logic of the command which was implemented after the initialization of the application.

.test/unit/modules/hello/create_hello_command.spec.ts
[source,typescript]
----
import { NamedRegistry } from 'lisk-sdk';
import { CreateHelloCommand } from '../../../../../src/app/modules/test/commands/create_hello_command';

describe('CreateHelloCommand', () => {
	let command: CreateHelloCommand;

	beforeEach(() => {
		command = new CreateHelloCommand(new NamedRegistry(), new NamedRegistry());
	});

	describe('constructor', () => {
		it('should have valid name', () => {
			expect(command.name).toEqual('createHello');
		});

		it('should have valid schema', () => {
			expect(command.schema).toMatchSnapshot();
		});
	});

	describe('verify', () => {
		describe('schema validation', () => {
			it.todo('should throw errors for invalid schema');
			it.todo('should be ok for valid schema');
		});
	});

	describe('execute', () => {
		describe('valid cases', () => {
			it.todo('should update the state store');
		});

		describe('invalid cases', () => {
			it.todo('should throw error');
		});
	});
});
----

== Writing unit tests

This example shows how to write unit tests for the module and command from the previous guide xref:{url_guides_asset}[].

[TIP]

====
For more information about the different features of the test suite, check out the reference page xref:{url_reference_test_suite}[]
====

=== Unit tests for the transaction command

==== Imports

Add the following lines at the top of `create_hello_command.spec.ts` to import the required resources for the tests.

[source,typescript]
----
import { NamedRegistry, testing, codec, cryptography, Transaction, chain, db, VerifyStatus } from 'lisk-sdk';
import { CreateHelloCommand } from '../../../../../src/app/modules/hello/commands/create_hello_command';
import { CreateHelloParams, createHelloSchema } from '../../../../../src/app/modules/hello/schema';
import { ModuleConfig } from '../../../../../src/app/modules/hello/types';
----

// <1> `CreateHelloAsset`: The asset which is tested here.
// <2> The following is imported from the `lisk-sdk` package:

// * `testing` contains the functions of the Lisk SDk test suite.
// * `StateStore`: See xref:{url_intro_modules_statestore}[the state store].
// * `ReducerHandler`: See xref:{url_reducerhandler}[ReducerHandler].
// * `codec`: contains functions for encoding and decoding data.


// <3> `HelloModule`: is used in `createDefaultAccount()` to create a default account with the correct account properties.

==== Testing the verify() function

As a reminder, the `verify()` function of the command `CreateHelloCommand` is shown below:

.`validate()` function of `create_hello_command.ts`
[source,typescript]
----
	public async verify(context: CommandVerifyContext<Params>): Promise<VerificationResult> {
		const wordList = context.params.message.split(" ");
		const found = this._blacklist.filter(value => wordList.includes(value));
		if (found.length > 0) {
			context.logger.info("==== FOUND: Message contains a blacklisted word ====");
			const error = Error(
				`Illegal word in hello message: ${found.toString()}`
			);
			return {
				status: VerifyStatus.FAIL,
				error,
			};
		}
		context.logger.info("==== NOT FOUND: Message contains no blacklisted words ====");
		return {
			status: VerifyStatus.OK
		};
	}
----

To verify that the function is implemented correctly, write 2 tests to check if the following occurs:

. An error is thrown, if the hello message equals some illegal statement
. No error is thrown for a valid schema

The function `createValidateAssetContext()` is used for both tests to create a context for the `validate()` function.

In the first test, where an error is expected, a context with an invalid `asset` parameter with the `helloString: 'Some illegal statement'` is created, whereas in the second test a valid `helloString` property is passed.

After the context is created, both tests will call the `validate()` function with the context and the result is checked.

If all tests pass, this verifies that the `validate()` function behaves exactly as expected.

.Tests for `verify()`
[source,typescript]
----
	describe('verify', () => {
		it('Illegal Message', async () => {
			const IllegalParam = codec.encode(createHelloSchema, { 'message': "badWord2" })
			const transaction = new Transaction(getSampleTransaction(IllegalParam));

			const context = testing
				.createTransactionContext({
					stateStore,
					transaction,
					header: testing.createFakeBlockHeader({}),
				})
				.createCommandVerifyContext<CreateHelloParams>(createHelloSchema);

			const result = await command.verify(context);
			expect(result.status).toBe(VerifyStatus.FAIL);
		});

		it('Legal Message', async () => {
			const LegalParam = codec.encode(createHelloSchema, { 'message': "Hello Lisk v6 " })
			const transaction = new Transaction(getSampleTransaction(LegalParam));

			const context = testing
				.createTransactionContext({
					stateStore,
					transaction,
					header: testing.createFakeBlockHeader({}),
				})
				.createCommandVerifyContext<CreateHelloParams>(createHelloSchema);

			const result = await command.verify(context);
			expect(result.status).toBe(VerifyStatus.OK);
		});
	});
----

==== Testing the execute() function

As a reminder, the `execute()` function of the asset `createHelloCommand` is shown below:

.`execute()` function of `create_hello_command.ts`
[source,typescript]
----
public async execute(context: CommandExecuteContext<Params>): Promise<void> {
    // 1. Get account data of the sender of the Hello transaction.
    const { senderAddress } = context.transaction;
    // 2. Get message and counter stores.
    const messageSubstore = this.stores.get(MessageStore);
    const counterSubstore = this.stores.get(CounterStore);

    // 3. Save the Hello message to the message store, using the senderAddress as key, and the message as value.
    await messageSubstore.set(context, senderAddress, {
        message: context.params.message,
    });

    // 3. Get the Hello counter from the counter store.
    let helloCounter: CounterStoreData;
    try {
        helloCounter = await counterSubstore.get(context, counterKey);
    } catch (error) {
        helloCounter = {
            counter: 0,
        }
    }
    // 5. Increment the Hello counter +1.
    helloCounter.counter += 1;

    // 6. Save the Hello counter to the counter store.
    await counterSubstore.set(context, counterKey, helloCounter);

    // 7. Emit a "New Hello" event
    const newHelloEvent = this.events.get(NewHelloEvent);
    newHelloEvent.add(context, {
        senderAddress: context.transaction.senderAddress,
        message: context.params.message
    }, [context.transaction.senderAddress]);
}
----

To verify that the function is implemented correctly, write 2 tests to check if the following occurs:

. The hello message is updated in the sender account with the specified hello string.
. The hello counter is incremented by +1.

Similar to the unit tests for the `validate()` function, a context is prepared using `createApplyAssetContext()` for the `apply()` function which can be passed to the function when calling it in each test.

As the context is the same for every test,  it is recommended to firstly prepare everything before the `beforeEach()` hook and directly call the `apply()` function with the context in each test.

.create_n_f_t_asset.spec.ts
[source,typescript]
----
describe('apply', () => {
    let stateStore: StateStore;
    let reducerHandler: ReducerHandler;
    let account: any;
    let context;
    let counter;

    beforeEach(() => {
        account = testing.fixtures.createDefaultAccount<HelloAccountProps>([HelloModule]);

        counter = { helloCounter: 0 };

        stateStore = new testing.mocks.StateStoreMock({
            accounts: [account],
            chain: { "hello:helloCounter": codec.encode(helloCounterSchema, counter)}
        });

        reducerHandler = testing.mocks.reducerHandlerMock;

        context = testing.createApplyAssetContext({
            stateStore,
            reducerHandler,
            asset: { helloString: 'Some statement' },
            transaction: { senderAddress: account.address, nonce: BigInt(1) } as any,
        });

        jest.spyOn(stateStore.chain, 'get');
        jest.spyOn(stateStore.chain, 'set');
        jest.spyOn(reducerHandler, 'invoke');
    });
});
----

Additionally, add the following interface at the top of the file:

[source,typescript]
----
export interface HelloAccountProps {
    hello: {
        helloMessage: "Hello World";
    };
}
----

It is used in the `beforeEach()` hook to create a default account with valid account properties.

The tests for the `valid cases` test are implemented as shown below:

[source,typescript]
----
describe('valid cases', () => {
    it('should update sender account hello message', async () => {
        await transactionAsset.apply(context);
        const updatedSender = await stateStore.account.get<HelloAccountProps>(account.address);

        expect(updatedSender.hello.helloMessage).toEqual("Some statement");
    });
    it('should increment the hello counter by +1', async () => {
        await transactionAsset.apply(context);

        expect(stateStore.chain.set).toHaveBeenCalledWith(
            CHAIN_STATE_HELLO_COUNTER,
            codec.encode(helloCounterSchema, { helloCounter: 1 })
        );
    });
});
----

=== Unit tests for the module

==== Imports
Add the following lines at the top of `hello_module.spec.ts` to import the required resources for the tests.

.test/unit/modules/hello/hello_module.spec.ts
[source,typescript]
----
import { helloCounterSchema, CHAIN_STATE_HELLO_COUNTER } from "./assets/create_hello_asset.spec"; // <1>
import { CreateHelloAsset } from '../../../../src/app/modules/hello/assets/create_hello_asset'; // <2>
import { testing, StateStore, codec } from 'lisk-sdk'; // <3>
import { HelloModule } from '../../../../src/app/modules/hello/hello_module'; // <4>
----

<1> The following is imported from the unit tests for the asset:

* `helloCounterSchema`: used to encode the hello counter for the database.
* `CHAIN_STATE_HELLO_COUNTER`: the key under which the hello counter is saved in the database.
<2> `CreateHelloAsset`: used to create a valid test transaction with a hello asset.
<3> The following is imported from the `lisk-sdk` package:

* `testing`: contains the functions of the Lisk SDK test suite.
* `StateStore`: See xref:{url_intro_modules_statestore}[the state store].
* `ReducerHandler`: See xref:{url_reducerhandler}[reducerHandler].
* `codec`: contains functions for encoding and decoding data.
<4> `HelloModule`: The module which is tested here.

==== Test preparations

.test/unit/modules/hello/hello_module.spec.ts
[source,typescript]
----
describe('HelloModule', () => {
    // Creates a new hello module
    let helloModule: HelloModule = new HelloModule(testing.fixtures.defaultConfig.genesisConfig);
    let asset = { helloString: "Hello test" };
    let stateStore: StateStore;
    let account = testing.fixtures.defaultFaucetAccount;
    let context;
    let channel = testing.mocks.channelMock;
    let validTestTransaction;

    // Overrides the init() method of the hello module to use the mocked channel
    helloModule.init({
        channel: channel,
        logger: testing.mocks.loggerMock,
        dataAccess: new testing.mocks.DataAccessMock(),
    });

    // Creates a valid hello transaction for testing
    validTestTransaction = testing.createTransaction({
        moduleID: 1000,
        assetClass: CreateHelloAsset,
        asset,
        nonce: BigInt(0),
        fee: BigInt('10000000'),
        passphrase: account.passphrase,
        networkIdentifier: Buffer.from(
            'e48feb88db5b5cf5ad71d93cdcd1d879b6d5ed187a36b0002cc34e0ef9883255',
            'hex',
        ),
    });

    // Creates an invalid hello transaction for testing
    invalidTestTransaction = testing.createTransaction({
        moduleID: 2,
        assetClass: TokenTransferAsset,
        asset: transferAsset,
        nonce: BigInt(0),
        fee: BigInt('10000000'),
        passphrase: account.passphrase,
        networkIdentifier: Buffer.from(
            'e48feb88db5b5cf5ad71d93cdcd1d879b6d5ed187a36b0002cc34e0ef9883255',
            'hex',
        ),
    });

    beforeEach(() => {
        // Creates a mock of the state store,
        // includse the hello counter in the chain state
        // and sets it to zero.
        stateStore = new testing.mocks.StateStoreMock({
            chain: { "hello:helloCounter": codec.encode(helloCounterSchema,  { helloCounter: 0 })}
        });

        jest.spyOn(channel, 'publish');
        jest.spyOn(stateStore.chain, 'get');
        jest.spyOn(stateStore.chain, 'set');
    });
});
----

==== Testing `afterTransactionApply()`

.`afterTransactionApply()` hook of `hello_module.ts`
[source,typescript]
----
public async afterTransactionApply(_input: TransactionApplyContext) {
    // Publish a `newHello` event for every received hello transaction
    // 1. Check for correct module and asset IDs
    if (_input.transaction.moduleID === this.id && _input.transaction.assetID === 0) {

        // 2. Decode the transaction asset
        let helloAsset : HelloAssetProps;
        helloAsset = codec.decode(
            helloAssetSchema,
            _input.transaction.asset
        );

        // 3. Publish the event 'hello:newHello' and
        // attach information about the sender address and the posted hello message.
        this._channel.publish('hello:newHello', {
            sender: _input.transaction.senderAddress.toString('hex'),
            hello: helloAsset.helloString
        });
    }
}
----

To verify that the function is implemented correctly, write 2 tests to check if the following occurs:

. A new event is published for each applied hello transaction.
. A new event is not published for each applied other transaction (not hello).

.test/unit/modules/hello/hello_module.spec.ts
[source,typescript]
----
describe('afterTransactionApply', () => {
    it('should publish a new event for each applied hello transaction.', async () => {
        context = testing.createTransactionApplyContext ({
            transaction: validTestTransaction,
        });

        await helloModule.afterTransactionApply(context);

        expect(channel.publish).toHaveBeenCalledWith("hello:newHello", {
            sender: account.address.toString('hex'),
            hello: asset.helloString
        });
    });
    it('should not publish a new event for each applied other transaction (not hello).', async () => {
        context = testing.createTransactionApplyContext ({
            transaction: invalidTestTransaction,
        });

        await helloModule.afterTransactionApply(context);

        expect(channel.publish).not.toBeCalled();
    });
});
----

==== Testing `afterGenesisBlockApply()`

.`afterGenesisBlockApply()` hook of `hello_module.ts`
[source,typescript]
----
public async afterGenesisBlockApply(_input: AfterGenesisBlockApplyContext) {
    // Set the hello counter to zero after the genesis block is applied
    await _input.stateStore.chain.set(
        CHAIN_STATE_HELLO_COUNTER,
        codec.encode(helloCounterSchema, { helloCounter: 0 })
    );
}
----

To verify that the function is implemented correctly, write 2 tests to check if the following occurs:

. The hello counter is set to zero, after the genesis block is applied.

.test/unit/modules/hello/hello_module.spec.ts
[source,typescript]
----
describe('afterGenesisBlockApply', () => {
    it('should set the hello counter to zero', async () => {
        context = testing.createAfterGenesisBlockApplyContext ({
            stateStore: stateStore,
        });

        await helloModule.afterGenesisBlockApply(context);

        expect(stateStore.chain.set).toHaveBeenCalledWith(
            CHAIN_STATE_HELLO_COUNTER,
            codec.encode(helloCounterSchema, { helloCounter: 0 })
        );
    });
});
----

==== Testing Actions

.actions of `hello_module.ts`
[source,typescript]
----
public actions = {
    amountOfHellos: async () => {
        let count = 0;
        const res = await this._dataAccess.getChainState(CHAIN_STATE_HELLO_COUNTER);
        if (res) {
            count = codec.decode(
                helloCounterSchema,
                res
            );
        }

        return count;
    },
};
----

To verify that the function is implemented correctly, write a test to check if the following occurs:

. The absolute amount of sent hello transactions are returned, when the action is invoked.

.test/unit/modules/hello/hello_module.spec.ts
[source,typescript]
----
describe('amountOfHellos', () => {
    it('should return the value of hello counter stored in chain state of the hello module', async () => {

        jest.spyOn(helloModule['_dataAccess'], 'getChainState').mockResolvedValue(codec.encode(helloCounterSchema, { helloCounter: 13 }));

        const helloCounter = await helloModule.actions.amountOfHellos();

        expect(helloCounter).toEqual({"helloCounter": 13});
    });
});
----

=== Run the tests

After the tests have been implemented, run the test suite again to check if all tests pass successfully:

./new_app/
[source,bash]
----
yarn run test
----

If the logic and the tests of the asset & module were implemented correctly, all tests should pass:

----
yarn run v1.22.10
$ jest --passWithNoTests
 PASS  test/unit/plugins/latest_hello/latest_hello_plugin.spec.ts (6.517 s)
 PASS  test/unit/modules/hello/assets/create_hello_asset.spec.ts (8.361 s)
 › 1 snapshot written.
 PASS  test/unit/modules/hello/hello_module.spec.ts (8.466 s)
 › 1 snapshot written.
 PASS  test/commands/account/create.spec.ts (9.077 s)

Snapshot Summary
 › 2 snapshots written from 2 test suites.

Test Suites: 4 passed, 4 total
Tests:       10 todo, 21 passed, 31 total
Snapshots:   2 written, 2 total
Time:        10.538 s, estimated 23 s
Ran all test suites.
✨  Done in 13.87s.
----

The implementation of the unit tests for the asset `CreateHelloAsset` is now complete.


//TODO: Write sections / pages for functional and integration testing
//== Functional tests
//== Integration tests

