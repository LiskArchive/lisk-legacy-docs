= How to create and sign a transaction
:toc: preamble
:toclevels: 3
:idprefix:
:idseparator: -

:sdk_docs: v6@lisk-sdk::
:docs_core: v4@lisk-core::
// :v_sdk: v6.0.0 (beta)

:url_sdk_client: lisk-sdk::references/lisk-elements/client.adoc
:url_integrate_tx_offline: integrate-blockchain/create-tx-offline.adoc
:url_protocol_txs: understand-blockchain/lisk-protocol/transactions.adoc#transaction-properties
//:url_sdk_cli: v6@lisk-sdk::client-cli.adoc
//:url_sdk_httpapi: lisk-sdk::plugins/http-api-plugin.adoc
//:url_core_cli: lisk-core::reference/cli.adoc
//:url_transaction_send: integrate-blockchain/integrate-UI/faucet-transfer.adoc#transfer-tokens
:url_integrate_decoding: integrate-blockchain/encode-decode.adoc
:url_api_node_rpc: api/lisk-node-rpc.adoc
:url_api_service_http: api/lisk-service-http.adoc
:url_api_service_rpc: api/lisk-service-rpc.adoc
:url_migration_guide: {sdk_docs}references/migration.adoc
:url_protocol_transactions: understand-blockchain/lisk-protocol/transactions.adoc#types
:url_modules: {sdk_docs}modules/index.adoc
:url_api_client: understand-blockchain/sdk/rpc.adoc#the-api-client

This guide describes different methods of creating and signing transactions. The steps are applicable for all the applications developed with the Lisk SDK [v6](https://www.npmjs.com/package/lisk-sdk/v/latest), including the Lisk Core.

//TODO: Update the default transactions

// == Default transactions

// The default modules already come with a set of xref:{url_protocol_transactions}[default transactions] out of the box, which can be sent to the blockchain application without writing any custom code.

// Each transaction type is defined in a module.
// More information regarding the different modules listed below can be found here on the xref:{url_module}[modules overview] page.

// * The Token module
// * The PoS module
// * The Interoperability module
// * The Auth module
// * The Legacy module

//TODO: Update the modules overview page to add the other modules, and links to the respective pages when they are completed, .eg. auth, interop, legacy modules.


== Transaction formats

A transaction can be represented in different formats.
It should be noted that in the Lisk SDK v6, the `moduleID`, `assetID`, and `asset` properties have been replaced with the `module` (name), `command` (name), and `params` respectively.
Further details can be found in the xref:{url_migration_guide}[SDK migration guide].

Below is an overview of all existing transaction formats and their use cases.

=== Buffer

The representation of the transaction binary data as a Buffer.

This format is used for applications-internal processes.

[source,js]
----
<Buffer 08 02 10 00 18 04 20 c0 84 3d 2a 20 51 33 af 79 44 ac f5 27 8b 03 10 a1 1c 06 13 4f 80 ab 45 46 d7 7d 1b 0e 02 7c 84 30 a7 d2 bb 92 32 2d 08 80 90 bc ... 107 more bytes>
----

=== Hex string

This is the hex string representation of the Buffer data.

It is sometimes used as an input or output format in the CLI when sending or creating transactions via the CLI.
//  (see xref:{url_sdk_cli}[Application CLI] and xref:{url_core_cli}[Lisk Core CLI]).

[source,js]
----
'08021000180420c0843d2a205133af7944acf5278b0310a11c06134f80ab4546d77d1b0e027c8430a7d2bb92322d088090bcfd0212149bd82e637d306533b1e1ad66e19ca0047faa1a6a1a0f4861707079206269727468646179213a4098a9ee2cde8354d014cfe6367d430be2713e102f37d92ab91f03db780407e5bf6d818a45c21c9f5518638dfc3c5365fc2d497b928e0b9d6337988df46a663a02'
----

=== Decoded object

The decoded transaction object.

Used as an input/output format for functions in xref:{url_references_elements}[Lisk Elements].
//for example the xref:{url_references_apiclient}[].

[source,js]
----
{
  module: 'token',
  command: 'transfer',
  fee: 1000000n,
  params: {
    tokenID: <Buffer 04 00 00 00 00 00 00 00>,
    amount: 800000000n,
    recipientAddress: 'lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj',
    data: 'Happy birthday!'
  },
  nonce: 0n,
  senderPublicKey: <Buffer 39 72 84 9f 2a b6 63 76 a6 86 71 c1 0a 00 e8 b8 b6 7d 88 04 34 cc 65 b0 4c 6e d8 86 df a9 1c 2c>,
  signatures: [
    <Buffer 96 0a 67 e3 04 7d bc 1b d2 e2 d1 30 6d 47 36 74 86 7e b8 1f df 90 ec 65 f5 75 9c 1a 1e c4 07 f5 ba f9 87 1c a7 63 75 55 7c 7b 23 e2 25 ae 60 cd da 65 ... 14 more bytes>
  ],
  id: <Buffer 08 de 6d b3 66 28 b1 f3 a7 17 5b 1b 88 9f 66 1f 9f 18 4a fa 3d f4 ee b0 15 69 8c 4a c2 de 0d 38>
}
----

=== JSON compatible object

A representation of the decoded transaction in a JSON compatible format.

For example, used for displaying the details of a transaction in the UI to the user.

[source,js]
----
{
  module: 'token',
  command: 'transfer',
  fee: '1000000',
  params: {
    tokenID: '0400000000000000',
    amount: '800000000',
    recipientAddress: 'lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj',
    data: 'Happy birthday!'
  },
  nonce: '0',
  senderPublicKey: '3972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c',
  signatures: [
    '960a67e3047dbc1bd2e2d1306d473674867eb81fdf90ec65f5759c1a1ec407f5baf9871ca76375557c7b23e225ae60cdda65fdce385bae076131ad5f7e39df0b'
  ],
  id: '08de6db36628b1f3a7175b1b889f661f9f184afa3df4eeb015698c4ac2de0d38'
}
----

== How to create a transaction

[TIP]
====
For convenience, it is recommended to use the API client or the CLI to communicate to a node for creating transactions.

In the case whereby a higher level of security is desired, it is also possible to create the transaction in a completely stand-alone offline environment.
Please check out the guide xref:{url_integrate_tx_offline}[] for more information.
====

.Transaction properties
[NOTE]
====
The properties of a transaction are described in detail in the Lisk Protocol on the xref:{url_protocol_txs}[Transactions] page.
====

=== via API client

// The API client allows connecting to a particular node API, and enables to get and post data to the node.
// It is part of the `lisk-api-client` package and is also included in the `lisk-client` and `lisk-sdk` packages.
// An example script how to create a transaction object via the API client is described in the code snippet below:

The API client allows external services/applications to connect and interact with a particular node.
The API client is part of the `@liskhq/lisk-api-client` package and is also included in the `@liskhq/lisk-client` and `lisk-sdk` packages.

An example script about how to create a transaction object via the API client is described in the code snippet below:

[NOTE]
The following example below demonstrates how to create a transaction using the Lisk API client. The API client can be instantiated using both `WS` and `IPC`.

The API client can also be used to query information from the node by invoking the supported endpoints over RPC. For more information regarding the same, please check the xref:{url_api_client}[RPC - The API client] page.

[source,js]
----
const { apiClient, cryptography, transactions } = require('@liskhq/lisk-client');

// For the apiClient to work in the WebSocket mode, the node must have the WebSocket mode enabled. This is true for IPC mode as well.
const RPC_ENDPOINT = 'ws://localhost:7887/rpc-ws';
// const IPC_ENDPOINT = '~/.lisk/lisk-core';`
let clientCache;

// Replace with the recipient address
const recipientAddress = 'lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj';

// Replace with the sender passphrase
const passphrase = 'attract squeeze option inflict dynamic end evoke love proof among random blanket table pumpkin general impose access toast undo extend fun employ agree dash';

const getClient = async () => {
	if (!clientCache) {
		clientCache = await apiClient.createWSClient(RPC_ENDPOINT);
		// clientCache = await apiClient.createIPCClient(IPC_ENDPOINT);
	}
	return clientCache;
};

getClient().then(async (apiClient) => {
	const privateKey = await cryptography.ed.getPrivateKeyFromPhraseAndPath(passphrase, "m/44'/134'/0'");
	constTx = await apiClient.transaction.create({
		module: 'token',
		command: 'transfer',
		fee: BigInt(transactions.convertLSKToBeddows('0.01')),
		params: {
			tokenID: Buffer.from('0400000000000000', 'hex'),
			amount: BigInt(transactions.convertLSKToBeddows('8')),
			recipientAddress,
			data: 'Happy birthday!'
		}
	}, privateKey);
	console.log('Signed transaction object: ', signedTx);

	process.exit(0);
});
----

.Example output
[%collapsible]
====
.Transaction object
[source, js]
----
Signed transaction object: {
module: 'token',
command: 'transfer',
fee: '1000000',
params: {
    tokenID: '0400000000000000',
    amount: '800000000',
    recipientAddress: 'lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj',
    data: 'Happy birthday!'
},
nonce: '0',
senderPublicKey: '3972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c',
signatures: [
    '960a67e3047dbc1bd2e2d1306d473674867eb81fdf90ec65f5759c1a1ec407f5baf9871ca76375557c7b23e225ae60cdda65fdce385bae076131ad5f7e39df0b'
],
id: '08de6db36628b1f3a7175b1b889f661f9f184afa3df4eeb015698c4ac2de0d38'
}
----
====

==== via IPC

Firstly, ensure that IPC is enabled.
This can be achieved by adding the IPC configuration option to your Lisk node's configuration file as shown below:

[source,json]
----
{
  "ipc": {
    "enabled": true,
    "path": "/path/to/ipc/socket"
  }
}


----
It will be necessary to replace the `/path/to/ipc/socket` in the snippet above with the path to your IPC socket file.
It will now be necessary to connect the IPC socket using a client library.
There are several libraries available, such as `lisk-client-ipc` for Node.js and `pylisk` for Python.

// Please check below as this appears to be incorrect.
Once a connection to the IPC socket has been established, a transaction can be created, which must contain all the necessary information for the transaction, such as the recipient address, amount, and fee.
An example using the `lisk-client-ipc` library can be seen in the snippet below:

[source,js]
----
const { APIClient } = require('@liskhq/lisk-api-client');
const { Transaction } = require('@liskhq/lisk-client-ipc');

const client = new APIClient(['https://my-lisk-node.com']);

const tx = new Transaction({
  moduleID: 2,
  assetID: 0,
  fee: '10000000',
  nonce: '1',
  senderPublicKey: 'sender-public-key',
  asset: {
    recipientAddress: 'lsk3wzmwGK3qY8JtYkZdRopDnNfVyj8PbW',
    amount: '100000000',
  },
});

client.transport
  .invoke('app:createTransaction', { transaction: tx.toJSON() })
  .then(response => {
    console.log(response.result);
  });

----
// The app:createTransaction endpoint can now be used to create the transaction

==== via WebSocket

Firstly ensure that WebSocket is enabled, this can be achieved by adding the `ws` configuration option to your node's configuration file as shown below:

[source,json]
----
{
  "ws": {
    "port": 8080,
    "path": "/ws"
  }
}
----
Replace `8080` with the port number you wish to use for WebSocket, and `/ws` with the path to the WebSocket endpoint.
Then connect to the Websocket endpoint using the desired library.
A transaction can now be created, which must contain all the necessary information such as the recipient address, amount, and fee.
An example using the `socket.io-client` library can be seen in the snippet below:

[source,js]
----
const io = require('socket.io-client');
const { APIClient } = require('@liskhq/lisk-api-client');
const { Transaction } = require('@liskhq/lisk-client');

const client = new APIClient(['https://my-lisk-node.com']);

const tx = new Transaction({
  moduleID: 2,
  assetID: 0,
  fee: '10000000',
  nonce: '1',
  senderPublicKey: 'sender-public-key',
  asset: {
    recipientAddress: 'lsk3wzmwGK3qY8JtYkZdRopDnNfVyj8PbW',
    amount: '100000000',
  },
});

const socket = io('https://my-lisk-node.com/ws');

socket.on('connect', () => {
  console.log('Connected to WebSocket');

  socket.emit('subscribe', 'transactions');

  socket.emit('transaction:create', tx.toJSON(), response => {
    console.log(response);
    socket.disconnect();
  });
});

socket.on('disconnect', () => {
  console.log('Disconnected from WebSocket');
});
----

=== via CLI

Any running node can be used to create a sendable transaction object.
// see xref:{url_sdk_cli}[Application CLI] and xref:{url_core_cli}[Lisk Core CLI].
//TODO: Add in above links when SDKv6 and Core docsv4 are released
An example for creating and sending a transfer transaction with the Lisk Core CLI is displayed below:

NOTE: If you are planning to run the same transaction through a sidechain client, then you can use nearly the same CLI commands as in the general Lisk CLI.
Just replace `lisk-core` with `./bin/run` in that case.

[source,bash]
----
$ lisk-core transaction:create token transfer 100000000
? Please enter passphrase:  [hidden]
Warning: Passphrase contains 24 words instead of expected 12. Passphrase contains 23 whitespaces instead of expected 11.
? Please enter: tokenID:  0400000000000000
? Please enter: amount:  800000000
? Please enter: recipientAddress:  lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj
? Please enter: data:  Happy birthday!
----

After all relevant information for the transaction is input, the encoded transaction is returned:

.Example output
[%collapsible]
====
----
{"transaction":"0a05746f6b656e12087472616e7366657218012080c2d72f2a203972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c32370a080400000000000000108090bcfd021a149bd82e637d306533b1e1ad66e19ca0047faa1a6a220f4861707079206269727468646179213a40ab69eabe03d73a69a867104a6e5eb820563921cf61ef6b7c036098ae46ac5a1c6311bae6006b55618f1c2b8288454a7d51eb2f10e1d4282a452ea35125bfd109"}
----
====

[TIP]
====
To also see the decoded transaction object on creation, add the `--json` parameter:

.Example
[%collapsible]
=====
[source,bash]
----
$ lisk-core transaction:create token transfer 100000000 --json
? Please enter passphrase:  [hidden]
Warning: Passphrase contains 24 words instead of expected 12. Passphrase contains 23 whitespaces instead of expected 11.
? Please enter: tokenID:  0400000000000000
? Please enter: amount:  800000000
? Please enter: recipientAddress:  lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj
? Please enter: data:  Happy birthday!
{"transaction":"0a05746f6b656e12087472616e7366657218042080c2d72f2a203972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c32370a080400000000000000108090bcfd021a149bd82e637d306533b1e1ad66e19ca0047faa1a6a220f4861707079206269727468646179213a40c06cd0ef375911528d491971296532dbd58725f0fccc0f23e6c0656c43e75ecd12635616117e64d005f1c9f2a55de7cf2d8f5cb961927d839d141a18faa80e08"}
{"transaction":{"module":"token","command":"transfer","fee":"100000000","nonce":"4","senderPublicKey":"3972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c","signatures":["c06cd0ef375911528d491971296532dbd58725f0fccc0f23e6c0656c43e75ecd12635616117e64d005f1c9f2a55de7cf2d8f5cb961927d839d141a18faa80e08"],"params":{"tokenID":"0400000000000000","amount":"800000000","recipientAddress":"lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj","data":"Happy birthday!"},"id":"f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a"}}
----
=====
====

==== Lisk Core CLI / Sidechain CLI

Once connected to the Lisk Core CLI, ensure the network required (either mainnet or testnet) is replaced with the url of the node you wish to establish the connection.
An example of a  how to create a transfer transaction using the `lisk-core transaction:create` command is shown in the snippet below:

[source,js]
----
const { createTransferTransaction } = require('@liskhq/lisk-transactions');
const { getNetworkIdentifier } = require('@liskhq/lisk-utils');
const { FeeEstimator } = require('@liskhq/lisk-client');

const feeEstimator = new FeeEstimator();

const passphrase = 'this is my secret passphrase';
const recipientAddress = 'lsk3wzmwGK3qY8JtYkZdRopDnNfVyj8PbW';
const amount = '100000000';

const networkIdentifier = getNetworkIdentifier('my_network_identifier');
const tx = createTransferTransaction({
    recipientAddress,
    amount,
    passphrase,
    networkIdentifier,
    fee: feeEstimator.calculateFee('transfer'),
});

console.log(JSON.stringify(tx, null, 2));
----

==== Sidechain client CLI

Once you are connected to a Lisk node, you can use the sidechain-client `transaction:create command` to create a new transaction.
// Need code snippet, etc..



== How to sign a transaction

The transaction object contains all the necessary information, such as the recipient address, amount, and fee.
It will then need to be signed with the users private key.
Once the transaction has been signed, it can then be broadcast to the network using the "broadcast" API endpoint of the Lisk node.
//TODO: Add in a link to the new Broadcast the transaction page when it is completed.

[source,js]
----
const { APIClient } = require('@liskhq/lisk-api-client');
const { TransactionBuilderFactory } = require('@liskhq/lisk-sdk');

const client = new APIClient(['https://my-lisk-node.com']);

const builder = new TransactionBuilderFactory(client);

const tx = builder
  .transfer()
  .amount('100000000')
  .recipientId('lsk3wzmwGK3qY8JtYkZdRopDnNfVyj8PbW')
  .nonce('1')
  .fee('10000000')
  .sign('my-secret-key')
  .build();

client.transactions.broadcast(tx.toString('hex')).then(response => {
  console.log(response.data);
});
----


// // == How to send the transaction
//
// [TIP]
// ====
// In case it is desired to have the transaction in a different format before sending, there are functions available to conveniently convert the transaction between the different formats, see xref:{url_integrate_decoding}[] for more information.
// ====
//
// === With Lisk Service
//
// How to send transactions to a Lisk node via Lisk Service.
//
// An existing transaction as hex string can be posted to a Lisk node via the Lisk Service either by using its HTTP or WebSocket APIs.
//
// ==== Via Lisk Service HTTP API
//
// cURL is one of the tools that can be used to send HTTP API requests to Lisk Service:
//
// [source,bash]
// ----
// curl -X POST -H "Content-Type: application/json" \
// -d '{"transaction": "0a05746f6b656e12087472616e7366657218042080c2d72f2a203972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c32370a080400000000000000108090bcfd021a149bd82e637d306533b1e1ad66e19ca0047faa1a6a220f4861707079206269727468646179213a40c06cd0ef375911528d491971296532dbd58725f0fccc0f23e6c0656c43e75ecd12635616117e64d005f1c9f2a55de7cf2d8f5cb961927d839d141a18faa80e08"}' \
// "http://localhost:9901/api/v3/transactions"
// ----

// [TIP]
// ====
// For more information, check out the xref:{url_api_service_http}[Mainnet HTTP API (Lisk Service)] reference.
// ====
// TODO: Update above link when Lisk Service 0.7 is released.

The following response will be displayed, if the transaction was posted successfully.

[source,json]
----
{
  "message":"Transaction payload was successfully passed to the network node",
  "transactionID":"f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a"
}
----

=== Via API client

An example of how to sign a transaction using the API client can be seen in the snippet below:

[source,js]
----
const { APIClient, cryptography } = require('@liskhq/lisk-client');

const client = new APIClient(['http://localhost:4000']);

const privateKey = 'f1d74c7ecfba5420d0e778e42fb748c25d2a0a19ce97448c5d5e42f22b670cb1';
const recipientAddress = 'lsk9j5fudguxsz5yh5sg5d5ax5r37t8rj69rmpcw2';
const amount = '100000000';
const fee = '10000000';

const transferTransaction = {
  moduleID: 2,
  assetID: 0,
  fee: fee,
  asset: {
    amount: amount,
    recipientAddress: recipientAddress
  },
  networkIdentifier: '1'
};

client.node.getNodeInfo().then(response => {
  transferTransaction.networkIdentifier = response.networkIdentifier;

  const transaction
----

==== Via Lisk Service WebSocket API

If you prefer to use the RPC WebSocket API of Lisk Service to post transactions, this can be achieved for example by writing a small JS script, and using the API client of the `socket.io-client` package:

[source,js]
----
// 1. Require the dependencies
const io = require('socket.io-client'); // The socket.io client
const jsome = require('jsome'); // Prettifies the JSON output

jsome.params.colored = true;

// Use local Service node
const WS_RPC_ENDPOINT = 'ws://localhost:9901/rpc-v3';
//Use public Service node
//const WS_RPC_ENDPOINT = "wss://service.lisk.com/rpc-v3";

// 2. Connect to Lisk Service via WebSockets
const socket = io(WS_RPC_ENDPOINT, {
  forceNew: true,
  transports: ['websocket']
});

// 3. Emit the remote procedure call
socket.emit('request', {
  jsonrpc: '2.0',
  method: 'post.transactions',
  payload: {"transaction":"0a05746f6b656e12087472616e7366657218042080c2d72f2a203972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c32370a080400000000000000108090bcfd021a149bd82e637d306533b1e1ad66e19ca0047faa1a6a220f4861707079206269727468646179213a40c06cd0ef375911528d491971296532dbd58725f0fccc0f23e6c0656c43e75ecd12635616117e64d005f1c9f2a55de7cf2d8f5cb961927d839d141a18faa80e08

"}
},
  answer => {
    jsome(answer);
    process.exit(0);
});
----

==== Via Lisk Service IPC

Firstly ensure that Lisk Core is running with IPC enabled, you can use a WebSocket client or a CLI tool such as `curl` to send commands to the IPC endpoint.
An example of how to sign a transaction using `curl` and the IPC endpoint can be seen in the snippet below:

[source,js]
----
const ipcPath = '/path/to/my/ipc/socket';
const data = {
    module: 'transaction',
    action: 'sign',
    data: {
        passphrase: 'this is my secret passphrase',
        transaction: {
            id: 'my_transaction_id',
            type: 0,
            fee: '10000000',
            senderPublicKey: 'my_sender_public_key',
            timestamp: 1530117600,
            asset: {
                amount: '100000000',
                recipientId: 'lsk3wzmwGK3qY8JtYkZdRopDnNfVyj8PbW'
            }
        }
    }
};

const command = `curl --unix-socket ${ipcPath} -X POST -H "Content-Type: application/json" -d '${JSON.stringify(data)}'`;

console.log(command);
----
After executing the above code, a `curl` command will be visible that can be used to sign the transaction via IPC.
Now copy and paste this command into your terminal to sign the transaction.



// === Via Lisk Service HTTP..? (This may not be required)

// [TIP]
// ====
// For more information, check out the xref:{url_api_service_rpc}[RPC endpoints (Lisk Service)] reference.
// ====
//TODO: Add in Tip and link above after v6 update.

// === With the application / node
=== CLI

Any running node can be used to sign a transaction object.
An example for signing a transfer transaction with the Lisk Core CLI is displayed below:

==== Lisk core

Firstly, enter the data of the transaction that you wish to sign, and the passphrase in the example below:

[source,bash]
----
./bin/run lisk transaction:sign [data] --passphrase [passphrase]
----
Now the following command below can be used to sign a transaction:

[source,js]
----
./bin/run lisk transaction:sign '{"amount":"100000000","recipientId":"lsk3wzmwGK3qY8JtYkZdRopDnNfVyj8PbW"}' --passphrase "this is my secret passphrase"
----

==== Sidechain client CLI

NOTE: If you are planning to run the same transaction through a sidechain client, then you can use nearly the same CLI commands as in the general Lisk CLI.
Just replace `lisk-core` with `./bin/run` in that case.
//check if the above is still valid?




// ==== Via the application CLI

// Any running node with an enabled API can be used to send a transaction object.
// see xref:{url_sdk_cli}[Application CLI] and xref:{url_core_cli}[Lisk Core CLI].
//TODO: Add in above links when SDKv6 and Core docs v4 are released
//An example for sending a transfer transaction, including an example for a sidechain client with the Lisk Core CLI is displayed below:

// [tabs]
// ====
// Lisk core::
// +
// --
// [source,bash]
// ----
// $ lisk-core transaction:send 0a05746f6b656e12087472616e7366657218042080c2d72f2a203972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c32370a080400000000000000108090bcfd021a149bd82e637d306533b1e1ad66e19ca0047faa1a6a220f4861707079206269727468646179213a40c06cd0ef375911528d491971296532dbd58725f0fccc0f23e6c0656c43e75ecd12635616117e64d005f1c9f2a55de7cf2d8f5cb961927d839d141a18faa80e08
//
//
// ----
// --
// ====
//
// [tabs]
// ====
// Sidechain client::
// +
// --
// [source,bash]
// ----
// $ bin/run transaction:send 0a05746f6b656e12087472616e7366657218042080c2d72f2a203972849f2ab66376a68671c10a00e8b8b67d880434cc65b04c6ed886dfa91c2c32370a080400000000000000108090bcfd021a149bd82e637d306533b1e1ad66e19ca0047faa1a6a220f4861707079206269727468646179213a40c06cd0ef375911528d491971296532dbd58725f0fccc0f23e6c0656c43e75ecd12635616117e64d005f1c9f2a55de7cf2d8f5cb961927d839d141a18faa80e08
//
//
// ----
// --
// ====


// ==== Via Lisk API client

// An example how to send a transaction via the API client is described in the code snippet below:


// Sending a transaction
// ==== Sending via an API client

// [source, js]
// ----
// const signedTxSentRes = await apiClient.transaction.send(signedTx);
// console.log('Transaction sent response: ', signedTxSentRes);
//
// ----

// [NOTE]
// It is also possible to send a transaction using the `transaction.send` method.
// For further information please see the example given regarding token transactions in the xref:{url_transaction_send}[Faucet and transferring tokens] page.
//TODO: uncomment the above note when Lisk docs beta is completed.

// .Example Response
// [%collapsible]
// ====
// [source, js]
// ----
// Transaction sent response:  {
// 	transactionId: '08de6db36628b1f3a7175b1b889f661f9f184afa3df4eeb015698c4ac2de0d38'
// }
// ----
// ====
//
// ==== Invoking the action `txpool_postTransaction`
//
// If the xref:{url_api_node_rpc}[RPC API for Lisk nodes] is enabled on a node, it is possible to send a transaction via WebSockets or IPC, depending on which protocol is enabled in the config.
//
// [source,js]
// ----
// const { apiClient, cryptography, transactions } = require('@liskhq/lisk-client');
//
// const RPC_ENDPOINT = 'ws://localhost:7887/rpc-ws';
//
// let clientCache;
//
// // Replace with the recipient address
// const recipientAddress = 'lskt8ovj2shbxrtno8xqqt7cnmzzygdkbt6brnvmj';
//
// // Replace with the sender passphrase
// const passphrase = 'attract squeeze option inflict dynamic end evoke love proof among random blanket table pumpkin general impose access toast undo extend fun employ agree dash';
//
// const getClient = async () => {
// 	if (!clientCache) {
// 		clientCache = await apiClient.createWSClient(RPC_ENDPOINT);
// 	}
// 	return clientCache;
// };
//
// getClient().then(async (apiClient) => {
// 	const privateKey = await cryptography.ed.getPrivateKeyFromPhraseAndPath(passphrase, "m/44'/134'/0'");
// 	const signedTx = await apiClient.transaction.create({
// 		module: 'token',
// 		command: 'transfer',
// 		fee: BigInt(transactions.convertLSKToBeddows('0.01')),
// 		params: {
// 			tokenID: Buffer.from('0400000000000000', 'hex'),
// 			amount: BigInt(transactions.convertLSKToBeddows('8')),
// 			recipientAddress,
// 			data: 'Happy birthday!'
// 		}
// 	}, privateKey);
//
// 	const signedTxHex = await apiClient.transaction.encode(signedTx).toString('hex');
//
// 	const signedTxSentRes = await apiClient.invoke("txpool_postTransaction", {
// 		transaction: signedTxHex,
// 	});
// 	console.log('Transaction sent response: ', signedTxSentRes);
//
// 	process.exit(0);
// });
// ----
//
// .Example output
// [%collapsible]
// ====
// ----
// Transaction sent response:  {
// 	transactionId: '08de6db36628b1f3a7175b1b889f661f9f184afa3df4eeb015698c4ac2de0d38'
// }
// ----
// ====
//
// ==== `txpool_dryRunTransaction`
//
// Finally, it is possible to 'dry run' a transaction, which returns the results of executing a transaction without actually submitting it to the chain.
// This offers the possibility of simulating an executed transaction, either via an API client or a CLI client, without actually adding it to the blockchain.
// This allows the end user to ensure they are functioning correctly before submitting them.
// In addition, this can also help to estimate the required fees for a transaction before actually submitting it.
//
// Specification::
//
// [cols="2,2,2,3",options="header",stripes="hover"]
// |===
// |Name
// |Type
// |Description
// |Sample
//
// |`transaction`
// |string
// |Hex encoded transaction data
// |0a05746f6b656e12087472616e7366657218042080c2d72f2a203972849f2ab66376a68671c1...
//
// |`skipVerify`
// |boolean
// |A boolean flag to indicate if the transaction dry run skips the verification steps
// |false
// |===
//
// --
// .Response
// [%collapsible]
// ====
// .Example output
// [source,js]
// ----
// {
//   result: 1,
//   events: [
// 	{
// 	  data: '0a14fc18da54f6ce01bf31195548460361dfdb83c20512036665651a0804000000000000002080c2d72f2800',
// 	  index: 0,
// 	  module: 'token',
// 	  name: 'lock',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a',
// 		'fc18da54f6ce01bf31195548460361dfdb83c205'
// 	  ],
// 	  height: 212
// 	},
// 	{
// 	  data: '0a149bd82e637d306533b1e1ad66e19ca0047faa1a6a1208040000000000000018c096b1022000',
// 	  index: 1,
// 	  module: 'token',
// 	  name: 'initializeUserAccount',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a',
// 		'9bd82e637d306533b1e1ad66e19ca0047faa1a6a'
// 	  ],
// 	  height: 212
// 	},
// 	{
// 	  data: '0a14fc18da54f6ce01bf31195548460361dfdb83c20512149bd82e637d306533b1e1ad66e19ca0047faa1a6a1a080400000000000000208090bcfd022800',
// 	  index: 2,
// 	  module: 'token',
// 	  name: 'transfer',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a',
// 		'fc18da54f6ce01bf31195548460361dfdb83c205',
// 		'9bd82e637d306533b1e1ad66e19ca0047faa1a6a'
// 	  ],
// 	  height: 212
// 	},
// 	{
// 	  data: '0a14fc18da54f6ce01bf31195548460361dfdb83c20512036665651a0804000000000000002080c2d72f2800',
// 	  index: 3,
// 	  module: 'token',
// 	  name: 'unlock',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a',
// 		'fc18da54f6ce01bf31195548460361dfdb83c205'
// 	  ],
// 	  height: 212
// 	},
// 	{
// 	  data: '0a14fc18da54f6ce01bf31195548460361dfdb83c2051208040000000000000018c89cbc022000',
// 	  index: 4,
// 	  module: 'token',
// 	  name: 'burn',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a',
// 		'fc18da54f6ce01bf31195548460361dfdb83c205'
// 	  ],
// 	  height: 212
// 	},
// 	{
// 	  data: '0a14fc18da54f6ce01bf31195548460361dfdb83c205121417ad887d46a197cd5c0caa5e70a746d24ef79a561a08040000000000000020b8a59b2d2800',
// 	  index: 5,
// 	  module: 'token',
// 	  name: 'transfer',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a',
// 		'fc18da54f6ce01bf31195548460361dfdb83c205',
// 		'17ad887d46a197cd5c0caa5e70a746d24ef79a56'
// 	  ],
// 	  height: 212
// 	},
// 	{
// 	  data: '0a14fc18da54f6ce01bf31195548460361dfdb83c205121417ad887d46a197cd5c0caa5e70a746d24ef79a5618c89cbc0220b8a59b2d',
// 	  index: 6,
// 	  module: 'fee',
// 	  name: 'generatorFeeProcessed',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a',
// 		'fc18da54f6ce01bf31195548460361dfdb83c205',
// 		'17ad887d46a197cd5c0caa5e70a746d24ef79a56'
// 	  ],
// 	  height: 212
// 	},
// 	{
// 	  data: '0801',
// 	  index: 7,
// 	  module: 'token',
// 	  name: 'commandExecutionResult',
// 	  topics: [
// 		'f3f537bbd52464d2f97c02f5ef0f9a805d19ad4f8ef1c7efa1da17cef0e5036a'
// 	  ],
// 	  height: 212
// 	}
//   ]
// }
//
// ----
// --