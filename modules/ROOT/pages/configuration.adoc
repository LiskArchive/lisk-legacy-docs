= Lisk Core Configuration
Mona Bärenfänger <mona@lightcurve.io>
:toc:
:source-highlighter: coderay
:v_sdk: master

== Structure

The root folder for all configurations is `config/`.
The *default* network is `devnet`.
If you want to connect to another network, specify the `network` when starting Lisk Core, as described in xref:administration/source.adoc#_command_line_options[Source Administration].
You can find *network specific configurations* under `config/<network>/config.json`, where `<network>` can be any of these values:

* `devnet`
* `alphanet`
* `betanet`
* `testnet`
* `mainnet`

[IMPORTANT]
====
Don’t override any value in files mentioned above if you need custom configuration.
The changes will be overwritten everytime you upgrade Lisk Core.
To use a custom configuration use environment variables or create your own `.json` file and pass it as xref:administration/source.adoc#_command_line_options[command line option].
====

Configurations will be loaded in the following order, each one will override the previous one:

. Default configuration values of modules and components of the xref:{v_sdk}@lisk-sdk::lisk-framework/index.adoc[Lisk Framework]
. Network specific configuration file
. A xref:administration/source.adoc#_command_line_options[custom configuration file] (if specified by the user)
. xref:administration/source.adoc#_command_line_options[Command line configurations], specified as command-line flags or `ENV` variables.

For development purposes, use `devnet` as the network option.
Other networks are specific to public Lisk networks.

The `config.json` file and a description of each configurable parameter.

include::partial$configuration.adoc[]

== API Access Control

Controlling access to a node plays a vital role in security.
The following configurable flags are available to control the access to your node:

[source%linenums,js]
----

"http_api": { <1>
    "enabled": true, <2>
    "access": { <3>
        "public": false, <4>
        "whiteList": ["127.0.0.1"], <5>
    },
----

<1> Contains options for the API module.
<2> Controls the API's availability. If disabled, no API access is possible.
<3> Contains API access options.
<4> If true, the API endpoints of the node are available to public.
<5> This parameter allows connections to the API by IP. Defaults to only allow local host.

The recommended setup is to configure a whitelist for only trusted IP addresses, such as your home connection.
Use IPV4 addresses only as the whitelist does not support IPV6.

To set up a public wallet, simply leave the `modules.http_api.access.whitelist` array empty.

For best security, disable all access setting `modules.http_api.enabled` to `false`.

NOTE: This last configuration may prevent monitoring scripts from functioning.

== Forging

To enable your node to forge, you need first to insert some encrypted data into the config file under the `chain.forging.delegates` array.
To encrypt your passphrase, we offer and recommend one of the following alternatives:

* xref:{v_sdk}@lisk-sdk::lisk-commander/user-guide/commands.adoc[Lisk Commander] via `encrypt passphrase` command
* xref:{v_sdk}@lisk-sdk::lisk-elements/packages/cryptography.adoc[Cryptography module of Lisk Elements]

We explain further the first alternative. First, make sure you have installed Lisk Commander in a secure environment.
Upon completion, please follow the commands below to generate the encrypted passphrase:

[source,bash]
----
$ lisk
lisk passphrase:encrypt --output-public-key
Please enter your secret passphrase: *****
Please re-enter your secret passphrase: *****
Please enter your password: ***
Please re-enter your password: ***
{
        "encryptedPassphrase": "iterations=1000000&cipherText=30a3c8&iv=b0d7322bf24e0dfe08462f4f&salt=aa7e26c9f4317b61b4f45b5c6909f941&tag=a2e0eadaf1f11a10b342965bc3bafc68&version=1",
        "publicKey": "a4465fd76c16fcc458448076372abf1912cc5b150663a64dffefe550f96feadd"
}
----

. In the first step, type in your passphrase and then type in the password you want to use for encryption.
. Afterward, you will get an `encryptedPassphrase` key-value pair.
. Create the JSON object and add it to your `config.json` under `chain.forging.delegates`:

[source,js,linenums]
----
"chain": { <1>
    "forging": { <2>
        "force": false, <3>
        "delegates": [ <4>
            {
                "encryptedPassphrase": "iterations=1&salt=476d4299531718af8c88156aab0bb7d6&cipherText=663dde611776d87029ec188dc616d96d813ecabcef62ed0ad05ffe30528f5462c8d499db943ba2ded55c3b7c506815d8db1c2d4c35121e1d27e740dc41f6c405ce8ab8e3120b23f546d8b35823a30639&iv=1a83940b72adc57ec060a648&tag=b5b1e6c6e225c428a4473735bc8f1fc9&version=1",
                "publicKey": "9d3058175acab969f41ad9b86f7a2926c74258670fe56b37c429c01fca9f2f0f"
            }
        ],
    },

"http_api": { <5>
            "forging": {
                "access": {
                    "whiteList": ["127.0.0.1", "REPLACE_ME"], <6>
                },
            },
----

<1> Contains options for the chain module.
<2> Contains forging options for delegates.
<3> Forces forging to be on, - only used on local development networks.
<4> List of delegates, who are allowed to forge on this node. To successfully enable forging for a delegate, the publickey and the encrypted passphrase need to be deposited here as JSON object.
<5> Contains options for the API module.
<6> Replace with the IP you will use to access your node

[arabic, start=4]
. Reload your Lisk Core process to make the changes in the config effective, e.g. for Binary install, run: `+bash lisk.sh reload+`

=== Check Forging

Use the following `curl` command to verify the forging status of your delegate:

[source,bash]
----
curl \
  http://127.0.0.1:7000/api/node/status/forging \
  -H 'cache-control: no-cache' \
  -H 'content-type: application/json'
----

The result should be something like this:

[source,json,linenums]
----
{
  "meta": {},
  "data": [
    {
      "forging": true,
      "publicKey": "9bc945f92141d5e11e97274c275d127dc7656dda5c8fcbf1df7d44827a732664"
    }
  ],
  "links": {}
}
----

=== Enable/Disable Forging

IMPORTANT: Remember that after restarting your Lisk node, you need to re-enable forging again.

[TIP]
====
The endpoint to perform this action is *idempotent*.

That means, the result is the same, no matter how many times you execute the query.
====

If you are running your Lisk Node from a local machine, you can enable forging through the API client, without further interruption.

Use the following curl command to *enable the forging* for your delegate:

[source,bash]
----
curl -X PUT \
  http://127.0.0.1:7000/api/node/status/forging \
  -H 'cache-control: no-cache' \
  -H 'content-type: application/json' \
  -d '{
          "publicKey": "YYYYYYYYY",
          "password": "XXX",
          "forging": true
      }'
----

Use the following curl command to *disable the forging* for your delegate:

[source,bash]
----
curl -X PUT \
  http://127.0.0.1:7000/api/node/status/forging \
  -H 'cache-control: no-cache' \
  -H 'content-type: application/json' \
  -d '{
          "publicKey": "YYYYYYYYY",
          "password": "XXX",
          "forging": false
      }'
----

* Where `publicKey` is the key for the delegate you want to enable/disable
* `password` is the password used to encrypt your passphrase in `config.json`
* `forging` is the boolean value to enable or disable the forging
* HTTP Port can be different based on your configuration, so check `httpPort` in your `config.json`

== SSL

[TIP]
====
We recommend to use a webserver like https://www.nginx.com/[NGINX] or https://httpd.apache.org/[Apache] to set up SSL for Lisk Core.
If you don’t have that opportunity, it’s possible to configure Lisk Core to handle SSL connections like described below.
====

[NOTE]
====
This step requires a signed certificate (from a CA, such as https://letsencrypt.org[Let’s Encrypt]) or a self-signed certificate.
You will need both the private and public keys in a location that is accessible to Lisk.
====

The next snippet highlights the essential parameters to enable SSL security on your node’s connections:

*SSL Configuration*

[source,js,linenums]
----
"http_api": {
    "ssl": {
        "enabled": false,           <1>
        "options": {
            "port": 443,            <2>
            "address": "0.0.0.0",   <3>
            "key": "path_to_key",   <4>
            "cert": "path_to_cert"  <5>
        }
    }
----

<1> Change FROM false TO true
<2> Default SSL Port
<3> Change only if you wish to block web access to the node
<4> Replace FROM path_to_key TO actual path to key file
<5> Replace FROM path_to_cert TO actual path to certificate file

WARNING: If the SSL Port configured above in `http_api.ssl.options.port` is a privileged port (below 1024), you must either allow the node to use the specified port with `+setcap+` or change the configuration to use a port outside of that range.

*Setcap:* Only required to grant Lisk access to port 443

[source,bash]
----
 sudo setcap cap_net_bind_service=+ep bin/node
----

To verify all you have properly configured your node, open the web client using `https://MY_IP_OR_HOST`.
You should now see a secure SSL connection.

== Logging

For monitoring or debugging your node, Lisk Core tracks all activity that happens in the node by creating log messages for them.

These log messages are grouped in different log levels, which makes it easy to define the level of detail for the logs.

We use https://github.com/trentm/node-bunyan[Bunyan] as logging library.
Bunyan allows simple and fast JSON logging for Node.js services.

=== Log Levels

[width="100%",cols="8%,92%",options="header",]
|===
|Log Level |Description
|None |No events are logged.

|Fatal(60) |The node is going to stop or become unusable now. An
operator should definitely look into this soon.

|Error(50) |Fatal for a particular request, but the node continues
servicing other requests. An operator should look at this soon(ish).

|Warn(40) |A note on something that should probably be looked at by an
operator eventually.

|Info(30) |Detail on a regular operation.

|Debug(20) |Anything else, i.e. too verbose to be included in ``info''
level.

|Trace(10) |Logging from external libraries used by your node or very
detailed application logging.
|===

=== Logging destinations

There are two possible output sources for logs: The `*file log stream*` and the `*console log stream*`.
Each output source can be configured independently inside of `config.json` under the options for the `logger` component.

==== Console log stream

The console log level displays the logs directly to the console where the Lisk Core process is started from.
It is useful for quick debugging or verifying that Lisk Core starts correctly.
Default log level for the console log stream is `none`.

*Example: Display the console log stream:*

[source,bash]
----
node dist/index.js | npx bunyan  <1>
----

<1> Pretty-prints console logs with log level equal or higher to the console log level.

For more information about the Bunyan CLI tool, please check out the official http://trentm.com/node-bunyan/bunyan.1.html[Bunyan Documentation].

==== File log stream

All logs that have equal or higher log levels than the in `config.json` specified file log level are saved in a `.log`-file for further analysis.
By default, the generated log files are saved inside of the `logs` folder of Lisk Core.
Default log level for the file log stream is `info`.

The file log stream is perfect to xref:monitoring.adoc#_log_monitoring[monitor the node via logs].

=== Logrotation

It is recommended to set up some form of log rotation for the log files of Lisk Core.
If no log rotation is set up, the log files may grow very big over time (depending on the specified file log level), and will eventually exceed the servers’ disk space limits.

Ubuntu systems, e.g. provide a service called `logrotate` for this purpose.
Please ensure Logrotate is installed on your system:

[source,bash]
----
logrotate --version
----

Next, go to the logrotate config directory and create a new logrotate file for Lisk Core:

[source,bash]
----
cd /etc/logrotate.d
touch lisk
----

Inside this file, define the parameters for the log rotation.

Example values:

[source,bash]
----
/path/to/lisk/logs/mainnet/*.log {
        daily                   <1>
        rotate 5                <2>
        maxage 14               <3>
        compress                <4>
        delaycompress           <5>
        missingok               <6>
        notifempty              <7>
}
----

<1> daily rotation
<2> keep the 5 most recent logs
<3> remove logs that are older than 14 days
<4> compress old log files
<5> compress the data after it has been moved
<6> if no log file is present, ignore
<7> do not rotate empty log files

After customizing the config to fit your needs and saving it, you can test it by doing a dry run:

[source,bash]
----
sudo logrotate /etc/logrotate.conf --debug
----
