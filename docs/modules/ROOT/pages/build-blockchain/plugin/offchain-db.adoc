= Creating an Off-chain database
Muhammad Talha <muhammad.talha@lightcurve.io>

:toc: preamble
:idprefix:
:idseparator: -
// :sectnums:
:docs_sdk: lisk-sdk::
// URLs
:url_github_guides_plugin: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/hello/hello_client/src/app/plugins/hello_info
:url_rocks_db: https://rocksdb.org/

// Project URLS
:url_lisk_db: {docs_sdk}references/lisk-elements/db.adoc
:url_plugin_schema: build-blockchain/plugin/schema-types.adoc#NewHelloEvent



Our plugin will need to store data of events generated by the `HelloModule`. So, On this page, you will learn:

====
* [x] Getting database's instance.
* [x] Getting and Setting NewHelloEvent's data
* [x] Getting and Setting Last Counter.
* [x] Getting and Setting Last event's height data
====

For the purpose of this guide, we want to store our event's data into xref:{url_lisk_db}[lisk-db]. Lisk DB is a key value store based on {url_rocks_db}[RocksDB].

Our database related operations will exist in a `db.ts` file which will exist in the plugin's root folder: `hello_info`. Create the new file in the said directory.

== Getting database's instance

A lisk-db instance requires a *datapath* and *name* of the database. The datapath is usually same as the datapath of the sidechain client and is mentioned in the _config.json_ or _custom_config.json_ file.

Add the following code to your `db.ts` for getting a db instance.

.getDBInstance
[source,typescript]
----
import { codec, db as liskDB, cryptography } from 'lisk-sdk';
import * as os from 'os';
import { join } from 'path';
import { ensureDir } from 'fs-extra';

// [...]

const { Database } = liskDB;
type KVStore = liskDB.Database;

// Returns DB's instance.
export const getDBInstance = async (
    dataPath: string,
    dbName = 'lisk-framework-helloInfo-plugin.db',
): Promise<KVStore> => {
    const dirPath = join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);
    await ensureDir(dirPath);
    return new Database(dirPath);
};

// [...]
----

== Getting and Setting event's data
Now that we have our function to get a db instance, lets create functions for setting and getting data from the database.

=== Setting event's data

As mentioned in the xref:{url_plugin_schema}[NewHelloEvent]'s Schema, we need to store the _sendersAddress_, the hello _message_ sent, and the _height_ of the block where a NewHelloEvent was emitted. 

Along with passing the aforementioned to our `setEventHelloInfo()`, we also need to pass a _counter_ value. This counter will be converted into a Buffer and will be concatenated with the Buffer value of our constant `DB_KEY_ADDRESS_INFO` to form a unique key for each NewHelloEvent. 

.setEventHelloInfo
[source,typescript]
----
// [...]

import { newHelloEventSchema, counterSchema, heightSchema } from './schemas';
import { Event, Counter, Height } from './types';
import { DB_KEY_ADDRESS_INFO, DB_LAST_COUNTER_INFO, DB_LAST_HEIGHT_INFO } from './constants';


// Stores event's data in the database.
export const setEventHelloInfo = async (db: KVStore, _lskAddress: Buffer, _message: string, _eventHeight: number, lastCounter: number): Promise<Event> => {
    try {
        const encodedAddressInfo = codec.encode(newHelloEventSchema, { senderAddress: _lskAddress, message: _message, height: _eventHeight });
        let dbKey = cryptography.utils.intToBuffer(lastCounter, 4);
        dbKey = Buffer.concat([dbKey, Buffer.from(':', 'utf8'), DB_KEY_ADDRESS_INFO]);
        await db.set(dbKey, encodedAddressInfo);
        console.log("************************************** Event's Data saved successfully in the database **************************************");
    } catch (error) {
        return (error);
    }
};

// [...]
----



=== Getting event's data

Getting the stored event's data is fairly simple. A counter value will be passed to the
`getEventHelloInfo()` function along with an instance of lisk-db.

The function will create a `dbKey` similarly to the `setEventHelloInfo()` by concatnating the buffer values of counter and the `DB_KEY_ADDRESS_INFO` constant. 

Based on the key, the function will return the corresponding event's data.

.getEventHelloInfo
[source,typescript]
----
// [...]

// Returns event's data stored in the database.
export const getEventHelloInfo = async (db: KVStore, lastCounter: number): Promise<Event> => {
    try {
        let dbKey = cryptography.utils.intToBuffer(lastCounter, 4);
        dbKey = Buffer.concat([dbKey, Buffer.from(':', 'utf8'), DB_KEY_ADDRESS_INFO]);
        const encodedAddressInfo = await db.get(dbKey);
        return codec.decode<Event>(newHelloEventSchema, encodedAddressInfo);
    } catch (error) {
        return error;
    }
};

// [...]
----

== Getting and Setting Counter
After the getters and setter for the event's data, we also want functions of getting and setting the counters.

=== Setting last counter

Every time an event's data is stored to the database, we intend to also store the last value of the counter inside our database. For that, we add the `setLastCounter()` function to our db.ts file.

Since we only intend to store a single value, there is no need to creating a series of unique keys so we will use our `DB_LAST_COUNTER_INFO` constant as the key for storing last counter.

.setLastCounter
[source,typescript]
----
// [...]

// Stores lastCounter for key generation.
export const setLastCounter = async (db: KVStore, lastCounter: number) => {
    try {
        const encodedCounterInfo = codec.encode(counterSchema, { counter: lastCounter });
        await db.set(DB_LAST_COUNTER_INFO, encodedCounterInfo);
        console.log("************************************** Counter saved successfully in the database **************************************");
    } catch (error) {
        return (error);
    }
}

// [...]
----

=== Getting last counter

The function will return the last counter stored in the database, the last counter will aid in fetching event's data.

.getLastCounter
[source,typescript]
----
// [...]

// Returns lastCounter.
export const getLastCounter = async (db: KVStore): Promise<Counter> => {
    try {
        const encodedCounterInfo = await db.get(DB_LAST_COUNTER_INFO);
        return codec.decode<Counter>(counterSchema, encodedCounterInfo);
    } catch (error) {
        return error;
    }
}

// [...]
----


== Getting and Setting Height
To avoid storing redundant event's data to our database, we will store the height of the last stored event into our database as well.

=== Setting Height
Similarly to the counter, we want to store the last value of height of block where an NewHelloEvent was emitted. For that, we will use the `DB_LAST_HEIGHT_INFO` constant as key.

.setLastEventHeight
[source,typescript]
----
// [...]

// Stores height of block where hello event exists.
export const setLastEventHeight = async (db: KVStore, lastHeight: number) => {
    try {
        const encodedHeightInfo = codec.encode(heightSchema, { height: lastHeight });
        await db.set(DB_LAST_HEIGHT_INFO, encodedHeightInfo);
        console.log("************************************** Height saved successfully in the database **************************************");
    } catch (error) {
        return (error);
    }
}

// [...]
----

=== Getting Height
As the name suggests, the `getLastEventHeight()` will return the last stored value of height for which an event was stored in the database. 

.getLastEventHeight
[source,typescript]
----
// [...]

// Returns height of block where hello event exists.
export const getLastEventHeight = async (db: KVStore): Promise<Height> => {
    try {
        const encodedHeightInfo = await db.get(DB_LAST_HEIGHT_INFO);
        return codec.decode<Height>(heightSchema, encodedHeightInfo);
    } catch (error) {
        return error;
    }
}

// [...]
----

After you add all the aforementioned functions, your `db.ts` file should like this:


.Database-script for HelloInfoPlugin
[%collapsible]
====
.hello_client/src/app/plugins/hello_info/db.ts
[source,typescript]
----
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unsafe-return */


import { codec, db as liskDB, cryptography } from 'lisk-sdk';
import * as os from 'os';
import { join } from 'path';
import { ensureDir } from 'fs-extra';
import { newHelloEventSchema, counterSchema, heightSchema } from './schemas';
import { Event, Counter, Height } from './types';
import { DB_KEY_ADDRESS_INFO, DB_LAST_COUNTER_INFO, DB_LAST_HEIGHT_INFO } from './constants';

const { Database } = liskDB;
type KVStore = liskDB.Database;

// Returns DB's instance.
export const getDBInstance = async (
    dataPath: string,
    dbName = 'lisk-framework-helloInfo-plugin.db',
): Promise<KVStore> => {
    const dirPath = join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);
    await ensureDir(dirPath);
    return new Database(dirPath);
};

// Returns event's data stored in the database.
export const getEventHelloInfo = async (db: KVStore, lastCounter: number): Promise<Event> => {
    try {
        let dbKey = cryptography.utils.intToBuffer(lastCounter, 4);
        dbKey = Buffer.concat([dbKey, Buffer.from(':', 'utf8'), DB_KEY_ADDRESS_INFO]);
        const encodedAddressInfo = await db.get(dbKey);
        return codec.decode<Event>(newHelloEventSchema, encodedAddressInfo);
    } catch (error) {
        return error;
    }
};

// Stores event's data in the database.
export const setEventHelloInfo = async (db: KVStore, _lskAddress: Buffer, _message: string, _eventHeight: number, lastCounter: number): Promise<Event> => {
    try {
        const encodedAddressInfo = codec.encode(newHelloEventSchema, { senderAddress: _lskAddress, message: _message, height: _eventHeight });
        let dbKey = cryptography.utils.intToBuffer(lastCounter, 4);
        dbKey = Buffer.concat([dbKey, Buffer.from(':', 'utf8'), DB_KEY_ADDRESS_INFO]);
        await db.set(dbKey, encodedAddressInfo);
        console.log("************************************** Event's Data saved successfully in the database **************************************");
    } catch (error) {
        return (error);
    }
};

// Stores lastCounter for key generation.
export const setLastCounter = async (db: KVStore, lastCounter: number) => {
    try {
        const encodedCounterInfo = codec.encode(counterSchema, { counter: lastCounter });
        await db.set(DB_LAST_COUNTER_INFO, encodedCounterInfo);
        console.log("************************************** Counter saved successfully in the database **************************************");
    } catch (error) {
        return (error);
    }
}

// Returns lastCounter.
export const getLastCounter = async (db: KVStore): Promise<Counter> => {
    try {
        const encodedCounterInfo = await db.get(DB_LAST_COUNTER_INFO);
        return codec.decode<Counter>(counterSchema, encodedCounterInfo);
    } catch (error) {
        return error;
    }
}

// Stores height of block where hello event exists.
export const setLastEventHeight = async (db: KVStore, lastHeight: number) => {
    try {
        const encodedHeightInfo = codec.encode(heightSchema, { height: lastHeight });
        await db.set(DB_LAST_HEIGHT_INFO, encodedHeightInfo);
        console.log("************************************** Height saved successfully in the database **************************************");
    } catch (error) {
        return (error);
    }
}

// Returns height of block where hello event exists.
export const getLastEventHeight = async (db: KVStore): Promise<Height> => {
    try {
        const encodedHeightInfo = await db.get(DB_LAST_HEIGHT_INFO);
        return codec.decode<Height>(heightSchema, encodedHeightInfo);
    } catch (error) {
        return error;
    }
}


----
====


