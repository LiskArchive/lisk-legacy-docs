= Understand Lisk blockchain
Muhammad Talha <muhammad.talha@lightcurve.io>
//Settings
:toc: preamble
:toclevels: 5
:page-toclevels: 3
:idprefix:
:idseparator: -
:fn_gpk: footnote:generatorPublicKey[Previously the `generatorPublicKey` property (see https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md#change-generator-public-key-to-generator-address[LIP 0055^] for more information).]
:fn_eventroot: footnote:eventroot[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0065.md[LIP 0065^] for the reason why it needs to be included in a block header.]
:fn_stateroot: footnote:stateroot[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0040.md[LIP 0040^] for the reason why it needs to be included in a block header.]
:fn_aggregate: footnote:aggregate[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0061.md[LIP 0061^] for more details.]
// URLs
:url_lip55: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md
// Project URLs
:url_intro_how_blockchain_works: intro/how-blockchain-works.adoc#state-machine
:url_intro_consensus: intro/how-blockchain-works.adoc#consensus-mechanisms
:url_understand_state_machine: understand-blockchain/state-machine.adoc
:url_understand_consensus: understand-blockchain/consensus/index.adoc
:url_understand_network: understand-blockchain/network.adoc
:url_understand_state_machine_tree: understand-blockchain/state-machine.adoc#the-blockchain-state-as-sparse-merkle-tree
:url_understand_sdk_commands: understand-blockchain/sdk/modules-assets.adoc#assets
:url_understand_sdk_modules: understand-blockchain/sdk/modules-assets.adoc
:lisk_service: lisk-service::
:docs_sdk: lisk-sdk::
:lisk_cross_chain_communication: understand-blockchain/interoperability/communication.adoc
:url_lisk_default_modules: {docs_sdk}modules/index.adoc

//External URLs
:url_lisk_roadmap: https://lisk.com/roadmap
:url_github_lns_dashboard: https://github.com/LiskHQ/lisk-sdk-examples/tree/nh-lisk-name-service/tutorials/lisk-name-service/lns-dashboard-plugin
:url_github_srs: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/social-recovery
:url_blog_benchmark: https://lisk.com/blog/development/benchmarking-lisk-core-v3.0.0-against-lisk-core-v2.1.6-0
:url_lisk_apps: https://lisk.com/ecosystem
//Project URLs
:url_introduction_modules: understand-blockchain/sdk/modules-assets.adoc
:url_introduction_plugins: understand-blockchain/sdk/plugins.adoc
:url_advanced_communication: understand-blockchain/sdk/rpc.adoc
:url_advanced_architecture_config: {docs_sdk}config.adoc
:url_advanced_communication_actions: understand-blockchain/sdk/rpc.adoc#actions
:url_advanced_communication_events: understand-blockchain/sdk/rpc.adoc#events
:url_protocol: understand-blockchain/lisk-protocol/index.adoc
:url_protocol_blocks: understand-blockchain/lisk-protocol/blocks.adoc
:url_protocol_consensus: understand-blockchain/lisk-protocol/consensus-algorithm.adoc#voting_and_weight
:url_protocol_transactions: understand-blockchain/lisk-protocol/transactions.adoc
:url_references_forger_plugin: {docs_sdk}plugins/forger-plugin.adoc
:url_references_monitor_plugin: {docs_sdk}plugins/monitor-plugin.adoc
:url_references_report_misbbehavior_plugin: {docs_sdk}plugins/report-misbehavior-plugin.adoc
:url_references_dpos_module: {docs_sdk}modules/dpos-module.adoc
:url_references_token_module: {docs_sdk}modules/token-module.adoc
:url_tutorials_nft: tutorial/nft.adoc
:url_tutorials_srs: tutorial/srs.adoc
:url_integrate_ui: integrate-blockchain/create-user-interface.adoc
:url_lisk_service: {lisk_service}index.adoc
:url_sdk_plugins: {docs_sdk}plugins/index.adoc


In the "Understand Lisk blockchain" category you learn the basic concepts of Lisk blockchain, Network and Protocol. The page discusses the topics and terms that are important to know when developing within the Lisk ecosystem.

This page gives an overview of what Lisk blockchain is? what are the key elements of a Lisk blockchain? what Lisk Network and Protocol is? what are blockchain applications and a basic structure for blockchain applications.

== What is Lisk Blockchain?

A blockchain is a chain of interconnected blocks that exist on various nodes distributed across a P2P network.
Each node keeps its copy of the blockchain protocol and its related data. 
It syncs periodically with other nodes to ensure that the nodes' records are up to date.

The Lisk blockchain also follows the same principle.
It is a combination of the main chain and many interconnected side chains.
Each side chain is registered to the main chain and is specific to a blockchain application.
Unlike Ethereum, where dApps have to share the same chain for their blockchain needs, Lisk provides the opportunity for each application to have its side chain.

This enables slower chain growth as information is only received from a single blockchain application.
It also provides faster block generation and lessens the burden on the network.
These side chains can also communicate with other side chains with the help of xref:{lisk_cross_chain_communication}[Lisk Cross Chain Communication].

Applications built with Lisk blockchains are called "blockchain applications". These applications can have customized logic, UIs, and a blockchain as their application's database.
An overview of Lisk Blockchain can be seen in the following diagram.

image::understand-blockchain/lisk-blockchain-overview.png["Lisk blockchain overview", 600, align="center"]

xref:{url_lisk_service}[Lisk Service] allows interaction with the blockchain network based on Lisk protocols. Lisk Service acts as a bridge between external software and the Lisk blockchain. We recommend the use of Lisk Service whenever data aggregation or communication to the Lisk network is required.







=== Lisk Network

A blockchain application generally consists of a network of servers, which are also called *nodes* in this context.

A typical network of nodes is illustrated in the diagram below:

image:intro/node-network.png[Side chain's node network, 900 ,align="center"]

.Shared on-chain logic, optional off-chain logic
****
All nodes in the network need to share the same on-chain logic as described in <<Modules>>. On the contrary, the off-chain logic as discussed in <<Plugins>> can differ from node to node.
****

==== P2P: Unstructured partial mesh network
The P2P network of nodes is unstructured, which means that all nodes are equal participants in the network.
It is also a partial mesh network, which means that every node is only connected to a small subset of nodes in the network.

Unstructured partial mesh networks allow nodes to share information in a very expeditious and secure manner with all other nodes.
They also can scale extremely well, even for large networks with thousands of connected nodes.


=== Lisk Protocol

A blockchain application consists of a network of nodes connected via P2P. Each node has an instance of Lisk Protocol and together, these nodes form a chain. The on-chain logic present in each instance of the Lisk protocol must be the same for a chain. However, the off-chain logic for each node can differ for a chain.

Each blockchain application has its blockchain known as a side chain. This side chain is registered with the main chain.

A node can only connect to a single network which can either be the main chain or the side chain.

The Lisk Protocol is divided into two layers:

* Application layer
* Engine layer

A detailed picture of the Lisk Protocol is present in the following architecture diagram.

image:architecture.png[lisk-framework-architecture, 900 , align="center"]


==== Application layer
The application layer handles state changes to the blockchain.
Its job is to connect with the outside world i.e. external services and software to send and receive data from them.
An application layer consists of a <<State machine>>, <<Modules>>, <<Plugins>>, and <<Configuration>>.

===== State machine

As the name suggests, a state machine is relevant to the states of a machine, Lisk protocol relies heavily on its state machine to mutate the state of a blockchain. 

* *States:* A state machine typically has a set of different states that it can enter. For example, a padlock represented as a state machine would have the two states "Open" and "Locked".

* *Transitions*: a set of allowable operations that change one state to another. For example, to change from the state "Open" to "Locked", a transition would be "Close padlock", and from "Locked" to "Open", it would be "Insert key & turn".

Lisk Protocol changes states with the help of modules, which define the on-chain logic for the blockchain application.

===== Modules

Modules aid the state machine to transition state of the blockchain with verified and validated data.
They contain on-chain logic which is part of the blockchain protocol.

For example, if Bob wants to sends 10 LSKs to Alice then, behind the scenes a module will verify the validity of such a request.
Upon validation and verification, the module will ask the state machine to transfer 10 LSKs from Bob's account to Alice's account.

TIP: Lisk provides a range of modules out of the box, for more information see xref:{url_lisk_default_modules}[]


====== When to create a module

xref:{url_introduction_modules}[Modules] are able to perform the following functions:

* Define how data is stored on the blockchain.
* Define logic which is executed per block footnote:block_footnote[For more information about blocks, check out the xref:{url_protocol_blocks}].
* Define logic which is executed per transaction footnote:tx_footnote[For more information about transactions, check the xref:{url_protocol_transactions}].


===== Plugins

Plugins represent the off-chain logic.
Plugins are not part of the Lisk protocol so, different plugins can be part of different nodes as shown in the network diagram.
Plugins are not directly part of the Lisk protocol and they can be added to the application layer as per necessity.


For example, consider a case where a node wants to investigate possible misbehaviours in the Lisk network. For that, node operator must gather all the blocks' data from the network, store it somewhere and analyse it to catch a misbehviour.

While this can be done from scratch, Lisk provides the xref:{url_references_report_misbbehavior_plugin}[Report Misbehavior Plugin] that listens to blocks data and automatically reports a node about a delegate's misbehaviour.

TIP: Lisk provides a set of plugins that can be injected into the Application layer when needed, see xref:{url_sdk_plugins}[Plugins].


===== When to create a plugin

xref:{url_introduction_plugins}[] are able to perform the following:

* Search the blockchain data.
* Aggregate the blockchain data.
* Provide a UI for the blockchain application.
* Automate the blockchain logic, such as automatically sending transactions.
* Add a proxy to the application interfaces.


A blockchain application does not include any plugins by default, however, to extend and customize the application, register the desired plugins to the application.

To add a new plugin to your application, either reuse an already existing plugin from another blockchain application, or create a new plugin based on the specific requirements of your application.


===== Configuration

==== Engine layer
The Engine layer acts as a bridge between the *Chain* and the *Application layer*. Engine is responsible for managing upcomming transactions, generating blocks, reaching consensus, storing chain\'s data to data stores and dipersing the new blocks to other nodes on the chain. An engine layer consists of the following domains:

* Transaction Pool
* Generator
* Consensus
* Chain
* RPC
* P2P

===== Transaction Pool
A transaction pool is where new transactions exist, before they become part of the blockchain.
It is similar to mempool in Ethereum.
Whenever a new transaction is created, it has to be sent to a transaction pool.
The transaction pool recieves the new transaction, verifies it with the help of the Application layer and then stores it in the transaction pool.

A node operator can configure the Transaction pool via the *Configurations* passed to the Application layer.
Node operator can change transaction properties like maximumTransactionsLimit, transactionPerAccount, minimumRequirementFee and minimumReplacementFee, etc.

Once a set of verified transactions are available in the pool, the are sent to the generator.

===== Generator
A generator is responsible for generating new blocks.
The generator picks up the transaction from transaction pool and orders it in terms of higher fees.
The generator then executes each transaction with the help of state machine to check their validity.
Once verified, the transactions are added to the block header.
A generator uses the last generated block and generator keys to generate a block.
For more information about Generator and Block Generation, see << URL>>

===== Consensus
The consensus domain applies the <<fork choice rule>> and checks the properties contained in the block header. It is also responsible for the replication of the same sequence of states among all nodes in the network.


===== Chain
After a consensus is reached about a block, and the state has been changed, the new blocks' information is passed to the Chain, which stores data of the new block into a data store. 
A chain is also responsible for fetching blockchain's data from the data stores.


===== P2P
The P2P domian is responsible for the network, sending and receiving data from nodes and maintaining an active connection with the Lisk Network. 
P2P network is responsible for the delivering the new blocks to all the peers in the network.
Once new information is recieved on a different node, all the steps mentioned earlier are executed at the node and after passing all checks, the reciever node adds the new block at their end as well.


===== Data Stores
Each node of a chain has various data stores that store both off-chain and on-chain data pertaining to that node. 

On Chain data includes but not limited to data regarding state of the chain, account balance, nonce, multi-signature keys, generators' information,and the Sparse Merkel tree, etc.
The blocks, transactions, events and assets are also part of the on-chain data among various other properties.

Off-chain data includes, node information, peer list, random hash, etc. 
It also contains information for generators i.e. last generated block, encrypted keys, etc.
Lisk also maintains information about legacy chains. Legacy informaction is off-chain and contains blocks from depriciated versions of the protocol.
















=== What are blockchain applications?

A blockchain application is any kind of application which uses its' own blockchain as a database layer.

More specifically, within the Lisk documentation, every time we talk about blockchain applications, we are referring to applications running on blockchains that are compatible with xref:{url_protocol}[].

Blockchain applications are highly customizeable as the Lisk protocol allows, creation of a scalable UI and business logic on top of Lisk Service. 

.Examples of blockchain applications
****
Examples of blockchain applications can be found in the tutorials, such as the xref:{url_tutorials_nft}[], or the xref:{url_tutorials_srs}[] application.

Additionally, check out the apps list at {url_lisk_apps}[^]
****


==== Blockchain applications vs. dApps
As blockchain applications are also in a sense decentralized applications, you may wonder what is the difference between blockchain applications and dApps, or if there is any difference at all.

In short, the main difference between dApps and blockchain applications is that blockchain applications each run on their own blockchain/sidechain, while dApps are sharing the blockchain network with other dApps.

dApps are generally constructed as smart contracts, for example on the Ethereum blockchain.
The development of blockchain applications is quite different, because it is much more similar to building a normal web application.

Most functionalities of smart contracts can be implemented in blockchain applications much easier and in a more straight forward manner.
However, there is one important difference here to dApps, when it comes to applying new <<on-chain-logic>> to the application:
New smart contracts can be directly applied on the running blockchain, while adding new on-chain logic to blockchain applications always requires a hard fork in the network.
Therefore, blockchain applications are less flexible than dApps, when it comes to uploading new logic on the running chain.

If the flexible characteristics of smart contracts are desired inside a blockchain application, it is of course also possible to develop a blockchain application which supports smart contracts.
For example, a new module could be added to the application, which accepts smart contracts.
This way it is possible to have the best of both worlds combined.

Additionally, smart contracts can reuse an already existing blockchain, which saves time when launching the application, as it is not necessary to take care of setting up an independent blockchain network, finding delegates footnote:delegate_footnote[For more information about delegates, check the xref:{url_protocol_consensus}[Consensus algorithm] page of the Lisk protocol.], etc.

Blockchain applications on the contrary rely on their own blockchain, and therefore also need to take care of maintaining their own network.
In the beginning, this will make the launch of the application slightly more complex, however, having an independent network comes with numerous benefits which are covered in the following paragraphs.

The Lisk documentation is referring to applications built with the Lisk SDK as "blockchain applications" and not "dApps". In order to clarify the difference here, applications are not sharing a common blockchain, but instead are each running on their own chain.
As a result blockchain applications have the following advantages:

* Lower transaction fees, as high traffic of one blockchain application has no effect on other blockchain applications.
* The blockchain for the application can be designed with the optimal characteristics for the specific use case, (for example by adjusting the block time or the number of delegates, or even changing the whole consensus algorithm).
* A much more scalable blockchain, as it only handles the data from one blockchain application.
Therefore it is growing much slower in size, and doesn't suffer so much from potential bottlenecks in the network, which can happen during times of high workload on many different dApps.
* Interoperability: Register a blockchain application as a sidechain to connect it to the Lisk Mainchain, (this is coming {url_lisk_roadmap}[soon^]).
This will provide seamless interoperability to the Lisk Mainchain and all of its' connected sidechains.





==== Communication interfaces / APIs

image::intro/communication-architecture.png[,1000 ,align="center"]

The communication architecture of the Lisk SDK allows internal application components and external services to communicate to the blockchain application via various channels.

The Lisk SDK provides two industry standard communication protocols: Inter Process Communication (IPC) and Web Sockets (WS).
The communication protocol of the blockchain application is changed in the xref:{url_advanced_architecture_config}[configuration].

It is possible to communicate to modules and plugins directly by invoking xref:{url_advanced_communication_actions}[actions] via a RPC request, or by subscribing to xref:{url_advanced_communication_events}[events].

It is recommended to use the IPC/WebSocket protocols where possible, as they provide a more enhanced performance in regard to the response times, (see the blog post: {url_blog_benchmark}[Benchmarking Lisk Core v3.0.0 against Lisk Core v2.1.6]).
// However, if you prefer an HTTP API, it is possible to add support for custom APIs by registering additional plugins, such as the xref:{url_references_http_plugin}[].
//We also recommend to try out xref:{url_service}[Lisk Service], which provides a much more comprehensive API compared to the HTTP API plugin.

For more information about the communication architecture, check out the xref:{url_advanced_communication}[endpoints explanation].

==== Frontend & backend

Blockchain applications usually consist of a frontend and a backend part, just as normal web applications.

In contrast to normal server-client applications, there is not one central backend, but rather a whole network of nodes which together secure and maintain the status of the blockchain.
Each node can handle complex business logic and provides a flexible and customizable API.
The blockchain itself is used as a database layer for the application.

The frontend allows users to interact conveniently with the blockchain application.
The implementation of a frontend is totally flexible.
For example, this can be achieved in the following ways:

[loweralpha]
. Create a new xref:{url_introduction_plugins}[plugin] for the blockchain application.
An example implementation of a frontend as a plugin is the {url_github_lns_dashboard}[LNS UI plugin] for the example application *Lisk Name Service*.
. Use your favorite framework/ programming language to develop a user interface, and communicate to the node via the <<communication-interfaces-apis>>.
One example is the frontend of the {url_github_srs}[SRS example application^] , which has been developed with React.js.
Another example is the UI for the Hello World application, detailed in the guide xref:{url_integrate_ui}[].
. For later requirements in a production environment, a middleware similar to Lisk Service should be used, which will aggregate the data from the blockchain network and possibly other 3rd party sources as well.
The frontend can then request this data via API requests from the middleware.

image::intro/ui-diagrams.png[]






