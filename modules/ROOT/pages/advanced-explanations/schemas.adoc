= Schemas
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc:
// URLs
:url_json_schema: https://json-schema.org/specification.html
:url_lip27_uniqueness: https://github.com/LiskHQ/lips/blob/master/proposals/lip-0027.md#uniqueness-of-encoding
// Project URLs
:url_introduction_modules_accountschema:: introduction/modules.adoc#account-schema
:url_introduction_modules_assetschema: introduction/modules.adoc#transaction-asset-schema

Schemas are used in various places in the Lisk SDK to encode and decode the data that is retrieved or pushed to the database.

NOTE: All blockchain related data such as blocks, transactions, account state, and chain state are encoded using `@liskhq/lisk-codec`.

Schemas are specifically used in the following:

* *modules* to define the xref:{url_introduction_modules_accountschema}[accountSchema], which consists of module-specific properties that are added to each account by the module.
* *assets*, for the xref:{url_introduction_modules_assetschema}[schema], which defines the data structure and formats of the transaction asset.
* modules and/or assets, to <<decoding-and-encoding-data,decode/encode>> other specific data from the database, such as blocks, transactions, account state, and chain state data.

== Format

Schemas must be defined as shown in the example below, which is a modified JSON schema (see the {url_json_schema}[JSON schema reference^]).

NOTE: If the data type of a property is either an `object` or an `array`, the `type` property must be used instead of `dataType`.

[tabs]

=====
Schemas::
+
--
[WARNING]
====
If the schema is used for serialization it is recommended to put all properties as `required` to guarantee the {url_lip27_uniqueness}[uniqueness of encoding^].
====

[source,js]
----
export const myAssetSchema = {
  $id: 'srs/recovery/create', // <1>
  type: 'object', // <2>
  required: ['friends', 'recoveryThreshold', 'delayPeriod'], // <3>
  properties: { // <4>
    friends: {
      type: 'array',
      fieldNumber: 1,
      items: {
        dataType: 'bytes',
      },
    },
    recoveryThreshold: {
      dataType: 'uint32',
      fieldNumber: 2,
    },
    delayPeriod: {
      dataType: 'uint32',
      fieldNumber: 3,
    },
  },
};
----

<1> Unique identifier of the schema throughout the system.
<2> Root type must be type `object`.
<3> Required properties.
<4> Properties of the schema.

--
Account schemas::
+
--
The following attributes are omitted in account schemas:

* `$id`
* `required`

The following attributes are added in the account schema:

* `default`: Default values for the different properties.

.Example of an account schema
[source,js]
----
const SRSAccountSchema = {
    type: 'object',
    required: ['config','status'],
    properties: {
      config: {
        fieldNumber: 1,
        type: 'object',
        required: ['friends'],
        properties: {
          friends: {
              type: 'array',
              fieldNumber: 1,
              items: {
                  dataType: 'bytes',
              },
          },
          recoveryThreshold: {
              dataType: 'uint32',
              fieldNumber: 2,
          },
          delayPeriod: {
              dataType: 'uint32',
              fieldNumber: 3,
          },
          deposit: {
            dataType: 'uint64',
            fieldNumber: 4,
          }
        },
        default: {
          friends: [],
          recoveryThreshold: 0,
					delayPeriod: 0,
        },
      },
      status: {
        fieldNumber: 2,
        type: 'object',
        properties: {
          rescuer: {
            dataType: 'bytes',
            fieldNumber: 1,
          },
          created: {
            dataType: 'uint32',
            fieldNumber: 2,
          },
          deposit: {
            dataType: 'uint64',
            fieldNumber: 3,
          },
          vouchList: {
            type: 'array',
            fieldNumber: 4,
            items: {
                dataType: 'bytes',
            },
          },
          active: {
            dataType: 'boolean',
            fieldNumber: 5,
          },
        },
      }
    },
  default: {
    config: {
      friends: [],
      recoveryThreshold: 0,
      delayPeriod: 0,
    },
    status: {
      active: false,
      vouchList: [],
      created: 0,
      deposit: BigInt(0),
      rescuer: Buffer.from(''),
    },
  },
};
----
--
=====

== Data types

The application data is stored in specific data types and structures in the database.

A schema always defines the data types that will be used in the database to store specific data.
When the data is retrieved from the database by a module or plugin of the blockchain application, it is returned as a JavaScript object or JSON, depending on the context:

Database::
These data types are used to save the respective data in the *database*.
JavaScript object::
These data types are used *internally* in the blockchain application to handle data from the database.
JSON::
Data that is provided by *actions* and *events* is always returned in JSON format.

.Table: Data types of the different data structures
[cols=",,",options="header",stripes="hover"]
|===
|Database
|JavaScript object
|JSON

|string
|string
|string

|uint32
|number
|number

|sint32
|number
|number

|uint64
|BigInt
|string

|sint64
|BigInt
|string

|bytes
|Buffer
|string in hex format

|boolean
|boolean
|boolean

|===

== Decoding and encoding data

To conveniently decode and encode the data structures, use the `codec` package, which can be imported from the `lisk-sdk`, `@liskhq/lisk-client` or installed separately with `@liskhq/lisk-codec`.

[source,js]
----
const {
    codec,
} = require('lisk-sdk');

const CHAIN_STATE_KEY = "myContext:moreContext";

const schema = {
    $id: "lisk/myContext/moreContext",
    type: "object",
    required: ["myCounter"],
    properties: {
        myCounter: {
            dataType: "uint32",
            fieldNumber: 1,
        },
    },
    default: {
      myCounter: 0
    }
};

// Get data from the database
let counterBuffer = await stateStore.chain.get(
    CHAIN_STATE_KEY
);

// Decode the retrieved data with the schema
let counter = codec.decode(
    schema,
    counterBuffer
);

// Mutate the retrieved data
counter.myCounter++;

// Post the data back to the database
await stateStore.chain.set(
    CHAIN_STATE_KEY,
    // Encode the data again before sending it to the DB
    codec.encode(schema, counter)
);
----
