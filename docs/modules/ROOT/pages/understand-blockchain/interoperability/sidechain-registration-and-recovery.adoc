= Sidechain Registration & Recovery
Chris Braithwaite <christopher.braithwaite@lightcurve.io>, Mona Bärenfänger <mona@lightcurve.io>
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
//URLs
:url_lip_45: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md
:url_lip_45_terminatechain: {url_lip_45}#terminatechain
:url_lip_53: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0053.md#verification
:url_typedoc_interop_module: {site-url}/lisk-sdk/v6/references/typedoc/classes/lisk_framework.SidechainInteroperabilityModule.html
:url_typedoc_interop_init_recovery: {site-url}/lisk-sdk/v6/references/typedoc/classes/lisk_framework.InitializeStateRecoveryCommand.html
:url_typedoc_interop_register_sidechain: {site-url}/lisk-sdk/v6/references/typedoc/classes/lisk_framework.RegisterSidechainCommand.html
:url_typedoc_interop_message_recovery: {site-url}/lisk-sdk/v6/references/typedoc/classes/lisk_framework.RecoverMessageCommand.html
:url_typedoc_interop_state_recovery: {site-url}/lisk-sdk/v6/references/typedoc/classes/lisk_framework.RecoverStateCommand.html
:url_typedoc_interop_terminate4liveness: {site-url}/lisk-sdk/v6/references/typedoc/classes/lisk_framework.TerminateSidechainForLivenessCommand.html
//Project URLs
:url_understand_statemachine_stores: understand-blockchain/state-machine.adoc#data-stores
:url_understand_interop: understand-blockchain/interoperability/index.adoc
:url_understand_interop_chainid: {url_understand_interop}#chain-identifiers
:url_understand_interop_sidechains: {url_understand_interop}#mainchain-sidechains
:url_ccc: understand-blockchain/interoperability/communication.adoc
:url_ccm: {url_ccc}#inducing-state-changes-across-chains-with-ccms
:url_ccu: {url_ccc}#relaying-ccms-in-a-ccu
:url_understand_module: understand-blockchain/sdk/modules-commands
:url_build_regsidechain: build-blockchain/register-sidechain.adoc
:url_build_regsidechain_mainchain: build-blockchain/register-sidechain.adoc#how-to-register-a-sidechain-on-the-mainchain
:url_build_regsidechain_sidechain: build-blockchain/register-sidechain.adoc#how-to-register-the-mainchain-on-the-sidehcain
//Footnotes
:fn_lip53: footnote:command[See {url_lip_53}[LIP 0053^] for more information about the verification of certificates.]

====
On this page, you'll learn about:

* [x] The lifecycle of a sidechain
* [x] The sidechain registration process
* [x] What happens when a sidechain is terminated
* [x] What data is stored on-chain to facilitate interoperability across chains
* [x] Data recovery from a terminated sidechain
====

== Life Cycle of a Sidechain

A xref:{url_understand_interop_sidechains}[sidechain] is always in one of the following three states:

. <<sidechain-registration,registered>>,
. <<active-sidechains,active>>, or
. <<terminated-sidechains,terminated>>.

.State diagram of a sidechain account on the Mainchain
image::understand-blockchain/interop/sidechain-lifecycle.png[]

:sectnums:
:sectnumlevels: 3

== Sidechain registration

//TODO: Add link to Lisk Mainchain page once it is created
The first step for sidechain to become interoperable with other sidechains and the Lisk Mainchain, is to register itself to the mainchain.

A sidechain is registered by performing the following steps:

. <<sidechain-registration-on-the-lisk-mainchain>>
. <<mainchain-registration-on-a-sidechain>>

NOTE: After a sidechain has been registered on the mainchain, it does not need to follow the <<liveness-condition>>, until the <<first-cross-chain-update>> has been included on the mainchain.

.Sidechain registration flow chart
image::understand-blockchain/interop/sidechain-registration.png[,300]

=== Sidechain registration on the Lisk Mainchain
A sidechain can be registered by any user account on the mainchain that has adequate funds to pay the required transaction fee.

TIP: Please check out the guide xref:{url_build_regsidechain_mainchain}[How to register a sidechain on the mainchain] for a step-by-step explanation about the process.

When a sidechain is registered on the mainchain, this creates new entries in the interoperability related data stores of the mainchain:

. A new sidechain account in the <<chain-substore>>.
. A new channel to the sidechain in the <<channel-substore>>.
. The list of active validators on the sidechain in the <<chain-validators-substore>>.
. An outbox root in the <<outbox-root-substore>>
. An new entry in the <<registered-names-substore>> for the sidechain.

=== Mainchain registration on a sidechain
Once the sidechain has been registered on the mainchain, a similar registration process should happen in the sidechain before the interoperable channel is opened between the two chains.

TIP: Please check out the guide xref:{url_build_regsidechain_sidechain}[How to register the mainchain on the sidehcain] for a step-by-step explanation about the process.

When the mainchain is registered on a sidechain, this creates new entries in the interoperability related data stores of the sidechain.

. A mainchain account in the <<chain-substore>>.
. A new channel to the mainchain in the <<channel-substore>>.
. The list of active validators on the mainchain in the <<chain-validators-substore>>.
. An outbox root in the <<outbox-root-substore>>
. It also initializes the <<own-chain-substore>> on the sidechain.

=== Registration CCM
Every time that a sidechain is registered on the mainchain and vice versa, a corresponding "registration" CCM is created and appended to the chain outbox.
The role of the registration cross-chain message is to allow for a safe activation of the channel between the sending and receiving chains.
It guarantees that when the CCU activating the channel is executed, a registration transaction has been included on the partner chain as well.

When a sidechain is registered on the mainchain, an ecosystem-wide chain ID and name are assigned to this chain.
The chain name, network ID, and the token used for the message fees are included in a registration message.
When the first cross-chain update containing messages is sent to the sidechain, the equality between the properties in the registration message and the ones in the interoperability store is verified.

== Active sidechains
If a sidechain receives the <<first-cross-chain-update>> from the mainchain, the status of the sidechain changes from `registered` to `active`.

This change means, that the receiving chain is now available to receive cross-chain messages and can interact with the sending chain.

At this point, the status of the sidechain account on the mainchain is updated to `active` and the <<liveness-condition>> is then enforced.
The liveness condition requires active sidechains to prove their liveness once every 30 days by including a CCU in the mainchain, or the sidechain account is terminated.

NOTE: *The liveness condition only needs to be fulfilled on the mainchain.*
That means, the mainchain account on the sidechain is not terminated, if the mainchain doesn't send a CCU to the sidechain withon 30 days.

=== First Cross-chain Update
The first cross-chain update containing messages from a given chain has a special function:
It will change the sending chain status in the chain account from `registered` to `active`.

There are some things to consider when sending the first CCU:

. It must contain a non-empty certificate
. The certificate is only valid if it allows the sidechain account to remain <<live-sidechains,live>> for at least 15 days.

When a sidechain is started and registered, the sidechain developers might decide to not activate the sidechain straight away (maybe to do further testing).
It could happen then (intentionally or not) that an old block header (almost 30 days old) is submitted to the mainchain to activate the sidechain.
This could result in the sidechain being terminated for liveness failure very soon after the activation (maybe only a few minutes later).

****
To prevent this issue (and without any significant drawbacks) *the first cross-chain update to be submitted on the mainchain must contain a certificate less than 15 days old.*
****
The sidechain has therefore at least 15 days to submit the next cross-chain update to the mainchain and start the regular posting of cross-chain updates.

=== Live sidechains

A sidechain is  `live`, if it is either in <<sidechain-registration,registered>> or <<active-sidechains,active>> status.

In other words:
Every sidechain that is not <<terminated-sidechains,terminated>>, is considered to be *live*.

== Terminated sidechains

When a sidechain is terminated, no cross-chain messages can be exchanged with it anymore.

Effectively, the sidechain is disconnected from the rest of the ecosystem, and assets (like tokens) cannot be moved to and from it anymore.
In particular, this means that users can not send the assets they were holding on the sidechain back to the original native chain (the chain where the asset was created).
The <<sidechain-recovery>> mechanism addresses this problem.

An active sidechain is terminated, if it fulfills any of the <<termination-causes>> described below.
When a chain is terminated, a "terminated state" account is created in the <<terminated-state-substore>>, storing the last certified state root of the terminated chain.

A cross-chain message targeting a terminated chain is bounced back to the mainchain instead of being forwarded.
When this happens, a <<sidechain-terminated-ccm>> is emitted by the mainchain, targeting the original sending chain.
When this message is processed, the chain is also terminated on the sending chain, blocking future messages to the terminated sidechain.

[CAUTION]
====
*The termination of a sidechain is permanent* and cannot be undone.

However, users can recover their tokens and CCMs from a terminated sidechain.
For more details on this topic, read <<sidechain-recovery>> covered later on this page.
====

=== Termination causes

A sidechain is terminated for the following reasons:

* The sidechain breaks the <<liveness-condition>>.
* The sidechain is <<sending-malicious-ccms>>.

==== Liveness condition

The liveness condition is defined as follows:

Active sidechains are required to prove their liveness to the mainchain at least once every 30 days.
This is done by including a CCU on the mainchain.

NOTE: *The liveness condition only needs to be fulfilled on the mainchain.*
That means, the mainchain account on the sidechain is not terminated, if the mainchain doesn't send a CCU to the sidechain withon 30 days.

Whenever a sidechain has violated the liveness condition, any user can submit a `TerminateSidechainForLiveness` command on the mainchain, and this will result in the sidechain being terminated.
This rule guarantees that users do not send funds to inactive sidechains and that users who have tokens in a sidechain which stops communicating with the ecosystem can recover their tokens.

==== Sending malicious CCMs

A sidechain is terminated, if it posts a CCU containing one or multiple malicious xref:{url_ccm}[CCMs].
Any xref:{url_understand_module}[module] of a sidechain client has the ability to terminate a sidechain account.
If the module receives a CCM that it considers to be malicious, it can call the  xref:{url_lip_45_terminatechain}[`terminateChain`] method of the Interoperability module to terminate the sidechain.

NOTE: Notice that a sidechain terminated for this reason is not terminated in the whole ecosystem.
For example, it could very well still be active and able to exchange messages with other chains.
However, communication with the sidechain that terminated it is interrupted.


==== Violating the Lisk Interoperability protocol

It is also possible for a sidechain to be terminated, if it violates the Lisk Interoperability protocol.

If a sidechain uses the Lisk Interoperability module, this should never happen.

But in case another custom module is used for interoperability, and it sends for example CCUs that don't follow the expected format, this can also lead to the termination of the sidechain.

=== Terminate Sidechain For Liveness command

The {url_typedoc_interop_terminate4liveness}[Terminate Sidechain For Liveness^] command is used to terminate a sidechain that violated the liveness condition.
The timestamp of the last certificate provided by the sidechain is checked against the current timestamp.
If the difference is greater than the maximum allowed timespan, the sidechain is terminated.

This command can only be submitted on the mainchain.

=== Sidechain Terminated CCM

The role of the sidechain terminated cross-chain message is to inform sidechains that another sidechain has been terminated on the mainchain and is unable to receive messages.
The message contains the ID of the terminated chain as well as the last certified state root of the terminated sidechain (as certified on the mainchain).
This value is used for the creation of the terminated state account (on the sidechain receiving the CCM), allowing state recoveries.

This message allows to inform sidechains about other terminated sidechains efficiently.
Indeed, this message will automatically trigger the creation of the terminated sidechain account as soon as the first message is unable to be delivered.
This also prevents further messages to be sent to already terminated sidechains.

=== Pending CCMs

If a sidechain is terminated, it can happen that some CCMs have been sent to the sidechain before the sending chain was aware that the sidechain is terminated.

Those CCMs that cannot be transmitted to the terminated chain anymore, and remain in the outbox on the mainchain are also called *pending CCMS*.

Pending CCMs can easily be recovered, please see <<ccm-recovery>> for more information.


== Sidechain recovery

The sidechain recovery process allows users to recover assets like tokens from a temrinated sidechain.
Furthermore, pending messages that were stuck unprocessed in the outbox of the terminated chain can be recovered as well, and their effect reverted on the sending chain.

NOTE: The sidechain recovery process is executed completely on the mainchain.
No connection or communication to the terminated sidechain is required to complete the recovery.

.Recovering tokens and NFTs form temrinated sidechains
video::iBVfttn_n-U[youtube,width=640]

[IMPORTANT]
====
For the sidechain recovery process, it is not important who is sending the recovery transactions:
The recovery process happens independently of the sender, and tokens and assets will always be recovered for the correct accounts.
That means, it is not possible to steal any tokens from a terminated chain by recovering them.

This makes it possible to provide <<recovery-as-a-service>> to users, to simplify the recovery process further.
====

=== CCM Recovery

It is possible to recover any <<pending-ccms>> that may have been unprocessed in the outbox of the terminated chain.
Subsequently, their effect can be reverted on the sending chain.

A <<initialize-message-recovery>> command is responsible for setting the outbox root and the inbox size in the terminated outbox account.
This is followed by issuing a <<recover-message>> command in order to recover any pending messages present in the outbox of the terminated sidechain.

The following information is needed to recover pending CCMs:

* Access to the cross-chain messages in the sidechain outbox.
* The entire tree of the sidechain outbox to be able to provide the inclusion proof.

TIP: All this information can be obtained from the CCMs.
So actually, to recover any pending CCMs, you only need to respective CCMs.

CCM recovery on the mainchain::
LSK amount returned to CCM sender.

CCM recovery on a sidechain::
CCM sent back to sending chain, where it is then reverted.

=== State recovery

The following information is needed to recover tokens and NFTs from a terminated chain:

* Access to the specific asset to recover from the sidechain
* The entire state tree authenticated by the last certified state root to be able to provide the inclusion proof.

State recovery on the mainchain::
LSK amount returned to respective account address on the mainchain

State recovery on a sidechain::
CCM sent back to sending chain, where it credits tokens / NFTs to the respective account.

////
This mechanism has been enabled in order to ensure that it is possible to recover a specific entry from a substore (i.e. the collection of key-value pairs with a common store prefix), of a module store of a terminated sidechain.
In this context, the term "recover" is referring to triggering a specific state transition defined as part of the relevant module protocol logic.
Specifically, it is based on the sidechain state root, `stateRoot`, set in the last certificate before sidechain termination.

In the context of the mainchain, a valid state recovery command can recover the assets that were held in the terminated sidechain.
In the context of a sidechain, it can recover an entry in a recoverable module store from a terminated sidechain.
//A recoverable module is classed as any module that exposes a recover function, which includes the Token module (for any custom token), and the xref:{url_nft_module}[NFT module].
This recovery mechanism requires the initialization commands.
////

==== Mainchain
* On the Lisk mainchain:

The users can recover the balance of LSK they had on a terminated sidechain by submitting a transaction with a <<State Recovery Command>>.
The users can recover a pending cross-chain message (CCM) from the sidechain account outbox by submitting a transaction with a <<Message Recovery Command>> on the Lisk mainchain.

Firstly regarding the mainchain, the process required is as follows, and is depicted in the illustration in figure 3 below:

1. The sidechain is terminated by submitting a <<Liveness Termination Command>>, or violating the token-module protocol.

a. A *terminated state account* containing the last certified state root of the sidechain is created in the state.

b. A User can start recovering assets with a *state recovery command* as covered above.

2. A *message recovery initialization command* is then sent.
This command contains the inbox size of the mainchain stored on the terminated sidechain, which indicates how many cross-chain messages were processed.

a. A *terminated outbox account* is created in the state.
This contains the outbox root of the terminated sidechain channel, and the inbox size provided with the message recovery initialization command.

b. A user can now recover pending messages with a <<Message Recovery Command>>.

.Recovery process from the mainchain.
image::understand-blockchain/interop/mainchain-recovery_v1.png[, align="center" ,500]

==== Sidechain
* On sidechains:

The users can recover the balance of any custom token they had on a terminated sidechain by submitting a transaction with a state recovery command.
The users can recover any assets they had on a terminated sidechain by submitting a transaction with a state recovery command.
The stored data of certain custom modules can be recovered from a terminated sidechain by submitting a transaction with a state recovery command.

On a sidechain, the process flow can occur in 3 scenarios which are described below and are also depicted in the corresponding 3 diagrams.

1. The sidechain is terminated for violating the protocol of the token module or of a custom module.

a. A terminated *state account* containing the mainchain last certified state root is created in the sidechain state.

b. A *state recovery initialization command* is sent.
This command contains the last certified state root (on the mainchain), of the terminated sidechain and an inclusion proof against the mainchain state root stored in the terminated state account.

c. A user is able to recover assets native to the sidechain with a *state recovery command*.

2. The sidechain receives a *sidechain terminated message* from the mainchain, indicating that a cross-chain message could not be delivered because the receiving chain was terminated.
This message contains the last certified state root (on the mainchain), of the terminated sidechain.

a. A *terminated state account* containing the sidechain’s last certified state root is created in the state.
However, it is important to note that in this case, the terminated sidechain state root is set immediately, and there is no need for a state recovery initialization command.

b. A user can recover assets native to the sidechain with a *state recovery command*.

3. The sidechain is terminated on the mainchain.

a. A *state recovery initialization command* is sent.
This command contains the last certified state root (on the mainchain), of the terminated sidechain and an inclusion proof against the last certified mainchain state root, proving the termination.

b. A *terminated state account* containing the sidechain’s last certified state root is created in the state.

c. A user can recover assets that are native to the sidechain with a *state recovery command*.

As mentioned above the steps from 1 to 3 are depicted graphically below in figure 4.

===== Message Recovery from the Sidechain Outbox

This message recovery mechanism is able to recover any CCM that is pending in the sidechain outbox.
Specifically, those CCMs that have not yet been included in the receiving sidechain.
Hence, this includes all the CCMs whose indices are larger than the last message index that the receiving sidechain reported to have included in its inbox on the mainchain.
Any user can submit a message recovery command to recover several CCMs simultaneously.
When the command is processed, the recovery is dependent on whether the sending chain is the mainchain or a sidechain.

However, it is important to note that users are not guaranteed to recover their CCMs in every situation.
Certain state information of the terminated sidechain might have been modified before the termination occurred, and this would make the recovered CCM application fail.
For example, in the case whereby escrowed LSK exists in the sidechain account on the mainchain, which could have been subtracted by prior malicious behavior in the terminated sidechain.

.Recovery process from the sidechain (Step 1)
image::understand-blockchain/interop/sidechain-recovery1-v2.png[, align="center" ,500]
.Recovery process from the sidechain (Step 2)
image::understand-blockchain/interop/sidechain-recovery2_v2.png[, align="center" ,500]
.Recovery process from the sidechain (Step 3)
image::understand-blockchain/interop/sidechain-recovery3-v2.png[, align="center" ,500]

=== Example: Recovery Process

In order to summarize the recovery process, a brief example of recovering assets/tokens from the state of a terminated sidechain is provided below:

1. A sidechain is terminated on the mainchain due to inactivity.
2. The last certified state root, i.e. the state root contained in the last certificate received from the sidechain, is stored in the terminated state account of the sidechain.
3. The user can recover the assets/tokens by sending a state recovery command.
This command contains an inclusion proof, proving the user balance on the sidechain against the state root stored in the terminated state account.
4. The funds are credited to the user's account on the mainchain.
5. Finally, the state root of the terminated sidechain is then updated accordingly.

Finally, there are certain data-availability requirements necessary to prepare a recovery transaction as listed below:

*Message recovery commands*:

- Access to the cross-chain messages in the sidechain outbox.
- The entire tree of the sidechain outbox must be able to provide the inclusion proof.

*State recovery commands*:

- Access to the specific asset to recover from the sidechain.
- The entire state tree authenticated by the last certified state root must be able to provide the inclusion proof.


Furthermore, this information has to be kept updated every time a recovery command is processed.
Additionally, it would be possible to employ third-party services that could offer to recover assets/tokens/messages for a nominal fee on behalf of the users.
It is envisaged that such services would deploy a mainchain and sidechain node to provide the data availability required to perform the recovery.

=== Recovery-as-a-Service
As explained above, there are certain data-availability requirements necessary to prepare a recovery transaction:

Message recovery commands::
* Access to the cross-chain messages in the sidechain outbox.
* The entire tree of the sidechain outbox to be able to provide the inclusion proof.

State recovery commands::
* Access to the specific asset to recover from the sidechain
* The entire state tree authenticated by the last certified state root to be able to provide the inclusion proof.

Furthermore, this information has to be kept updated every time a recovery command is processed.
Due to this fact, third-party services could offer to recover assets and messages on behalf of users.
These services will run a mainchain and sidechain node to provide the data availability, possibly in exchange for a small fee.

=== Recovery commands

==== Initialize State Recovery

The {url_typedoc_interop_init_recovery}[Initialize State Recovery^] command sets the sidechain state root in the terminated state account, so that state recovery commands can be issued.

This command has two purposes:

. It can be used to set the state root of a terminated state account on a sidechain, or
. to terminate another sidechain directly.

In the first case, the command contains an inclusion proof against the mainchain state root stored in the terminated state account, proving the value of the state root of the terminated sidechain.
In the second case, the command contains an inclusion proof against the mainchain state root, proving that another sidechain is either terminated or the <<liveness-condition>> is violated.

//TODO: Merge/ update content
===== State Recovery Initialization Command

This command is used to initialize a terminated state account, or to update the state root stored in it if it was not actually set yet.
It can only be submitted on a sidechain.

It contains an inclusion proof against the mainchain state root stored in the terminated state account, proving the value of the state root of the terminated sidechain.
Any user on the corresponding sidechain can send a transaction with this command and initiate the state recoveries with respect to the terminated sidechain.
A sidechain account can be terminated on a sidechain using the `terminateChain` function exposed by the Interoperability module.
In this case, the state root is generally not available and the terminated state account is created without setting the sidechain state root.
Instead, the account stores the mainchain state root at the time of termination.
A state recovery initialization command will in the future set the sidechain state root by giving an inclusion proof against this mainchain state root.

The command sets the sidechain state root in the terminated state account so that state recovery commands can be issued.

The transactions executing this command have the following:

* `module = MODULE_NAME_INTEROPERABILITY`

* `command = COMMAND_STATE_RECOVERY_INITIALIZATION`

The state recovery initialization command schema can be seen below:

.State Recovery Initialization Command
[%collapsible]
====
[source,js]
----
stateRecoveryInitializationParams = {
    "type": "object",
    "required": [
        "chainID",
        "sidechainAccount",
        "bitmap",
        "siblingHashes"
    ],
    "properties": {
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "sidechainAccount": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "bitmap": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "siblingHashes": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length": HASH_LENGTH
            },
            "fieldNumber": 4
        }
    }
}
----
====

* `chainID`: The ID of the sidechain whose terminated state account is to be initialized or updated.
* `sidechainAccount`: The sidechain chain account stored on the mainchain.
* `bitmap`: The bitmap of the inclusion proof of the sidechain account in the mainchain state tree.
* `siblingHashes`: The sibling hashes of the inclusion proof of the sidechain account in the mainchain state tree.
// Assumming that `trs` is a transaction with module ID `MODULE_NAME_INTEROPERABILITY`, and the command ID `COMMAND_STATE_RECOVERY_INITIALIZATION` is to be verified, this can be seen as shown in the following validation schema below:

.State Recovery Initialization Command Validation
[%collapsible]
====
[source,js]
----
def verify(trs: Transaction) -> None:
    if trs.params.chainID == CHAIN_ID_MAINCHAIN or trs.params.chainID == ownChainAccount.chainID:
        raise Exception("Chain ID is not valid.")

    # The commands fails if the sidechain is already terminated on this chain
    if terminatedStateAccount(trs.params.chainID) exists and terminatedStateAccount(trs.params.chainID).initialized == True:
        raise Exception("Sidechain is already terminated.")

    sidechainAccount = decode(chainAccountSchema, trs.params.sidechainAccount)
    # The commands fails if the sidechain is not terminated and did not violate the liveness requirement
    if sidechainAccount.status != CHAIN_STATUS_TERMINATED
        and chainAccount(CHAIN_ID_MAINCHAIN).lastCertificate.timestamp - sidechainAccount.lastCertificate.timestamp <= LIVENESS_LIMIT:
        raise Exception("Sidechain is not terminated.")

    queryKey = STORE_PREFIX_INTEROPERABILITY + SUBSTORE_PREFIX_CHAIN_DATA + sha256(trs.params.chainID)

    query = {
        "key": queryKey,
        "value": sha256(trs.params.sidechainAccount),
        "bitmap": trs.params.bitmap
    }

    proofOfInclusion = { "siblingHashes": trs.params.siblingHashes, "queries" : [query] }

    if terminatedStateAccount(trs.params.chainID) exists:
        if SMTVerify([queryKey], proofOfInclusion, terminatedStateAccount(trs.params.chainID).mainchainStateRoot) == False:
            raise Exception("State recovery initialization proof of inclusion is not valid.")
    else:
        if SMTVerify([queryKey], proofOfInclusion, chainAccount(CHAIN_ID_MAINCHAIN).lastCertificate.stateRoot) == False:
            raise Exception("State recovery initialization proof of inclusion is not valid.")

----

====

// To continue and process a transaction `trs` with the module ID `MODULE_NAME_INTEROPERABILITY` and the command ID 'COMMAND_STATE_RECOVERY_INITIALIZATION`, this implies the following logic as displayed below in the state recovery initialization command execution:

.State Recovery Initialization Command Execution
[%collapsible]
====
[source,js]
----
def execute(trs: Transaction) -> None:
    sidechainAccount = decode(chainAccountSchema, trs.params.sidechainAccount)
    if terminatedStateAccount(trs.params.chainID) exists:
        terminatedStateAccount(trs.params.chainID).stateRoot = sidechainAccount.lastCertificate.stateRoot
        terminatedStateAccount(trs.params.chainID).mainchainStateRoot = EMPTY_BYTES
        terminatedStateAccount(trs.params.chainID).initialized = True
    else:
        createTerminatedStateAccount(trs.params.chainID, sidechainAccount.lastCertificate.stateRoot)
----

====
Further information including, the `createTerminatedStateAccount` function can be found in {url_lip_45}[LIP 0045].

==== Initialize Message Recovery
Once a <<terminated-state-substore,terminated state>> account has been created on the mainchain, users can send this command to initialize the corresponding terminated outbox account.
The command sets the outbox root and the inbox size in the terminated outbox account, so that message recovery commands can be issued.

This command contains the channel account of the mainchain stored in the state of the terminated sidechain and an inclusion proof for it against the state root stored in the corresponding terminated state account.
The mainchain channel data is needed to get the number of messages that were processed in the terminated sidechain (corresponding to the inbox size of the channel).

* `chainID` : The ID of the sidechain whose terminated outbox account is to be initialized.
* `channel` : The channel of this chain stored on the terminated sidechain.
* `bitmap` : The bitmap of the inclusion proof of the channel in the sidechain state tree.
* `siblingHashes` : The sibling hashes of the inclusion proof of the channel in the sidechain state tree.

==== Recover State
The {url_typedoc_interop_state_recovery}[Recover State^] command is used to recover assets (for example fungible and non-fungible tokens) from a terminated sidechain.

The user proves the existence of an entry in the terminated sidechain state with an inclusion proof against the state root stored in the <<terminated-state-substore,sidechain terminated>> account.
The recovery of the state is then handled by the relevant module (for example, the token module would refund the user) and the state root is updated.

==== Recover Message
The {url_typedoc_interop_message_recovery}[Recover Message^] command is used to recover any <<pending-ccms>> from the outbox of a terminated sidechain.
The user proves with an inclusion proof validated against the outbox root stored in the terminated outbox account that the message is in the terminated sidechain outbox.
The message nonce is compared to the size of the inbox (also stored in the terminated outbox account) to check that the message had not been processed yet.
The recovered message is then bounced back to the original sending chain or processed directly if the sending chain is the mainchain.

:!sectnums:

== Interoperability data substores

Each sidechain stores data related to cross-chain interoperability in the xref:{url_understand_statemachine_stores}[Interoperability data store], maintained by the xref:{url_typedoc_interop_module}[Interoperability module].

The interoperability store consists of several substores, as shown in the diagram below.

.The Interoperability module store
image::understand-blockchain/interop/interop-store.png[,500]

Each box in the above diagram represents a substore, where the `storeKey` --> `storeValue` relation is indicated.

Each substore and its contained data is described in detail below.

=== Outbox root substore
The "outbox root" substore holds the root of the Merkle tree containing the messages targeting the respective partner chain for every registered sidechain.

It is initialized on the respective chain as part of the <<sidechain-registration>> process.

[NOTE]
====
The outbox root property is duplicated and additionally stored separately from all other properties of the chain account.
Storing the outbox root with a different substore prefix allows to separate the subtree corresponding to the outbox roots from the rest of the data in the interoperability store.
This choice allows for shorter inclusion proofs for the outbox root, as the other properties of the Interoperability module are not needed to recalculate the state root if the outbox root is known.
In particular, the inclusion proof contained in a CCU from a sidechain posted on the mainchain will contain only one hash.
====

[%collapsible]
====
Key:: Each store key is set to the ID of the partner chain `chainID`.

Value::
Each entry in the "outbox root" substore includes the following property:

* `root`: The root of the underlying Merkle tree of the partner chain outbox.
This value is initialized to `sha256(b"")`.
====

=== Own chain substore

The "own chain" substore stores the name and ID of the respective chain.

On the Lisk *mainchain*, the own chain account is present by default, and set to an object with properties:

[source,js]
----
{
    name: "lisk_mainchain",
    chainID: 00000000,
    nonce: 0
}
----

On a *sidechain*, the own chain account is initialized as part of the <<mainchain-registration-on-a-sidechain>>.

[%collapsible]
====
Key:: The store key is set to an empty string `""`.

Value::
The "own chain" substore consists of the following properties:

* `name`: The name of the sidechain registered on the mainchain with the sidechain registration command.
* `chainID`: The xref:{url_understand_interop_chainid}[chain ID] assigned to the sidechain on the mainchain after processing the sidechain registration command.
* `nonce`: The chain nonce, an incremental integer indicating the total number of CCMs sent from the chain.
====

=== Chain substore
The chain substore holds the chain accounts of other partner chains.

It is initialized on the respective chain as part of the <<sidechain-registration>> process.

[%collapsible]
====
Key:: Each store key is set to the ID of the partner chain `chainID`.

Value::
Each entry in the chain account substore includes the following properties:

* `name`: This property corresponds to the name of the sidechain as a string of characters.
It has to be unique in the ecosystem and contain only characters from the set `[a-z0-9!@$&_.]`.
For the mainchain account on a sidechain, this property is initialized to the string `"lisk_mainchain"`.
For a sidechain account on the mainchain, this property is set by the sender of the xref:{url_typedoc_interop_register_sidechain}[Register Sidechain command].
* `lastCertificate`: This property holds some information from the certificate posted contained in the last CCU from the partner chain.
It is an object containing the following properties:
** `height`: The height contained in the last certificate from the partner chain.
It is used to validate a certificate{fn_lip53} (certificates must contain block headers with increasing heights).
The default value of this property is `0`.
** `timestamp`: The timestamp contained in the last certificate from the partner chain.
On the mainchain, it is used to check that the sidechain chain fulfills the <<liveness-condition>>.
The default value of this property is `0`.
** `stateRoot`: The state root contained in the last certificate from the partner chain.
It is used to validate the inclusion proof of the cross-chain messages contained in a CCU and to verify the validity of the token recovery command.
The default value of this property is `sha256(b"")`.
** `validatorsHash`: The validators hash contained in the last certificate from the partner chain.
This value always corresponds to the hash calculated from the validators data substore entry for the partner chain.
The default value of this property is the constant `sha256(b"")`.
* `status`: This property stores the current status of the partner chain account.
As explained in <<life-cycle-of-a-sidechain>>, there are 3 possible statuses: `active`(0), `registered`(1), and `terminated`(2).
The default value of this property is `0`, corresponding to the `registered` status.
====

=== Channel substore
The channel substore holds information about the inbox and outbox with other partner chains.

It is initialized on the respective chain as part of the <<sidechain-registration>> process.

[%collapsible]
====
Key:: Each store key is set to the ID of the partner chain `chainID`.

Value::
Each entry in the channel substore includes the following properties:

* `inbox`: The data structure containing information about the cross-chain messages received from the partner chain, organized in a regular Merkle tree (specified for the Lisk protocol in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md#regular-merkle-trees)).
The underlying Merkle tree of the inbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md).
It contains the following properties:
** `root`:  The root of the Merkle tree.
The default value of this property is `sha256(b"")`.
** `appendPath`: An array of hashes necessary to append new data to the tree efficiently.
The default value of this property is an empty array.
** `size`: The current size of the tree, i.e. the number of cross-chain messages received from the partner chain and processed.
The default value of this property is 0.
* `outbox`: The data structure containing information about the cross-chain messages sent to the partner chain, organized in a regular Merkle tree.
The underlying Merkle tree of the outbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md).
It contains the following properties:
** `root`:  The root of the Merkle tree.
The default value of this property is `sha256(b"")`.
** `appendPath`: An array of hashes necessary to append new data to the tree efficiently.
The default value of this property is an empty array.
** `size`: The current size of the tree, i.e. the number of cross-chain messages sent to the partner chain.
The default value of this property is 0.
* `partnerChainOutboxRoot`: The value of this property is set to the outbox root computed from the last CCU from the partner chain.
It is used to validate the cross-chain messages contained in a future CCU when the CCU does not certify a new outbox root.
The default value of this property is the constant `sha256(b"")`.
* `messageFeeTokenID`: This property is the token ID of the token used to pay for the cross-chain message fees.
The default value is `messageFeeTokenID = Token.getTokenIDLSK()`, corresponding to the LSK token.
* `minReturnFeePerByte`: This property is the minimum fee per byte to automatically send back a CCM from the partner chain in case of exeuction errors.
In particular, the CCM fee must be larger or equal than the product of its size in bytes and `minReturnFeePerByte`.
The value used in channels between mainchain and sidechains is `minReturnFeePerByte` = `1000` Beddows.
====

=== Chain validators substore

The "chain validators" substore holds information about the validators of other partner chains.

It is initialized on the respective chain as part of the <<sidechain-registration>> process.

[%collapsible]
====
Key:: Each store key is set to the ID of the partner chain `chainID`.

Value::
Each entry in the "chain validators" substore includes the following properties:

* `activeValidators`: An array of objects corresponding to the set of validators eligible to sign the certificates from the partner chain.
Each entry contains the following properties:
** `blsKey`: The BLS public key used to sign certificates.
** `bftWeight`: An integer indicating the weight of the corresponding BLS public key for signing a certificate.
* `certificateThreshold`: An integer setting the required cumulative weight needed for the certificate signature to be valid.
For the mainchain account on a sidechain, the `activeValidators` and `certificateThreshold` properties are initialized by the mainchain registration command.
For a sidechain account on the mainchain, they are set by the sidechain registration command.
====

=== Terminated state substore

A "terminated state" account is created as part of the `terminateChain` function, as part of the processing of a <<sidechain-terminated-ccm>>, as part of the processing of a channel terminated CCM, or as part of the processing of a "Recover State" command.

It is initialized with the information contained in the last sidechain certificate posted on the mainchain.

[%collapsible]
====
Key::
The store key is set to the ID of the terminated chain `chainID`.

Value::
Each entry in the "terminated state" substore includes the following properties:

* `stateRoot`: The state root of the terminated chain, where `chainID` is the chain ID of the terminated chain.
If the account is not initialized, it is set to `sha256(b"")` instead.
* `mainchainStateRoot`: The state root of the mainchain at the moment in which the chain was terminated.
If the account is initialized, it is set to `sha256(b"")` instead.
* `initialized`: A boolean value, indicating whether the terminated state account has been initialized, i.e. if the `stateRoot` property has been set.
====

=== Terminated outbox substore

A "terminated outbox" account is created as part of the processing of a "Recover Message" command.

A data structure holding the outbox root along with the mainchain inbox size from the terminated sidechain, indicating the number of messages that were processed on it.

[%collapsible]
====
Key::
The store key is set to the ID of the terminated chain `chainID`.

Value::
Each entry in the "terminated outbox" substore includes the following properties:

* `outboxRoot`: The outbox root of the terminated chain, where `chainID` is the chain ID of the terminated chain.
* `outboxSize`: The outbox size of the terminated chain, where `chainID` is the chain ID of the terminated chain.
* `partnerChainInboxSize`: The number of cross-chain messages processed in the terminated chain, set to the `partnerChainInboxSize` property contained in the "Recover Message" command.
====

=== Registered names substore
In order to process sidechain registration commands more efficiently, it is convenient to store on the mainchain the names already registered in the ecosystem to quickly check the uniqueness of the sidechain name.
This substore contains the names of all chains in the ecosystem.

NOTE: The "registered names" substore is only present on the mainchain.

A new entry in the substore is created as part of the <<sidechain-registration-on-the-lisk-mainchain>>.

An entry for the Lisk Mainchain is present by default, where:

* The store key is set to `"lisk_mainchain"`.
* The store value is an object with chainID == getMainchainID(), serialized using the JSON schema registeredNamesSchema.

[%collapsible]
====
Key:: The chain name (String).

Value::
Each entry in the "terminated outbox" substore includes the following properties:

* `chainID`: The ID of the chain.
====

